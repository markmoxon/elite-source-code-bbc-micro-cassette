\ ******************************************************************************
\
\ ELITE GAME SOURCE
\
\ ******************************************************************************

INCLUDE "elite-header.h.asm"

_REMOVE_COMMANDER_CHECK = TRUE AND _REMOVE_CHECKSUMS
_ENABLE_MAX_COMMANDER   = TRUE AND _REMOVE_CHECKSUMS

GUARD &6000             \ Screen buffer starts here

\ ******************************************************************************
\
\ Configuration variables
\
\ ******************************************************************************

NOST = 18               \ Maximum number of stardust particles

NOSH = 12               \ Maximum number of ships in our local bubble of the
                        \ universe (counting from 0, so there are actually 13
                        \ ship slots)

COPS = 2                \ Ship type for a Viper
MAM  = 3                \ Ship type for a Mamba
THG  = 6                \ Ship type for a Thargoid
CYL  = 7                \ Ship type for a Cobra Mk III (trader)
SST  = 8                \ Ship type for the space station
MSL  = 9                \ Ship type for a missile
AST  = 10               \ Ship type for an asteroid
OIL  = 11               \ Ship type for a cargo canister
TGL  = 12               \ Ship type for a Thargon
ESC  = 13               \ Ship type for an escape pod

POW  = 15               \ Pulse laser power

NI%  = 36               \ Number of bytes in each ship's data block (as stored
                        \ in INWK and K% and pointed to by the UNIV table)

\ ******************************************************************************
\
\ MOS definitions
\
\ ******************************************************************************

OSBYTE = &FFF4          \ The OS routines used in Elite. OSBYTE is used three
OSWORD = &FFF1          \ times, OSWORD is used twice, and OSFILE is used just
OSFILE = &FFDD          \ once

SHEILA = &FE00          \ Memory-mapped space for accessing internal hardware,
                        \ particularly the video ULA, 6845 CRTC and 6522 VIAs

VSCAN  = 57             \ Defines the split position in the split screen mode

VEC    = &7FFE          \ Set to the original IRQ1 vector by elite-loader.asm

SVN    = &7FFD          \ Set to 1 while we are saving a commander, 0 otherwise

X      = 128            \ The centre coordinates of the 256 x 192 mode 4 space
Y      = 96             \ view

\ ******************************************************************************
\
\ Function key numbers
\
\ ******************************************************************************

f0 = &20                \ The internal key numbers of the function keys (see
f1 = &71                \ the Advanced User Guide for a list of internal key
f2 = &72                \ numbers)
f3 = &73
f4 = &14
f5 = &74
f6 = &75
f7 = &16
f8 = &76
f9 = &77

\ ******************************************************************************
\
\ Macro definitions
\
\ ******************************************************************************

MACRO CHAR x
  EQUB x EOR 35         \ Insert ASCII character "x"
ENDMACRO

MACRO TWOK n
  EQUB n EOR 35         \ Insert two-letter token <n>
ENDMACRO

MACRO CTRL n
  EQUB n EOR 35         \ Insert control code token {n}
ENDMACRO

MACRO RTOK n
  IF n >= 0 AND n <= 95
    t = n + 160         \ Insert recursive token [n]
  ELIF n >= 128         \
    t = n - 114         \ Tokens 0-95 get stored as n + 160
  ELSE                  \ Tokens 128-145 get stored as n - 114
    t = n               \ Tokens 96-127 get stored as n
  ENDIF
  EQUB t EOR 35
ENDMACRO

MACRO ITEM price, factor, units, quantity, mask
  IF factor < 0
    s = 1 << 7          \ Insert an item into the market prices table at QQ23
  ELSE                  \
    s = 0               \ Arguments:
  ENDIF                 \
  IF units == 't'       \   * price = Base price
    u = 0               \   * factor = Economic factor
  ELIF units == 'k'     \   * units = "t", "g" or "k"
    u = 1 << 5          \   * quantity = Base quantity
  ELSE                  \   * mask = Fluctutaions mask
    u = 1 << 6          \
  ENDIF                 \ See location QQ23 for details of how the above data
  e = ABS(factor)       \ is stored in the table
  EQUB price
  EQUB s + u + e
  EQUB quantity
  EQUB mask
ENDMACRO

\ ******************************************************************************
\
\ Deep dive: Multi-byte number terminology
\ ----------------------------------------
\ Not surprisingly, Elite deals with some pretty big numbers. For example, the
\ cash reserves are stored as big-endian 32-bit numbers, space coordinates are
\ stored as 24-bit sign-magnitude little-endian numbers, and the joystick gives
\ us two's complement signed 16-bit numbers. When you only have the 8-bit bytes
\ of 6502 assembly language to play with, things can get confusing, and quickly.
\
\ First, let's recap some basic definitions, so we're all on the same page.
\
\   * Big-endian numbers store their most significant bytes first, then the
\     least significant bytes. This is how humans tend to write numbers.
\
\   * Little-endian numbers store the least significance bytes first then the
\     most significant ones. The 6502 stores its addresses in little-endian
\     format, as do the EQUD and EQUW directives, for example.
\
\   * Sign-magnitude numbers store their sign in their highest bit, and the
\     rest of the number contains the magnitude of the number (i.e. the number
\     without the sign). You can change the sign of a sign magnitude number by
\     simply flipping the highest bit (bit 7 in an 8-bit sign-magnitude number,
\     bit 15 in a 16-bit sign-magnitude number, and so on).
\
\   * Two's complement numbers, meanwhile, are the mainstay of 6502 assembly
\     language, and instructions like ADC and SBC are designed to work with both
\     negative and positive two's complement numbers without us having to worry
\     about a thing. They also have a sign bit in the highest bit, but negative
\     numbers have their bits flipped compared to positive numbers. To flip the
\     sign of a number in two's complement, you flip all the bits and add 1.
\
\ Elite uses a smorgasbord of all these types, and it can get pretty confusing.
\ Given this, let's invent some terminology to make it easier to talk about
\ multi-byte numbers and how they are stored in memory.
\
\ If we have three bytes called x_sign, x_hi and x_lo, then we can refer to
\ their 32-bit number like this:
\
\   (x_sign x_hi x_lo)
\
\ In this terminology, the most significant byte is always written first,
\ irrespective of how the bytes ar stored in memory. Similarly, we can talk
\ about 16-bit numbers made up of registers:
\
\   (X Y)
\
\ or numbers made up of a mix of registers and memory locations:
\
\  (A S S+1)
\
\ In the latter case, the most significant byte is in the accumulator A, then
\ the next most significant is in memory location S, and the least significant
\ byte is in S+1.
\
\ When talking about numbers in sequential memory locations, we can use another
\ shorthand. Consider this little-endian number:
\
\   (K+3 K+2 K+1 K)
\
\ where a 32-bit little-endian number is stored in memory locations K (low byte)\ through to K+3 (high byte). We can also refer to this number like this:
\
\   K(3 2 1 0)
\
\ Or a big-endian number stored in XX15 through XX15+3 would be:
\
\   XX15(0 1 2 3)
\
\ where XX15 is the most significant byte and XX15+3 the least significant.
\
\ To take this even further, if we want to add
\ another significant byte to make this a five-byte number - an overflow byte
\ in a memory location called S, say - then we might talk about:
\
\   K(S 3 2 1 0)
\
\ or even something like this:
\
\   XX15(4 0 1 2 3)
\
\ which is a five-byte number stored with the highest byte in XX15+4, then the
\ next most significant in XX15, then XX15+1 and XX15+2, through to the lowest
\ byte in XX15+3. And yes, Elite does store one of its numbers like this - see
\ the BPRNT routine for the gory details.
\
\ With this terminology, it might help to think of the digits listed in the
\ brackets as being written down in the same order that we would write them
\ down as humans. The point of this terminology is to make it easier for people
\ to read, after all.
\
\ ******************************************************************************

\ ******************************************************************************
\
\ Deep dive: The Elite memory map
\ -------------------------------
\ The tape version of Elite uses almost every nook and cranny of the BBC Micro,
\ which isn't surprising when you consider just how much the authors managed to
\ squeeze into this 32K micro, without the disc version's luxury of being able
\ to switch out the codebase when docking and launching.
\
\ When Elite is loaded, this is how the memory map of the BBC Micro looks.
\
\     +-----------------------------------+   &FFFF
\     |                                   |
\     | Machine Operating System (MOS)    |
\     |                                   |
\     +-----------------------------------+   &C000
\     |                                   |
\     | Paged ROMs                        |
\     |                                   |
\     +-----------------------------------+   &8000
\     |                                   |
\     | Screen memory                     |
\     |                                   |
\     +-----------------------------------+   &6000
\     |                                   |
\     | Ship definitions (SHIPS.bin)      |
\     |                                   |
\     +-----------------------------------+   &563A = XX21
\     |                                   |
\     | Main game code (ELTcode.bin)      |
\     |                                   |
\     +-----------------------------------+   &0F40
\     |                                   |
\     | &0F34-&0F40 not used              |
\     |                                   |
\     +-----------------------------------+   &0F34
\     |                                   |
\     | Workspace at WP                   |
\     |                                   |
\     +-----------------------------------+   &0D40 = WP
\     |                                   |
\     | Ship lines heap descends from WP  |
\     |                                   |
\     +-----------------------------------+   SLSP
\     |                                   |
\     .                                   .
\     .                                   .
\     .                                   .
\     .                                   .
\     .                                   .
\     |                                   |
\     +-----------------------------------+   INF
\     |                                   |
\     | Ship data blocks                  |
\     |                                   |
\     +-----------------------------------+   &0900 = K%
\     |                                   |
\     | Page 8, MOS sound/printer buffers |
\     |                                   |
\     +-----------------------------------+   &0800
\     |                                   |
\     | Recursive tokens (WORDS9.bin)     |
\     |                                   |
\     +-----------------------------------+   &0400 = QQ18
\     |                                   |
\     | &035F - &03FF used for stardust?  |
\     |                                   |
\     +-----------------------------------+   &035F = SXL
\     |                                   |
\     | Workspace at T%                   |
\     |                                   |
\     +-----------------------------------+   &0300 = T%
\     |                                   |
\     | Page 2, MOS workspace             |
\     |                                   |
\     +-----------------------------------+   &0200
\     |                                   |
\     | 6502 stack descends from &01FF    |
\     |                                   |
\     +-----------------------------------+
\     |                                   |
\     | Heap space at XX3                 |
\     |                                   |
\     +-----------------------------------+   &0100 = XX3
\     |                                   |
\     | Zero page workspace at ZP         |
\     |                                   |
\     +-----------------------------------+   &0000 = ZP
\
\ More details on all of the memory blocks can be found in the source code
\ below. Of the 64K of addressable memory that the BBC's 6502 supports, this
\ is the breakdown of memory usage once Elite is loaded and running, shown in
\ bytes:
\
\   Operating system ROM                                 16384
\   Paged ROMs                                           16384
\   6502 stack                                             256
\   Operating system workspace in page 2                   256
\   Sound and printer buffers                              256
\
\   Elite's split screen memory                           8192
\
\   Game code                                            18170
\   Ship blueprints (11 different designs)                2502
\   K% workspace (ship data blocks and heap space)        1088
\   Game text (recursive tokens)                          1024
\   WP workspace (ship slots, variables)                   512
\   Zero page workspace (INWK workspace, variables)        256
\   T% workspace (current commander data, stardust data)   256
\
\   Total                                                65536
\
\ Contrary to popular legend, Elite does not use every single last byte of
\ usable memory. There are 12 unused bytes at the end of the WP workspace,
\ and 6 unused bytes in T% amongst all the equipment bytes, as well as an
\ unused duplicate of one of the multiplication routines that takes up 24 bytes
\ that could have been reclaimed... and that's not including quite a few
\ instructions that have no effect and could have been culled without impact.
\ But this is splitting hairs, as Elite swells the BBC Micro to near bursting
\ point while being incredibly clever and efficient, and for that, serious
\ respect is due to the authors.
\
\ ******************************************************************************

\ ******************************************************************************
\
\ Deep dive: Galaxy and system seeds
\ ----------------------------------
\ Famously, Elite's galaxy and system data is generated procedurally, using a
\ set of three 16-bit seed numbers and the Tribonnaci series. You can read all
\ about this process in the individual documentation for the routines mentioned
\ in the table below, as well as the system twisting routine at TT54 and galaxy
\ twisting process in Ghy.
\
\ The three seeds are stored as little-endian 16-bit numbers, so the low (least
\ significant) byte is first followed by the high (most significant) byte. That
\ means if the seeds are w0, w1 and w2, they are stored like this:
\
\       low byte  high byte
\   w0  QQ15      QQ15+1
\   w1  QQ15+2    QQ15+3
\   w2  QQ15+4    QQ15+5
\
\ In this documentation, we denote the low byte of w0 as w0_lo and the high byte
\ as w0_hi, and so on for w1_lo, w1_hi, w2_lo and w2_hi.
\
\ The seeds for the selected system are stored at QQ15, while the seeds for the
\ current galaxy are in QQ21.
\
\ Here's a summary of which bits in which seeds are used to generate the various
\ bits of data in the universe. The routine names where these data are generated
\ are shown at the end (TT25 etc.).
\
\    w0_hi    w0_lo    w1_hi    w1_lo    w2_hi    w2_lo
\ 76543210 76543210 76543210 76543210 76543210 76543210
\
\                                        ^^^----------- Species adjective 1 TT25
\                                     ^^^-------------- Species adjective 2 TT25
\       ^^----------------^^--------------------------- Species adjective 3 TT25
\                                           ^^--------- Species type        TT25
\                   ^^^^^^^^--------------^^^^--------- Average radius      TT25
\                              ^^^--------------------- Government type     TT24
\       ^^--------------------------------------------- Prosperity level    TT24
\       ^---------------------------------------------- Economy type        TT24
\                         ^^--------------------------- Tech level          TT24
\                   ^^^^^^^^--------------------------- Galactic x-coord    TT24
\ ^^^^^^^^--------------------------------------------- Galactic y-coord    TT24
\                                               ^-^---- Long-range dot size TT22
\                                                     ^ Short-range size    TT23
\           ^------------------------------------------ Name length          cpl
\                                        ^^^^^--------- Name token (x4)      cpl
\      ^^^--------------------------------------------- Planet distance    SOLAR
\                        ^^^--------------------------- Sun distance       SOLAR
\                                           ^^--------- Sun x-y offset     SOLAR
\
\ 76543210 76543210 76543210 76543210 76543210 76543210
\    w0_hi    w0_lo    w1_hi    w1_lo    w2_hi    w2_lo
\
\ ******************************************************************************

\ ******************************************************************************
\
\ Zero page workspace ZP at &0000 - &00B0
\
\ ******************************************************************************

ORG &0000

.ZP                     \ Zero page workspace

.RAND

 SKIP 4                 \ Random number seeds, four 8-bit numbers

.TRTB%

 SKIP 2                 \ Set by elite-loader.asm to point to the MOS key
                        \ translation table, used to translate internal key
                        \ values to ASCII

.T1

 SKIP 1                 \ Temporary storage, used quite a lot

.SC

 SKIP 1                 \ Screen address (low byte)

.SCH

 SKIP 1                 \ Screen address (high byte)

.XX16

 SKIP 18                \

.P

 SKIP 3                 \ Temporary storage for a memory pointer (e.g. used in
                        \ TT26 to store the address of character definitions)

.XX0

 SKIP 2                 \ Stores the address of the ship blueprint in NWSHP,
                        \ and the blueprint of the current ship being analysed
                        \ in the main flight loop

.INF

 SKIP 2                 \ Stores address of new ship data block when adding a
                        \ new ship

.V

 SKIP 2                 \

.XX

 SKIP 2                 \

.YY

 SKIP 2                 \

.SUNX

 SKIP 2                 \

.BETA

 SKIP 1                 \ Pitch rate, reduced from JSTY to a value between -8
                        \ and +8, with same sign as BET2 (the correct sign)

.BET1

 SKIP 1                 \ Pitch rate magnitude, reduced from JSTY to a positive
                        \ value between 0 and 8, i.e. |pitch rate|

.XC

 SKIP 1                 \ Contains the x-coordinate of the text cursor (i.e.
                        \ the text column), from 0 to 32
                        \
                        \ A value of 0 denotes the leftmost column and 32 the
                        \ rightmost column, but because the top part of the
                        \ screen (the mode 4 part) has a white border that
                        \ clashes with columns 0 amd 32, text is only shown
                        \ at columns 1-31


.YC

 SKIP 1                 \ Contains the y-coordinate of the text cursor (i.e.
                        \ the text row), from 0 to 23
                        \
                        \ A value of 0 denotes the top row, but because the
                        \ top part of the screen has a white border that clashes
                        \ with row 0, text is always shown at row 1 or greater

.QQ22

 SKIP 2                 \ Hyperspace countdown counters
                        \
                        \ Before a hyperspace jump, both QQ22 and QQ22+1 are
                        \ set to 15
                        \
                        \ QQ22 is an internal counter that counts down by 1
                        \ each time TT102 is called, which happens every
                        \ iteration of the main game loop. When it reaches
                        \ zero, the on-screen counter in QQ22+1 gets
                        \ decremented, and QQ22 gets set to 5 and the countdown
                        \ continues (so the first tick of the hyperspace counter
                        \ takes 15 iterations to happen, but subsequent ticks
                        \ take 5 iterations each)
                        \
                        \ QQ22+1 contains the number that's shown on-screen
                        \ during countdown. It counts down from 15 to 1, and
                        \ when it hits 0, the hyperspace engines kick in

.ECMA

 SKIP 1                 \ E.C.M. countdown timer (can be either our E.C.M.
                        \ or an opponent's)
                        \
                        \ 0 is off, non-zero is on and counting down

.XX15                   \ 6-byte storage from XX15 TO XX15+5

.X1

 SKIP 1                 \ Temporary storage for coordinates in line-drawing
                        \ routines

.Y1

 SKIP 1                 \ Temporary storage for coordinates in line-drawing
                        \ routines

.X2

 SKIP 1                 \ Temporary storage for coordinates in line-drawing
                        \ routines

.Y2

 SKIP 1                 \ Temporary storage for coordinates in line-drawing
                        \ routines

 SKIP 2                 \ Last 2 bytes of XX15

.XX12

 SKIP 6                 \

.K

 SKIP 4                 \ Temporary storage, used all over the place

.KL

 SKIP 1                 \ If a key is being pressed that is not in the keyboard
                        \ table at KYTB, it can be stored here (as seen in
                        \ routine DK4, for example)

                        \ The following bytes implement a key logger that
                        \ enables Elite to scan for concurrent key presses of
                        \ all the flight keys (so this effectively implements
                        \ a 15-key rollover for the flight keys listed in the
                        \ keyboard table at KYTB, enabling players to roll,
                        \ pitch, change speed and fire lasers at the same, all
                        \ while targeting missiles and setting off their E.C.M.
                        \ and energy bomb, without the keyboard ignoring them).
                        \ The various keyboard canning routines, such as the one
                        \ at DKS1, can set the relevant byte in this table to
                        \ &FF to denote that that particular key is being
                        \ pressed. The logger is cleared to zero (no keys are
                        \ being pressed) by the U% routine

.KY1

 SKIP 1                 \ ? key pressed (0 = no, non-zero = yes)

.KY2

 SKIP 1                 \ Space key pressed (0 = no, non-zero = yes)

.KY3

 SKIP 1                 \ < key pressed (0 = no, non-zero = yes)

.KY4

 SKIP 1                 \ > key pressed (0 = no, non-zero = yes)

.KY5

 SKIP 1                 \ X key pressed (0 = no, non-zero = yes)

.KY6

 SKIP 1                 \ S key pressed (0 = no, non-zero = yes)

.KY7

 SKIP 1                 \ A key pressed (0 = no, non-zero = yes)
                        \
                        \ Also, joystick fire button pressed

.KY12

 SKIP 1                 \ Tab key pressed (0 = no, non-zero = yes)

.KY13

 SKIP 1                 \ Escape key pressed (0 = no, non-zero = yes)

.KY14

 SKIP 1                 \ T key pressed (0 = no, non-zero = yes)

.KY15

 SKIP 1                 \ U key pressed (0 = no, non-zero = yes)

.KY16

 SKIP 1                 \ M key pressed (0 = no, non-zero = yes)

.KY17

 SKIP 1                 \ E key pressed (0 = no, non-zero = yes)

.KY18

 SKIP 1                 \ J key pressed (0 = no, non-zero = yes)

.KY19

 SKIP 1                 \ C key pressed (0 = no, non-zero = yes)

.LAS

 SKIP 1                 \ Bits 0-6 of the laser power of the current space view
                        \ (bit 7 doesn't denote laser power, just whether or
                        \ not the laser pulses)

.MSTG

 SKIP 1                 \ Missile lock target
                        \
                        \ &FF = no target, otherwise contains the slot number of
                        \ the ship that our missile is locked onto

.XX1

.INWK

 SKIP 33                \ Workspace for the current ship data block. See the
                        \ documentation for workspace K% for details of what
                        \ each of the bytes in the data block represents

.XX19

 SKIP NI% - 33          \ XX19 shares location with INWK+33

.LSP

 SKIP 1                 \

.QQ15

 SKIP 6                 \ Contains the three 16-bit seeds (6 bytes) for the
                        \ selected system, i.e. the one in the crosshairs in
                        \ the short range chart

.K5

.XX18

.QQ17

 SKIP 1                 \ QQ17 stores flags that affect how text tokens are
                        \ printed, including the capitalisation setting
                        \
                        \ Setting QQ17 = 255 disables text printing entirely
                        \
                        \ Otherwise:
                        \
                        \ Bit 7 = 0 means ALL CAPS
                        \ Bit 7 = 1 means Sentence Case, bit 6 determines case
                        \           of next letter to print
                        \
                        \ Bit 6 = 0 means print the next letter in upper case
                        \ Bit 6 = 1 means print the next letter in lower case
                        \
                        \ So:
                        \
                        \ QQ17 = 0   (%0000 0000) means case is set to ALL CAPS
                        \ QQ17 = 128 (%1000 0000) means Sentence Case,
                        \                         currently printing upper case
                        \ QQ17 = 192 (%1100 0000) means Sentence Case,
                        \                         currently printing lower case
                        \
                        \ If any of bits 0-5 are set and QQ17 is not &FF, we
                        \ print in lower case

.QQ19

 SKIP 3                 \ Temporary storage (e.g. used in TT25 to store results
                        \ when calculating adjectives to show for system species
                        \ names, and in TT151 when printing market prices, and
                        \ in TT111 when working out which system is nearest to
                        \ the crosshairs in the system charts)

.K6

 SKIP 5                 \ Temporary storage for seed pairs (e.g. used in cpl
                        \ as a temporary backup when twisting three 16-bit
                        \ seeds, and in TT151 when printing market prices)

.ALP1

 SKIP 1                 \ Roll rate magnitude, reduced from JSTX to a positive
                        \ value between 0 and 31, i.e. |roll rate|

.ALP2

 SKIP 2                 \ ALP2   = correct sign of the alpha angle (roll rate)
                        \ ALP2+1 = flipped sign of the alpha angle (roll rate)

.BET2

 SKIP 2                 \ BET2   = correct sign of the beta angle (pitch rate)
                        \ BET2+1 = flipped sign of the beta angle (pitch rate)

.DELTA

 SKIP 1                 \ Current speed, 1-40

.DELT4

 SKIP 2                 \ The current speed * 64
                        \
                        \ The high byte therefore contains the current speed
                        \ divided by 4

.U

 SKIP 1                 \ Temporary storage (e.g. used in BPRNT to store the
                        \ last position at which we must start printing digits)

.Q

 SKIP 1                 \ Temporary storage, used all over the place

.R

 SKIP 1                 \ Temporary storage, used all over the place

.S

 SKIP 1                 \ Temporary storage, used all over the place

.XSAV

 SKIP 1                 \ Temporary storage for X, used all over the place

.YSAV

 SKIP 1                 \ Temporary storage for Y, used all over the place

.XX17

 SKIP 1                 \ Temporary storage (e.g. used in BPRNT to store the
                        \ number of characters to print)

.QQ11

 SKIP 1                 \ Current view
                        \
                        \ 0   = Space view
                        \ 1   = Title screen
                        \       Buy Cargo screen (red key f1)
                        \       Data on System screen (red key f6)
                        \       Get commander name ("@", save/load commander)
                        \       In-system jump just arrived ("J")
                        \       Mis-jump just arrived (witchspace)
                        \ 4   = Sell Cargo screen (red key f2)
                        \ 6   = Death screen
                        \ 8   = Status Mode screen (red key f8)
                        \       Inventory screen (red key f9)
                        \ 16  = Market Price screen (red key f7)
                        \ 32  = Equip Ship screen (red key f3)
                        \ 64  = Long-range Chart (red key f4)
                        \ 128 = Short-range Chart (red key f5)

.ZZ

 SKIP 1                 \

.XX13

 SKIP 1                 \ Number of pirates currently spawned

.MCNT

 SKIP 1                 \ Main loop counter
                        \
                        \ Gets set to 0 when we buy fuel
                        \
                        \ Gets set to &FF on death and in-system jump
                        \
                        \ Gets decremented every time the main loop at TT100 is
                        \ entered
                        \
                        \ Used to determine when to do certain actions within
                        \ the main loop, so ship energy and shields are bumped
                        \ up every 8 loops, we check whether we are near a
                        \ space station every 32 loops, we check the ship's
                        \ altitude every 10 loops, and so on

.DL

 SKIP 1                 \ Line scan counter
                        \
                        \ Gets set to 30 every vertical sync on the video
                        \ system, which happens 50 times a second (50Hz)

.TYPE

 SKIP 1                 \ Temporary storage, used to store the current ship type
                        \ in places like the main flight loop (see FRIN for
                        \ information about ship types)

.JSTX

 SKIP 1                 \ Current rate of roll (as shown in the dashboard's RL
                        \ indicator), ranging from 1 to 255 with 128 as the
                        \ centre point (so 1 means roll is decreasing at the
                        \ maximum rate, 128 means roll is not changing, and
                        \ 255 means roll is increasing at the maximum rate)

.JSTY

 SKIP 1                 \ Current rate of pitch (as shown in the dashboard's DC
                        \ indicator), ranging from 1 to 255 with 128 as the
                        \ centre point (so 1 means pitch is decreasing at the
                        \ maximum rate, 128 means pitch is not changing, and
                        \ 255 means pitch is increasing at the maximum rate)

.ALPHA

 SKIP 1                 \ Roll rate, reduced from JSTX to a value between -31
                        \ and +31, with same sign as ALP2 (the correct sign)

.QQ12

 SKIP 1                 \ Docked status
                        \
                        \ 0 = not docked, &FF = docked

.TGT

 SKIP 1                 \

.SWAP

 SKIP 1                 \

.COL

 SKIP 1                 \

.FLAG

 SKIP 1                 \

.CNT

 SKIP 1                 \

.CNT2

 SKIP 1                 \

.STP

 SKIP 1                 \

.XX4

 SKIP 1                 \ Used as temporary storage (e.g. used in STATUS as a
                        \ loop counter)

.XX20

 SKIP 1                 \

.XX14

 SKIP 1                 \

.RAT

 SKIP 1                 \

.RAT2

 SKIP 1                 \

.K2

 SKIP 4

ORG &D1

.T

 SKIP 1                 \ Used as temporary storage (e.g. used in cpl for the
                        \ loop counter)

.K3                     \ Used as temporary storage (e.g. used in TT27 for the
                        \ character to print)

.XX2

 SKIP 14

.K4                     \ Used as temporary storage (e.g. used in TT27 for the
                        \ character to print)

PRINT "Zero page variables from ", ~ZP, " to ", ~P%

\ ******************************************************************************
\
\ Workspace XX3 at &0100
\
\ Used as heap space for storing temporary data during calculations shared with
\ the descending 6502 stack, which works down from &01FF.
\
\ ******************************************************************************

ORG &0100

.XX3                    \ Temporary heap space

\ ******************************************************************************
\
\ Workspace T% at &0300 - &035F
\
\ Contains the current commander data (NT% bytes at location TP), and the
\ stardust data block (NOST bytes at location SX)
\
\ ******************************************************************************

ORG &0300               \ Start of the commander block

.T%                     \ Start of workspace T%

.TP

 SKIP 1                 \ Mission status, always 0 for the tape version of Elite

.QQ0

 SKIP 1                 \ Current system's galactic x-coordinate

.QQ1

 SKIP 1                 \ Current system's galactic y-coordinate

.QQ21

 SKIP 6                 \ The three 16-bit seeds for the current galaxy
                        \
                        \ These seeds define system 0 in the current galaxy, so
                        \ they can be used as a starting point to generate all
                        \ 256 systems in this galaxy
                        \
                        \ Using a galactic hyperdrive rotates each byte to the
                        \ left (rolling each byte within itself) to get the
                        \ seeds for the next galaxy, so after 8 galactic jumps,
                        \ the seeds roll round to the first galaxy again

.CASH

 SKIP 4                 \ Cash as a 32-bit unsigned integer, stored with the
                        \ most significant byte in CASH and the least
                        \ significant in CASH+3 (big-endian, which is not the
                        \ same way that 6502 assembler stores addresses) -
                        \ or, to use our notation, it's CASH(0 1 2 3)

.QQ14

 SKIP 1                 \ Contains the current fuel level * 10 (so a 1 in QQ14
                        \ represents 0.1 light years)
                        \
                        \ Maximum value is 70 (7.0 light years)

.COK

 SKIP 1                 \ Competition code flags
                        \
                        \ Bit 7 is set on start-up if CHK and CHK2 do not match,
                        \ which presumably indicates that there may have been
                        \ some cheatimg going on
                        \
                        \ Bit 1 is set on start-up
                        \
                        \ Bit 0 is set in routine ptg if we hold X during
                        \ hyperspace to force a mis-jump (having first paused
                        \ the game and toggled on the author credits with X)

.GCNT

 SKIP 1                 \ Contains the current galaxy number, 0-7
                        \
                        \ When this is displayed in-game, 1 is added to the
                        \ number (so we start in galaxy 1 in-game, but it's
                        \ stored as galaxy 0 internally)

.LASER

 SKIP 4                 \ Laser power
                        \
                        \ (byte 0 = front, 1 = rear, 2 = left, 3 = right)
                        \
                        \   0 means no laser
                        \
                        \   non-zero denotes the following:
                        \
                        \ Bits 0-6 contain the laser's power
                        \
                        \ Bit 7 determines whether or not the laser pulses
                        \ (pulse laser) or is always on (beam laser)

 SKIP 2                 \ Not used (originally reserved for up/down lasers,
                        \ perhaps?)

.CRGO

 SKIP 1                 \ Cargo capacity
                        \
                        \   22 = standard cargo bay of 20 tonnes
                        \
                        \   37 = large cargo bay of 35 tonnes

.QQ20

 SKIP 17                \ Contents of cargo hold
                        \
                        \ The amount of market item X in the hold is in QQ20+X,
                        \ so QQ20 contains the amount of food (item 0) while
                        \ QQ20+7 contains the amount of computers (item 7). See
                        \ QQ23 for a list of market item numbers

.ECM

 SKIP 1                 \ E.C.M. system
                        \
                        \   0 = not fitted
                        \   &FF = fitted

.BST

 SKIP 1                 \ Fuel scoops ("barrel status")
                        \
                        \   0 = not fitted
                        \   &FF = fitted

.BOMB

 SKIP 1                 \ Energy bomb
                        \
                        \   0 = not fitted
                        \   &7F = fitted

.ENGY

 SKIP 1                 \ Energy unit
                        \
                        \   0 = not fitted
                        \   1 = fitted

.DKCMP

 SKIP 1                 \ Docking computer
                        \
                        \   0 = not fitted
                        \   &FF = fitted

.GHYP

 SKIP 1                 \ Galactic hyperdrive
                        \
                        \   0 = not fitted
                        \   &FF = fitted

.ESCP

 SKIP 1                 \ Escape pod
                        \
                        \   0 = not fitted
                        \   &FF = fitted

 SKIP 4                 \ Not used

.NOMSL

 SKIP 1                 \ Number of missiles

.FIST

 SKIP 1                 \ Legal status ("fugitive/innocent status")
                        \
                        \   0    = Clean
                        \   1-49 = Offender
                        \   50+  = Fugitive
                        \
                        \ You get 64 points if you kill a cop, so that's
                        \ straight to fugitive

.AVL

 SKIP 17                \ Market availability
                        \
                        \ The available amount of market item X is in AVL+X, so
                        \ AVL contains the amount of food (item 0) while AVL+7
                        \ contains the amount of computers (item 7). See QQ23
                        \ for a list of market item numbers, and GVL for the
                        \ algorithm for calculating item availability

.QQ26

 SKIP 1                 \ A random value that changes for each visit to a
                        \ system, for randomising market prices (see TT151 for
                        \ details of the market price calculation)

.TALLY

 SKIP 2                 \ Number of kills as a 16-bit number, stored as
                        \ TALLY(1 0) - so the high byte is in TALLY+1 and the
                        \ low in TALLY
                        \
                        \ If the high byte in TALLY+1 = 0 then we are Harmless,
                        \ Mostly Harmless, Poor, Average or Above Average,
                        \ according to the value of the low byte in TALLY:
                        \
                        \ Harmless        = 0000 0000 to 0000 0011 = 0 to 3
                        \ Mostly Harmless = 0000 0100 to 0000 0111 = 4 to 7
                        \ Poor            = 0000 1000 to 0000 1111 = 8 to 15
                        \ Average         = 0001 0000 to 0001 1111 = 16 to 31
                        \ Above Average   = 0010 0000 to 1111 1111 = 32 to 255
                        \
                        \ If the high byte in TALLY+1 is non-zero then we are
                        \ Competent, Dangerous, Deadly or Elite, according to
                        \ the high byte in TALLY+1:
                        \
                        \ Competent       = 1           = 256 to 511 kills
                        \ Dangerous       = 2 to 9      = 512 to 2559 kills
                        \ Deadly          = 10 to 24    = 2560 to 6399 kills
                        \ Elite           = 25 and up   = 6400 kills and up
                        \
                        \ You can see the rating calculation in STATUS

.SVC

 SKIP 1                 \ Save count, gets halved with each save

 SKIP 2                 \ Reserve two bytes for commander checksum, so when
                        \ current commander block is copied to the last saved
                        \ commnder block at NA%, CHK and CHK2 get overwritten

NT% = SVC + 2 - TP      \ Set to the size of the commander block, which starts
                        \ at T% (&300) and goes to SVC+3

SX = P%                 \ SX points to the stardust data block, which is NOST
                        \ bytes (NOST = "number of stars")

SXL = SX + NOST + 1     \ SXL points to the end of the stardust data block

PRINT "T% workspace from  ", ~T%, " to ", ~SXL

\ ******************************************************************************
\
\ ELITE WORDS9 at &0400 - &07FF
\
\ Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
\
\ The recursive token table is loaded at &1100 and is moved down to &0400 as
\ part of elite-loader.asm.
\
\ ******************************************************************************

CODE_WORDS% = &0400
LOAD_WORDS% = &1100

ORG CODE_WORDS%

\ ******************************************************************************
\
\ Variable: QQ18
\
\ Recursive token table for tokens 0-148.
\
\ ******************************************************************************
\
\ Deep dive: Game text in Elite
\ -----------------------------
\ This table contains data for the recursive token system used in Elite. There
\ are actually three types of token used by Elite - recursive, two-letter and
\ control codes - so let's look at all of them in one go.
\
\ Tokenisation
\ ------------
\ Elite uses a tokenisation system to store the text it displays during the
\ game. This enables the game to store strings more efficiently than would be
\ the case if they were simply inserted into the source code using EQUS, and it
\ also makes it possible to create things like system names using procedural
\ generation.
\
\ To support tokenisation, characters are printed to the screen using a special
\ subroutine (TT27), which not only supports the usual range of letters,
\ numbers and punctuation, but also three different types of token. When
\ printed, these tokens get expanded into longer strings, which enables the
\ game to squeeze a lot of text into a small amount of storage.
\
\ To print something, you pass a byte through to the printing routine at TT27.
\ The value of that byte determines what gets printed, as follows:
\
\   Value (n)     Type
\   ---------     -------------------------------------------------------
\   0-13          Control codes 0-13
\   14-31         Recursive tokens 128-145 (i.e. token number = n + 114)
\   32-95         Normal ASCII characters 32-95 (0-9, A-Z and most punctuation)
\   96-127        Recursive tokens 96-127 (i.e. token number = n)
\   128-159       Two-letter tokens 128-159
\   160-255       Recursive tokens 0-95 (i.e. token number = n - 160)
\
\ Characters with codes 32-95 represent the normal ASCII characters from " " to
\ "_", so a value of 65 in an Elite string represents the letter A (as "A" has
\ character code 65 in the BBC Micro's character set).
\
\ All other character codes (0-31 and 96-255) represent tokens, and they can
\ print anything from single characters to entire sentences. In the case of
\ recursive tokens, the tokens can themselves contain other tokens, and in this
\ way long strings can be stored in very few bytes, at the expense of code
\ readability and speed.
\
\ To make things easier to follow in the discussion and comments below, let's
\ refer to the three token types like this, where n is the character code:
\
\   {n}           Control codes             n = 0 to 13
\   <n>           Two-letter token          n = 128 to 159
\   [n]           Recursive token           n = 0 to 148
\
\ So when we say {13} we're talking about control code 13 ("crlf"), while <141>
\ is the two-letter token 141 ("DI"), and [3] is the recursive token 3 ("DATA
\ ON {current system}"). The brackets are just there to make things easier to
\ understand when following the code, because the way these tokens are stored
\ in memory and passed to subroutines is confusing, to say the least.
\
\ We'll take a look at each of the three token types in more detail below, but
\ first a word about how characters get printed in Elite.
\
\ The TT27 print subroutine
\ -------------------------
\ Elite contains a subroutine at TT27 that prints out the character given in
\ the accumulator, and if that number refers to a token, then the token is
\ expanded before being printed. Whole strings can be printed by calling this
\ subroutine on one character at a time, and this is how almost all of the text
\ in the game gets put on screen. For example, the following code:
\
\   LDA #65
\   JSR TT27
\
\ prints a capital A, while this code:
\
\   LDA #163
\   JSR TT27
\
\ prints recursive token number 3 (see below for more on why we pass #163
\ instead of #3). This would produce the following if we were currently
\ visiting Tionisla:
\
\   DATA ON TIONISLA
\
\ This is because token 3 expands to the string "DATA ON {current system}". You
\ can see this very call being used in TT25, which displays data on the
\ selected system when F6 is pressed (this particular call is what prints the
\ title at the top of the screen).
\
\ The ex print subroutine
\ -----------------------
\ You may have noticed that in the table above, there are character codes for
\ all our ASCII characters and tokens, except for recursive tokens 146, 147 and
\ 148. How do we print these?
\
\ To print these tokens, there is another subroutine at ex that always prints
\ the recursive token number in the accumulator, so we can use that to print
\ these tokens.
\
\ (Incidentally, the ex subroutine is what TT27 calls when it has analysed the
\ character code, determined that it is a recursive token, and subtracted 160
\ or added 114 as appropriate to get the token number, so calling it directly
\ with 146-148 in the accumulator is acceptable.)
\
\ Control codes: {n}
\ ------------------
\ Control codes are in the range 0 to 13, and expand to the following when
\ printed via TT27:
\
\   0   Current cash, right-aligned to width 9, then " CR", newline
\   1   Current galaxy number, right-aligned to width 3
\   2   Current system name
\   3   Selected system name (the crosshairs in the short range chart)
\   4   Commander's name
\   5   "FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:", {0}, newline
\   6   Switch case to Sentence Case
\   7   Beep
\   8   Switch case to ALL CAPS
\   9   Tab to column 21, then print a colon
\   10  Line feed (i.e. move cursor down)
\   11  (not used, does the same as 13)
\   12  (not used, does the same as 13)
\   13  Newline (i.e. carriage return and line feed)
\
\ So a value of 4 in a tokenised string will be expanded to the current
\ commander's name, while a value of 5 will print the current fuel level in the
\ format "FUEL: 5.3 LIGHT YEARS", followed by a newline, followed by "CASH: ",
\ and then followed by control code 0, which shows the amount of cash to one
\ significant figure, right-aligned to a width of 9 characters, and finished
\ off with " CR" and another newline. The result is something like this, when
\ displayed in Sentence Case:
\
\   Fuel: 6.7 Light Years
\   Cash:    1234.5 Cr
\
\ If you press f8 to show the Status Mode screen, you can see control code 4
\ being used to show the commander's name in the title, while control code 5 is
\ responsible for displaying the fuel and cash lines.
\
\ When talking about encoded strings in the code comments below, control
\ characters are shown as {n}, so {4} expands to the commander's name and {5}
\ to the current fuel.
\
\ By default, Elite prints words using Sentence Case, where the first letter of
\ each word is capitalised. Control code {8} can be used to switch to ALL CAPS
\ (so it acts like Caps Lock), and {6} can be used to switch back to Sentence
\ Case. You can see this in action on the Status Mode screen, where the title
\ and equipment headers are in ALL CAPS, while everything else is in Sentence
\ Case. Tokens are stored in capital letters only, and each letter's case is
\ set by the logic in TT27.
\
\ Two-letter tokens: <n>
\ ----------------------
\ Two-letter tokens expand to the following:
\
\   128     AL
\   129     LE
\   130     XE
\   131     GE
\   132     ZA
\   133     CE
\   134     BI
\   135     SO
\   136     US
\   137     ES
\   138     AR
\   139     MA
\   140     IN
\   141     DI
\   142     RE
\   143     A?
\   144     ER
\   145     AT
\   146     EN
\   147     BE
\   148     RA
\   149     LA
\   150     VE
\   151     TI
\   152     ED
\   153     OR
\   154     QU
\   155     AN
\   156     TE
\   157     IS
\   158     RI
\   159     ON
\
\ So a value of 150 in the tokenised string would expand to VE, for example.
\ When talking about encoded strings in the code comments below, two-letter
\ tokens are shown as <n>, so <150> expands to VE.
\
\ The set of two-letter tokens is stored at location QQ16, in a two-byte lookup
\ table. This table is also used to generate system names procedurally, as
\ described in routine cpl.
\
\ Note that question marks are not printed, so token <143> expands to A. This
\ allows names with an odd number of characters to be generated from sequences
\ of two-letter tokens, though only if they contain the letter A.
\
\ Recursive tokens: [n]
\ ---------------------
\ The binary file that is assembled by this source file (WORDS9.bin) contains
\ 149 recursive tokens, numbered from 0 to 148, which are stored from &0400 to
\ &06FF in a tokenised form. These tokenised strings can include references to
\ other tokens, hence "recursive".
\
\ When talking about encoded strings in the code comments below, recursive
\ tokens are shown as [n], so [111] expands to "FUEL SCOOPS", for example, and
\ [110] expands to "[102][104]S", which in turn expands to "EXTRA BEAM LASERS"
\ (as [102] expands to "EXTRA " and [104] to "BEAM LASER").
\
\ The recursive tokens are numbered from 0 to 148, but because we've already
\ reserved codes 0-13 for control characters, 32-95 for ASCII characters and
\ 128-159 for two-letter tokens, we can't just send the token number straight
\ to TT27 to print it out (sending 65 to TT27 prints "A", for example, and not
\ recursive token 65). So instead, we use the table above to work out what to
\ send to TT27; here are the relevant lines:
\
\   Value (n)     Type
\   ---------     -------------------------------------------------------
\   14-31         Recursive tokens 128-145 (i.e. token number = n + 114)
\   96-127        Recursive tokens 96-127 (i.e. token number = n)
\   160-255       Recursive tokens 0-95 (i.e. token number = n - 160)
\
\ The first column is the number we need to send to TT27 to print the token
\ mentioned in the second column.
\
\ So, if we want to print recursive token 132, then according to the first row
\ in this table, we need to subtract 114 to get 18, and send that to TT27.
\
\ Meanwhile, if we want to print token 101, then according to the second row,
\ we can just pass that straight through to TT27.
\
\ Finally, if we want to print token 3, then according to the third row, we
\ need to add 160 to get 163.
\
\ Note that, as described in the section above, you can't use TT27 to print
\ recursive tokens 146-148, but instead you need to call the ex subroutine, so
\ the method described here only applies to recursive tokens 0-145.
\
\ How recursive tokens are stored in memory
\ -----------------------------------------
\ The 149 recursive tokens are stored one after the other in memory, starting
\ at &0400, with each token being terminated by a null character (EQUB 0).
\
\ To complicate matters, the strings themselves are all EOR'd with 35 before
\ being stored, and this process is repeated when they are read from memory (as
\ EOR is reversible). This is done in the routine at TT50.
\
\ Note that if a recursive token contains another recursive token, then that
\ token's number is stored as the number that would be sent to TT27, rather
\ than the number of the token itself.
\
\ All of this makes it pretty challenging to work out how one would store a
\ specific token in memory, which is why this file uses a handful of macros to
\ make life easier. They are:
\
\   CHAR n          Insert ASCII character n        n = 32 to 95
\   CTRL n          Insert control code n           n = 0 to 13
\   TWOK n          Insert two-letter token n       n = 128 to 159
\   RTOK n          Insert recursive token n        n = 0 to 148
\
\ A side effect of all this obfuscation is that tokenised strings can't contain
\ ASCII 35 characters ("#"). This is because ASCII "#" EOR 35 is 0, and the
\ null character is already used to terminate our tokens in memory, so if you
\ did have a string containing the hash character, it wouldn't print the hash,
\ but would instead terminate at the character before.
\
\ Interestingly, there's no lookup table for each recursive token's starting
\ point im memory, as that would take up too much space, so to get hold of the
\ encoded string for a specific recursive token, the print routine runs through
\ the entire list of tokens, character by character, counting all the nulls
\ until it reaches the right spot. This might not be fast, but it is much more
\ space-efficient than a lookup table; you can see this loop in the subroutine
\ at ex, which is where recursive tokens are printed.
\
\ An example
\ ----------
\ Given all this, let's consider recursive token 3 again, which is printed
\ using the following code (remember, we have to add 160 to 3 to pass through
\ to TT27):
\
\   LDA #163
\   JSR TT27
\
\ Token 3 is stored in the tokenised form:
\
\   D<145>A[131]{3}
\
\ which we could store in memory using the following (adding in the null
\ terminator at the end):
\
\   CHAR 'D'
\   TWOK 145
\   CHAR 'A'
\   RTOK 131
\   CTRL 3
\   EQUB 0
\
\ As mentioned above, the values that are actually stored are EOR'd with 35,
\ and token [131] has to have 114 taken off it before it's ready for TT27, so
\ the bytes that are actually stored in memory for this token are:
\
\   EQUB 'D' EOR 35
\   EQUB 145 EOR 35
\   EQUB 'A' EOR 35
\   EQUB (131 - 114) EOR 35
\   EQUB 3 EOR 35
\   EQUB 0
\
\ or, as they would appear in the raw WORDS9.bin file, this:
\
\   EQUB &67, &B2, &62, &32, &20, &00
\
\ These all produce the same output, but the first version is rather easier to
\ understand.
\
\ Now that the token is stored in memory, we can call TT27 with the accumulator
\ set to 163, and the token will be printed as follows:
\
\   D             The letter D                      "D"
\   <145>         Two-letter token 145              "AT"
\   A             The letter A                      "A"
\   [131]         Recursive token 131               " ON "
\   {3}           Control character 3               The selected system name
\
\ So if the system under the crosshairs in the short range chart is Tionisla,
\ this expands into "DATA ON TIONISLA".
\
\ ******************************************************************************

.QQ18

 RTOK 111               \ Token 0:      "FUEL SCOOPS ON {beep}"
 RTOK 131               \ Encoded as:   "[111][131]{7}"
 CTRL 7
 EQUB 0

 CHAR ' '               \ Token 1:      " CHART"
 CHAR 'C'               \ Encoded as:   " CH<138>T"
 CHAR 'H'
 TWOK 138
 CHAR 'T'
 EQUB 0

 CHAR 'G'               \ Token 2:      "GOVERNMENT"
 CHAR 'O'               \ Encoded as:   "GO<150>RNM<146>T"
 TWOK 150
 CHAR 'R'
 CHAR 'N'
 CHAR 'M'
 TWOK 146
 CHAR 'T'
 EQUB 0

 CHAR 'D'               \ Token 3:      "DATA ON {selected system name}"
 TWOK 145               \ Encoded as:   "D<145>A[131]{3}"
 CHAR 'A'
 RTOK 131
 CTRL 3
 EQUB 0

 TWOK 140               \ Token 4:      "INVENTORY{crlf}"
 TWOK 150               \ Encoded as:   "<140><150>NT<153>Y{13}"
 CHAR 'N'
 CHAR 'T'
 TWOK 153
 CHAR 'Y'
 CTRL 13
 EQUB 0

 CHAR 'S'               \ Token 5:      "SYSTEM"
 CHAR 'Y'               \ Encoded as:   "SYS<156>M"
 CHAR 'S'
 TWOK 156
 CHAR 'M'
 EQUB 0

 CHAR 'P'               \ Token 6:      "PRICE"
 TWOK 158               \ Encoded as:   "P<158><133>"
 TWOK 133
 EQUB 0

 CTRL 2                 \ Token 7:      "{current system name} MARKET PRICES"
 CHAR ' '               \ Encoded as:   "{2} <139>RKET [6]S"
 TWOK 139
 CHAR 'R'
 CHAR 'K'
 CHAR 'E'
 CHAR 'T'
 CHAR ' '
 RTOK 6
 CHAR 'S'
 EQUB 0

 TWOK 140               \ Token 8:      "INDUSTRIAL"
 CHAR 'D'               \ Encoded as:   "<140>D<136>T<158><128>"
 TWOK 136
 CHAR 'T'
 TWOK 158
 TWOK 128
 EQUB 0

 CHAR 'A'               \ Token 9:      "AGRICULTURAL"
 CHAR 'G'               \ Encoded as:   "AG<158>CULTU<148>L"
 TWOK 158
 CHAR 'C'
 CHAR 'U'
 CHAR 'L'
 CHAR 'T'
 CHAR 'U'
 TWOK 148
 CHAR 'L'
 EQUB 0

 TWOK 158               \ Token 10:     "RICH "
 CHAR 'C'               \ Encoded as:   "<158>CH "
 CHAR 'H'
 CHAR ' '
 EQUB 0

 CHAR 'A'               \ Token 11:     "AVERAGE "
 TWOK 150               \ Encoded as:   "A<150><148><131> "
 TWOK 148
 TWOK 131
 CHAR ' '
 EQUB 0

 CHAR 'P'               \ Token 12:     "POOR "
 CHAR 'O'               \ Encoded as:   "PO<153> "
 TWOK 153
 CHAR ' '
 EQUB 0                 \ Encoded as:   "PO<153> "

 TWOK 139               \ Token 13:     "MAINLY "
 TWOK 140               \ Encoded as:   "<139><140>LY "
 CHAR 'L'
 CHAR 'Y'
 CHAR ' '
 EQUB 0

 CHAR 'U'               \ Token 14:     "UNIT"
 CHAR 'N'               \ Encoded as:   "UNIT"
 CHAR 'I'
 CHAR 'T'
 EQUB 0

 CHAR 'V'               \ Token 15:     "VIEW "
 CHAR 'I'               \ Encoded as:   "VIEW "
 CHAR 'E'
 CHAR 'W'
 CHAR ' '
 EQUB 0

 TWOK 154               \ Token 16:     "QUANTITY"
 TWOK 155               \ Encoded as:   "<154><155><151>TY"
 TWOK 151
 CHAR 'T'
 CHAR 'Y'
 EQUB 0

 TWOK 155               \ Token 17:     "ANARCHY"
 TWOK 138               \ Encoded as:   "<155><138>CHY"
 CHAR 'C'
 CHAR 'H'
 CHAR 'Y'
 EQUB 0

 CHAR 'F'               \ Token 18:     "FEUDAL"
 CHAR 'E'               \ Encoded as:   "FEUD<128>"
 CHAR 'U'
 CHAR 'D'
 TWOK 128
 EQUB 0

 CHAR 'M'               \ Token 19:     "MULTI-GOVERNMENT"
 CHAR 'U'               \ Encoded as:   "MUL<151>-[2]"
 CHAR 'L'
 TWOK 151
 CHAR '-'
 RTOK 2
 EQUB 0

 TWOK 141               \ Token 20:     "DICTATORSHIP"
 CHAR 'C'               \ Encoded as:   "<141>CT<145><153>[25]"
 CHAR 'T'
 TWOK 145
 TWOK 153
 RTOK 25
 EQUB 0

 RTOK 91                \ Token 21:     "COMMUNIST"
 CHAR 'M'               \ Encoded as:   "[91]MUN<157>T"
 CHAR 'U'
 CHAR 'N'
 TWOK 157
 CHAR 'T'
 EQUB 0

 CHAR 'C'               \ Token 22:     "CONFEDERACY"
 TWOK 159               \ Encoded as:   "C<159>F<152><144>ACY"
 CHAR 'F'
 TWOK 152
 TWOK 144
 CHAR 'A'
 CHAR 'C'
 CHAR 'Y'
 EQUB 0

 CHAR 'D'               \ Token 23:     "DEMOCRACY"
 CHAR 'E'               \ Encoded as:   "DEMOC<148>CY"
 CHAR 'M'
 CHAR 'O'
 CHAR 'C'
 TWOK 148
 CHAR 'C'
 CHAR 'Y'
 EQUB 0

 CHAR 'C'               \ Token 24:     "CORPORATE STATE"
 TWOK 153               \ Encoded as:   "C<153>P<153><145>E [43]<145>E"
 CHAR 'P'
 TWOK 153
 TWOK 145
 CHAR 'E'
 CHAR ' '
 RTOK 43
 TWOK 145
 CHAR 'E'
 EQUB 0

 CHAR 'S'               \ Token 25:     "SHIP"
 CHAR 'H'               \ Encoded as:   "SHIP"
 CHAR 'I'
 CHAR 'P'
 EQUB 0

 CHAR 'P'               \ Token 26:     "PRODUCT"
 CHAR 'R'               \ Encoded as:   "PRODUCT"
 CHAR 'O'
 CHAR 'D'
 CHAR 'U'
 CHAR 'C'
 CHAR 'T'
 EQUB 0

 CHAR ' '               \ Token 27:     " LASER"
 TWOK 149               \ Encoded as:   " <149>S<144>"
 CHAR 'S'
 TWOK 144
 EQUB 0

 CHAR 'H'               \ Token 28:     "HUMAN COLONIAL"
 CHAR 'U'               \ Encoded as:   "HUM<155> COL<159>I<128>"
 CHAR 'M'
 TWOK 155
 CHAR ' '
 CHAR 'C'
 CHAR 'O'
 CHAR 'L'
 TWOK 159
 CHAR 'I'
 TWOK 128
 EQUB 0

 CHAR 'H'               \ Token 29:     "HYPERSPACE "
 CHAR 'Y'               \ Encoded as:   "HYP<144>SPA<133> "
 CHAR 'P'
 TWOK 144
 CHAR 'S'
 CHAR 'P'
 CHAR 'A'
 TWOK 133
 CHAR ' '
 EQUB 0

 CHAR 'S'               \ Token 30:     "SHORT RANGE CHART"
 CHAR 'H'               \ Encoded as:   "SH<153>T [42][1]"
 TWOK 153
 CHAR 'T'
 CHAR ' '
 RTOK 42
 RTOK 1
 EQUB 0

 TWOK 141               \ Token 31:     "DISTANCE"
 RTOK 43                \ Encoded as:   "<141>[43]<155><133>"
 TWOK 155
 TWOK 133
 EQUB 0

 CHAR 'P'               \ Token 32:     "POPULATION"
 CHAR 'O'               \ Encoded as:   "POPUL<145>I<159>"
 CHAR 'P'
 CHAR 'U'
 CHAR 'L'
 TWOK 145
 CHAR 'I'
 TWOK 159
 EQUB 0

 CHAR 'G'               \ Token 33:     "GROSS PRODUCTIVITY"
 CHAR 'R'               \ Encoded as:   "GROSS [26]IVITY"
 CHAR 'O'
 CHAR 'S'
 CHAR 'S'
 CHAR ' '
 RTOK 26
 CHAR 'I'
 CHAR 'V'
 CHAR 'I'
 CHAR 'T'
 CHAR 'Y'
 EQUB 0

 CHAR 'E'               \ Token 34:     "ECONOMY"
 CHAR 'C'               \ Encoded as:   "EC<159>OMY"
 TWOK 159
 CHAR 'O'
 CHAR 'M'
 CHAR 'Y'
 EQUB 0

 CHAR ' '               \ Token 35:     " LIGHT YEARS"
 CHAR 'L'               \ Encoded as:   " LIGHT YE<138>S"
 CHAR 'I'
 CHAR 'G'
 CHAR 'H'
 CHAR 'T'
 CHAR ' '
 CHAR 'Y'
 CHAR 'E'
 TWOK 138
 CHAR 'S'
 EQUB 0

 TWOK 156               \ Token 36:     "TECH.LEVEL"
 CHAR 'C'               \ Encoded as:   "<156>CH.<129><150>L"
 CHAR 'H'
 CHAR '.'
 TWOK 129
 TWOK 150
 CHAR 'L'
 EQUB 0

 CHAR 'C'               \ Token 37:     "CASH"
 CHAR 'A'               \ Encoded as:   "CASH"
 CHAR 'S'
 CHAR 'H'
 EQUB 0

 CHAR ' '               \ Token 38:     " BILLION"
 TWOK 134               \ Encoded as:   " <134>[118]I<159>"
 RTOK 118
 CHAR 'I'
 TWOK 159
 EQUB 0

 RTOK 122               \ Token 39:     "GALACTIC CHART{galaxy number
 RTOK 1                 \                right-aligned to width 3}"
 CTRL 1                 \ Encoded as:   "[122][1]{1}"
 EQUB 0

 CHAR 'T'               \ Token 40:     "TARGET LOST"
 TWOK 138               \ Encoded as:   "T<138><131>T LO[43]"
 TWOK 131
 CHAR 'T'
 CHAR ' '
 CHAR 'L'
 CHAR 'O'
 RTOK 43
 EQUB 0

 RTOK 106               \ Token 41:     "MISSILE JAMMED"
 CHAR ' '               \ Encoded as:   "[106] JAMM<152>"
 CHAR 'J'
 CHAR 'A'
 CHAR 'M'
 CHAR 'M'
 TWOK 152
 EQUB 0

 CHAR 'R'               \ Token 42:     "RANGE"
 TWOK 155               \ Encoded as:   "R<155><131>"
 TWOK 131
 EQUB 0

 CHAR 'S'               \ Token 43:     "ST"
 CHAR 'T'               \ Encoded as:   "ST"
 EQUB 0

 RTOK 16                \ Token 44:     "QUANTITY OF "
 CHAR ' '               \ Encoded as:   "[16] OF "
 CHAR 'O'
 CHAR 'F'
 CHAR ' '
 EQUB 0

 CHAR 'S'               \ Token 45:     "SELL"
 CHAR 'E'               \ Encoded as:   "SE[118]"
 RTOK 118
 EQUB 0

 CHAR ' '               \ Token 46:     " CARGO{switch to sentence case}"
 CHAR 'C'               \ Encoded as:   " C<138>GO{6}"
 TWOK 138
 CHAR 'G'
 CHAR 'O'
 CTRL 6
 EQUB 0

 CHAR 'E'               \ Token 47:     "EQUIP"
 TWOK 154               \ Encoded as:   "E<154>IP"
 CHAR 'I'
 CHAR 'P'
 EQUB 0

 CHAR 'F'               \ Token 48:     "FOOD"
 CHAR 'O'               \ Encoded as:   "FOOD"
 CHAR 'O'
 CHAR 'D'
 EQUB 0

 TWOK 156               \ Token 49:     "TEXTILES"
 CHAR 'X'               \ Encoded as:   "<156>X<151>L<137>"
 TWOK 151
 CHAR 'L'
 TWOK 137
 EQUB 0

 TWOK 148               \ Token 50:     "RADIOACTIVES"
 TWOK 141               \ Encoded as:   "<148><141>OAC<151><150>S"
 CHAR 'O'
 CHAR 'A'
 CHAR 'C'
 TWOK 151
 TWOK 150
 CHAR 'S'
 EQUB 0

 CHAR 'S'               \ Token 51:     "SLAVES"
 TWOK 149               \ Encoded as:   "S<149><150>S"
 TWOK 150
 CHAR 'S'
 EQUB 0

 CHAR 'L'               \ Token 52:     "LIQUOR/WINES"
 CHAR 'I'               \ Encoded as:   "LI<154><153>/W<140><137>"
 TWOK 154
 TWOK 153
 CHAR '/'
 CHAR 'W'
 TWOK 140
 TWOK 137
 EQUB 0

 CHAR 'L'               \ Token 53:     "LUXURIES"
 CHAR 'U'               \ Encoded as:   "LUXU<158><137>"
 CHAR 'X'
 CHAR 'U'
 TWOK 158
 TWOK 137
 EQUB 0

 CHAR 'N'               \ Token 54:     "NARCOTICS"
 TWOK 138               \ Encoded as:   "N<138>CO<151>CS"
 CHAR 'C'
 CHAR 'O'
 TWOK 151
 CHAR 'C'
 CHAR 'S'
 EQUB 0

 RTOK 91                \ Token 55:     "COMPUTERS"
 CHAR 'P'               \ Encoded as:   "[91]PUT<144>S"
 CHAR 'U'
 CHAR 'T'
 TWOK 144
 CHAR 'S'
 EQUB 0

 TWOK 139               \ Token 56:     "MACHINERY"
 CHAR 'C'               \ Encoded as:   "<139>CH<140><144>Y"
 CHAR 'H'
 TWOK 140
 TWOK 144
 CHAR 'Y'
 EQUB 0

 RTOK 117               \ Token 57:     "ALLOYS"
 CHAR 'O'               \ Encoded as:   "[117]OYS"
 CHAR 'Y'
 CHAR 'S'
 EQUB 0

 CHAR 'F'               \ Token 58:     "FIREARMS"
 CHAR 'I'               \ Encoded as:   "FI<142><138>MS"
 TWOK 142
 TWOK 138
 CHAR 'M'
 CHAR 'S'
 EQUB 0

 CHAR 'F'               \ Token 59:     "FURS"
 CHAR 'U'               \ Encoded as:   "FURS"
 CHAR 'R'
 CHAR 'S'
 EQUB 0

 CHAR 'M'               \ Token 60:     "MINERALS"
 TWOK 140               \ Encoded as:   "M<140><144><128>S"
 TWOK 144
 TWOK 128
 CHAR 'S'
 EQUB 0

 CHAR 'G'               \ Token 61:     "GOLD"
 CHAR 'O'               \ Encoded as:   "GOLD"
 CHAR 'L'
 CHAR 'D'
 EQUB 0

 CHAR 'P'               \ Token 62:     "PLATINUM"
 CHAR 'L'               \ Encoded as:   "PL<145><140>UM"
 TWOK 145
 TWOK 140
 CHAR 'U'
 CHAR 'M'
 EQUB 0

 TWOK 131               \ Token 63:     "GEM-STONES"
 CHAR 'M'               \ Encoded as:   "<131>M-[43]<159><137>"
 CHAR '-'
 RTOK 43
 TWOK 159
 TWOK 137
 EQUB 0

 TWOK 128               \ Token 64:     "ALIEN ITEMS"
 CHAR 'I'               \ Encoded as:   "<128>I<146> [127]S"
 TWOK 146
 CHAR ' '
 RTOK 127
 CHAR 'S'
 EQUB 0

 CHAR '('               \ Token 65:     "(Y/N)?"
 CHAR 'Y'               \ Encoded as:   "(Y/N)?"
 CHAR '/'
 CHAR 'N'
 CHAR ')'
 CHAR '?'
 EQUB 0

 CHAR ' '               \ Token 66:     " CR"
 CHAR 'C'               \ Encoded as:   " CR"
 CHAR 'R'
 EQUB 0

 CHAR 'L'               \ Token 67:     "LARGE"
 TWOK 138               \ Encoded as:   "L<138><131>"
 TWOK 131
 EQUB 0

 CHAR 'F'               \ Token 68:     "FIERCE"
 CHAR 'I'               \ Encoded as:   "FI<144><133>"
 TWOK 144
 TWOK 133
 EQUB 0

 CHAR 'S'               \ Token 69:     "SMALL"
 TWOK 139               \ Encoded as:   "S<139>[118]"
 RTOK 118
 EQUB 0

 CHAR 'G'               \ Token 70:     "GREEN"
 TWOK 142               \ Encoded as:   "G<142><146>"
 TWOK 146
 EQUB 0

 CHAR 'R'               \ Token 71:     "RED"
 TWOK 152               \ Encoded as:   "R<152>"
 EQUB 0

 CHAR 'Y'               \ Token 72:     "YELLOW"
 CHAR 'E'               \ Encoded as:   "YE[118]OW"
 RTOK 118
 CHAR 'O'
 CHAR 'W'
 EQUB 0

 CHAR 'B'               \ Token 73:     "BLUE"
 CHAR 'L'               \ Encoded as:   "BLUE"
 CHAR 'U'
 CHAR 'E'
 EQUB 0

 CHAR 'B'               \ Token 74:     "BLACK"
 TWOK 149               \ Encoded as:   "B<149>CK"
 CHAR 'C'
 CHAR 'K'
 EQUB 0

 RTOK 136               \ Token 75:     "HARMLESS"
 EQUB 0                 \ Encoded as:   "[136]"

 CHAR 'S'               \ Token 76:     "SLIMY"
 CHAR 'L'               \ Encoded as:   "SLIMY"
 CHAR 'I'
 CHAR 'M'
 CHAR 'Y'
 EQUB 0

 CHAR 'B'               \ Token 77:     "BUG-EYED"
 CHAR 'U'               \ Encoded as:   "BUG-EY<152>"
 CHAR 'G'
 CHAR '-'
 CHAR 'E'
 CHAR 'Y'
 TWOK 152
 EQUB 0

 CHAR 'H'               \ Token 78:     "HORNED"
 TWOK 153               \ Encoded as:   "H<153>N<152>"
 CHAR 'N'
 TWOK 152
 EQUB 0

 CHAR 'B'               \ Token 79:     "BONY"
 TWOK 159               \ Encoded as:   "B<159>Y"
 CHAR 'Y'
 EQUB 0

 CHAR 'F'               \ Token 80:     "FAT"
 TWOK 145               \ Encoded as:   "F<145>"
 EQUB 0

 CHAR 'F'               \ Token 81:     "FURRY"
 CHAR 'U'               \ Encoded as:   "FURRY"
 CHAR 'R'
 CHAR 'R'
 CHAR 'Y'
 EQUB 0

 CHAR 'R'               \ Token 82:     "RODENT"
 CHAR 'O'               \ Encoded as:   "ROD<146>T"
 CHAR 'D'
 TWOK 146
 CHAR 'T'
 EQUB 0

 CHAR 'F'               \ Token 83:     "FROG"
 CHAR 'R'               \ Encoded as:   "FROG"
 CHAR 'O'
 CHAR 'G'
 EQUB 0

 CHAR 'L'               \ Token 84:     "LIZARD"
 CHAR 'I'               \ Encoded as:   "LI<132>RD"
 TWOK 132
 CHAR 'R'
 CHAR 'D'
 EQUB 0

 CHAR 'L'               \ Token 85:     "LOBSTER"
 CHAR 'O'               \ Encoded as:   "LOB[43]<144>"
 CHAR 'B'
 RTOK 43
 TWOK 144
 EQUB 0

 TWOK 134               \ Token 86:     "BIRD"
 CHAR 'R'               \ Encoded as:   "<134>RD"
 CHAR 'D'
 EQUB 0

 CHAR 'H'               \ Token 87:     "HUMANOID"
 CHAR 'U'               \ Encoded as:   "HUM<155>OID"
 CHAR 'M'
 TWOK 155
 CHAR 'O'
 CHAR 'I'
 CHAR 'D'
 EQUB 0

 CHAR 'F'               \ Token 88:     "FELINE"
 CHAR 'E'               \ Encoded as:   "FEL<140>E"
 CHAR 'L'
 TWOK 140
 CHAR 'E'
 EQUB 0

 TWOK 140               \ Token 89:     "INSECT"
 CHAR 'S'               \ Encoded as:   "<140>SECT"
 CHAR 'E'
 CHAR 'C'
 CHAR 'T'
 EQUB 0

 RTOK 11                \ Token 90:     "AVERAGE RADIUS"
 TWOK 148               \ Encoded as:   "[11]<148><141><136>"
 TWOK 141
 TWOK 136
 EQUB 0

 CHAR 'C'               \ Token 91:     "COM"
 CHAR 'O'               \ Encoded as:   "COM"
 CHAR 'M'
 EQUB 0

 RTOK 91                \ Token 92:     "COMMANDER"
 CHAR 'M'               \ Encoded as:   "[91]M<155>D<144>"
 TWOK 155
 CHAR 'D'
 TWOK 144
 EQUB 0

 CHAR ' '               \ Token 93:     " DESTROYED"
 CHAR 'D'               \ Encoded as:   " D<137>TROY<152>"
 TWOK 137
 CHAR 'T'
 CHAR 'R'
 CHAR 'O'
 CHAR 'Y'
 TWOK 152
 EQUB 0

 CHAR 'B'               \ Token 94:     "BY D.BRABEN & I.BELL"
 CHAR 'Y'               \ Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
 CHAR ' '
 CHAR 'D'
 CHAR '.'
 CHAR 'B'
 TWOK 148
 TWOK 147
 CHAR 'N'
 CHAR ' '
 CHAR '&'
 CHAR ' '
 CHAR 'I'
 CHAR '.'
 TWOK 147
 RTOK 118
 EQUB 0

 RTOK 14                \ Token 95:     "UNIT  QUANTITY{crlf} PRODUCT   UNIT
 CHAR ' '               \                 PRICE FOR SALE{crlf}{lf}"
 CHAR ' '               \ Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
 RTOK 16                \                 SA<129>{13}{10}"
 CTRL 13
 CHAR ' '
 RTOK 26
 CHAR ' '
 CHAR ' '
 CHAR ' '
 RTOK 14
 CHAR ' '
 RTOK 6
 CHAR ' '
 CHAR 'F'
 TWOK 153
 CHAR ' '
 CHAR 'S'
 CHAR 'A'
 TWOK 129
 CTRL 13
 CTRL 10
 EQUB 0

 CHAR 'F'               \ Token 96:     "FRONT"
 CHAR 'R'               \ Encoded as:   "FR<159>T"
 TWOK 159
 CHAR 'T'
 EQUB 0

 TWOK 142               \ Token 97:     "REAR"
 TWOK 138               \ Encoded as:   "<142><138>"
 EQUB 0

 TWOK 129               \ Token 98:     "LEFT"
 CHAR 'F'               \ Encoded as:   "<129>FT"
 CHAR 'T'
 EQUB 0

 TWOK 158               \ Token 99:     "RIGHT"
 CHAR 'G'               \ Encoded as:   "<158>GHT"
 CHAR 'H'
 CHAR 'T'
 EQUB 0

 RTOK 121               \ Token 100:    "ENERGY LOW{beep}"
 CHAR 'L'               \ Encoded as:   "[121]LOW{7}"
 CHAR 'O'
 CHAR 'W'
 CTRL 7
 EQUB 0

 RTOK 99                \ Token 101:    "RIGHT ON COMMANDER!"
 RTOK 131               \ Encoded as:   "[99][131][92]!"
 RTOK 92
 CHAR '!'
 EQUB 0

 CHAR 'E'               \ Token 102:    "EXTRA "
 CHAR 'X'               \ Encoded as:   "EXT<148> "
 CHAR 'T'
 TWOK 148
 CHAR ' '
 EQUB 0

 CHAR 'P'               \ Token 103:    "PULSE LASER"
 CHAR 'U'               \ Encoded as:   "PULSE[27]"
 CHAR 'L'
 CHAR 'S'
 CHAR 'E'
 RTOK 27
 EQUB 0

 TWOK 147               \ Token 104:    "BEAM LASER"
 CHAR 'A'               \ Encoded as:   "<147>AM[27]"
 CHAR 'M'
 RTOK 27
 EQUB 0

 CHAR 'F'               \ Token 105:    "FUEL"
 CHAR 'U'               \ Encoded as:   "FUEL"
 CHAR 'E'
 CHAR 'L'
 EQUB 0

 CHAR 'M'               \ Token 106:    "MISSILE"
 TWOK 157               \ Encoded as:   "M<157>SI<129>"
 CHAR 'S'
 CHAR 'I'
 TWOK 129
 EQUB 0

 RTOK 67                \ Token 107:    "LARGE CARGO{switch to sentence
 RTOK 46                \                 case} BAY"
 CHAR ' '               \ Encoded as:   "[67][46] BAY"
 CHAR 'B'
 CHAR 'A'
 CHAR 'Y'
 EQUB 0

 CHAR 'E'               \ Token 108:    "E.C.M.SYSTEM"
 CHAR '.'               \ Encoded as:   "E.C.M.[5]"
 CHAR 'C'
 CHAR '.'
 CHAR 'M'
 CHAR '.'
 RTOK 5
 EQUB 0

 RTOK 102               \ Token 109:    "EXTRA PULSE LASERS"
 RTOK 103               \ Encoded as:   "[102][103]S"
 CHAR 'S'
 EQUB 0

 RTOK 102               \ Token 110:    "EXTRA BEAM LASERS"
 RTOK 104               \ Encoded as:   "[102][104]S"
 CHAR 'S'
 EQUB 0

 RTOK 105               \ Token 111:    "FUEL SCOOPS"
 CHAR ' '               \ Encoded as:   "[105] SCOOPS"
 CHAR 'S'
 CHAR 'C'
 CHAR 'O'
 CHAR 'O'
 CHAR 'P'
 CHAR 'S'
 EQUB 0

 TWOK 137               \ Token 112:    "ESCAPE POD"
 CHAR 'C'               \ Encoded as:   "<137>CAPE POD"
 CHAR 'A'
 CHAR 'P'
 CHAR 'E'
 CHAR ' '
 CHAR 'P'
 CHAR 'O'
 CHAR 'D'
 EQUB 0

 RTOK 121               \ Token 113:    "ENERGY BOMB"
 CHAR 'B'               \ Encoded as:   "[121]BOMB"
 CHAR 'O'
 CHAR 'M'
 CHAR 'B'
 EQUB 0

 RTOK 121               \ Token 114:    "ENERGY UNIT"
 RTOK 14                \ Encoded as:   "[121][14]"
 EQUB 0

 RTOK 124               \ Token 115:    "DOCKING COMPUTERS"
 TWOK 140               \ Encoded as:   "[124]<140>G [55]"
 CHAR 'G'
 CHAR ' '
 RTOK 55
 EQUB 0

 RTOK 122               \ Token 116:    "GALACTIC HYPERSPACE "
 CHAR ' '               \ Encoded as:   "[122] [29]"
 RTOK 29
 EQUB 0

 CHAR 'A'               \ Token 117:    "ALL"
 RTOK 118               \ Encoded as:   "A[118]"
 EQUB 0

 CHAR 'L'               \ Token 118:    "LL"
 CHAR 'L'               \ Encoded as:   "LL"
 EQUB 0

 RTOK 37                \ Token 119:    "CASH:{cash right-aligned to width 9}
 CHAR ':'               \                 CR{crlf}"
 CTRL 0                 \ Encoded as:   "[37]:{0}"
 EQUB 0

 TWOK 140               \ Token 120:    "INCOMING MISSILE"
 RTOK 91                \ Encoded as:   "<140>[91]<140>G [106]"
 TWOK 140
 CHAR 'G'
 CHAR ' '
 RTOK 106
 EQUB 0

 TWOK 146               \ Token 121:    "ENERGY "
 TWOK 144               \ Encoded as:   "<146><144>GY "
 CHAR 'G'
 CHAR 'Y'
 CHAR ' '
 EQUB 0

 CHAR 'G'               \ Token 122:    "GALACTIC"
 CHAR 'A'               \ Encoded as:   "GA<149>C<151>C"
 TWOK 149
 CHAR 'C'
 TWOK 151
 CHAR 'C'
 EQUB 0

 CTRL 13                \ Token 123:    "{crlf}COMMANDER'S NAME? "
 RTOK 92                \ Encoded as:   "{13}[92]'S NAME? "
 CHAR 39                \ CHAR 39 is the apostrophe
 CHAR 'S'
 CHAR ' '
 CHAR 'N'
 CHAR 'A'
 CHAR 'M'
 CHAR 'E'
 CHAR '?'
 CHAR ' '
 EQUB 0

 CHAR 'D'               \ Token 124:    "DOCK"
 CHAR 'O'               \ Encoded as:   "DOCK"
 CHAR 'C'
 CHAR 'K'
 EQUB 0

 CTRL 5                 \ Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
 TWOK 129               \                CASH:{cash right-aligned to width 9}
 CHAR 'G'               \                 CR{crlf}LEGAL STATUS:"
 TWOK 128               \ Encoded as:   "{5}<129>G<128> [43]<145><136>:"
 CHAR ' '
 RTOK 43
 TWOK 145
 TWOK 136
 CHAR ':'
 EQUB 0

 RTOK 92                \ Token 126:    "COMMANDER {commander name}{crlf}{crlf}
 CHAR ' '               \                {crlf}{switch to sentence case}PRESENT
 CTRL 4                 \                 SYSTEM{tab to column 21}:{current
 CTRL 13                \                system name}{crlf}HYPERSPACE SYSTEM
 CTRL 13                \                {tab to column 21}:{selected system
 CTRL 13                \                name}{crlf}CONDITION{tab to column
 CTRL 6                 \                21}:"
 RTOK 145               \ Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
 CHAR ' '               \                {13}[29][5]{9}{3}{13}C<159><141><151>
 RTOK 5                 \                <159>{9}"
 CTRL 9
 CTRL 2
 CTRL 13
 RTOK 29
 RTOK 5
 CTRL 9
 CTRL 3
 CTRL 13
 CHAR 'C'
 TWOK 159
 TWOK 141
 TWOK 151
 TWOK 159
 CTRL 9
 EQUB 0

 CHAR 'I'               \ Token 127:    "ITEM"
 TWOK 156               \ Encoded as:   "I<156>M"
 CHAR 'M'
 EQUB 0

 CHAR ' '               \ Token 128:    "  LOAD NEW COMMANDER (Y/N)?
 CHAR ' '               \                {crlf}{crlf}"
 CHAR 'L'               \ Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
 CHAR 'O'
 CHAR 'A'
 CHAR 'D'
 CHAR ' '
 CHAR 'N'
 CHAR 'E'
 CHAR 'W'
 CHAR ' '
 RTOK 92
 CHAR ' '
 RTOK 65
 CTRL 13
 CTRL 13
 EQUB 0

 CTRL 6                 \ Token 129:    "{switch to sentence case}DOCKED"
 RTOK 124               \ Encoded as:   "{6}[124]<152>"
 TWOK 152
 EQUB 0

 TWOK 148               \ Token 130:    "RATING:"
 TWOK 151               \ Encoded as:   "<148><151>NG:"
 CHAR 'N'
 CHAR 'G'
 CHAR ':'
 EQUB 0

 CHAR ' '               \ Token 131:    " ON "
 TWOK 159               \ Encoded as:   " <159> "
 CHAR ' '
 EQUB 0

 CTRL 13                \ Token 132:    "{crlf}{switch to all caps}EQUIPMENT:
 CTRL 8                 \                {switch to sentence case}"
 RTOK 47                \ Encoded as:   "{13}{8}[47]M<146>T:{6}"
 CHAR 'M'
 TWOK 146
 CHAR 'T'
 CHAR ':'
 CTRL 6
 EQUB 0

 CHAR 'C'               \ Token 133:    "CLEAN"
 TWOK 129               \ Encoded as:   "C<129><155>"
 TWOK 155
 EQUB 0

 CHAR 'O'               \ Token 134:    "OFFENDER"
 CHAR 'F'               \ Encoded as:   "OFF<146>D<144>"
 CHAR 'F'
 TWOK 146
 CHAR 'D'
 TWOK 144
 EQUB 0

 CHAR 'F'               \ Token 135:    "FUGITIVE"
 CHAR 'U'               \ Encoded as:   "FUGI<151><150>"
 CHAR 'G'
 CHAR 'I'
 TWOK 151
 TWOK 150
 EQUB 0

 CHAR 'H'               \ Token 136:    "HARMLESS"
 TWOK 138               \ Encoded as:   "H<138>M<129>SS"
 CHAR 'M'
 TWOK 129
 CHAR 'S'
 CHAR 'S'
 EQUB 0

 CHAR 'M'               \ Token 137:    "MOSTLY HARMLESS"
 CHAR 'O'               \ Encoded as:   "MO[43]LY [136]"
 RTOK 43
 CHAR 'L'
 CHAR 'Y'
 CHAR ' '
 RTOK 136
 EQUB 0

 RTOK 12                \ Token 138:    "POOR "
 EQUB 0                 \ Encoded as:   "[12]"

 RTOK 11                \ Token 139:    "AVERAGE "
 EQUB 0                 \ Encoded as:   "[11]"

 CHAR 'A'               \ Token 140:    "ABOVE AVERAGE "
 CHAR 'B'               \ Encoded as:   "ABO<150> [11]"
 CHAR 'O'
 TWOK 150
 CHAR ' '
 RTOK 11
 EQUB 0

 RTOK 91                \ Token 141:    "COMPETENT"
 CHAR 'P'               \ Encoded as:   "[91]PET<146>T"
 CHAR 'E'
 CHAR 'T'
 TWOK 146
 CHAR 'T'
 EQUB 0

 CHAR 'D'               \ Token 142:    "DANGEROUS"
 TWOK 155               \ Encoded as:   "D<155><131>RO<136>"
 TWOK 131
 CHAR 'R'
 CHAR 'O'
 TWOK 136
 EQUB 0

 CHAR 'D'               \ Token 143:    "DEADLY"
 CHAR 'E'               \ Encoded as:   "DEADLY"
 CHAR 'A'
 CHAR 'D'
 CHAR 'L'
 CHAR 'Y'
 EQUB 0

 CHAR '-'               \ Token 144:    "---- E L I T E ----"
 CHAR '-'               \ Encoded as:   "---- E L I T E ----"
 CHAR '-'
 CHAR '-'
 CHAR ' '
 CHAR 'E'
 CHAR ' '
 CHAR 'L'
 CHAR ' '
 CHAR 'I'
 CHAR ' '
 CHAR 'T'
 CHAR ' '
 CHAR 'E'
 CHAR ' '
 CHAR '-'
 CHAR '-'
 CHAR '-'
 CHAR '-'
 EQUB 0

 CHAR 'P'               \ Token 145:    "PRESENT"
 TWOK 142               \ Encoded as:   "P<142>S<146>T"
 CHAR 'S'
 TWOK 146
 CHAR 'T'
 EQUB 0

 CTRL 8                 \ Token 146:    "{switch to all caps}GAME OVER"
 CHAR 'G'               \ Encoded as:   "{8}GAME O<150>R"
 CHAR 'A'
 CHAR 'M'
 CHAR 'E'
 CHAR ' '
 CHAR 'O'
 TWOK 150
 CHAR 'R'
 EQUB 0

 CHAR 'P'               \ Token 147:    "PRESS FIRE OR SPACE,COMMANDER.
 CHAR 'R'               \                {crlf}{crlf}"
 TWOK 137               \ Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
 CHAR 'S'               \                {13}{13}"
 CHAR ' '
 CHAR 'F'
 CHAR 'I'
 TWOK 142
 CHAR ' '
 TWOK 153
 CHAR ' '
 CHAR 'S'
 CHAR 'P'
 CHAR 'A'
 TWOK 133
 CHAR ','
 RTOK 92
 CHAR '.'
 CTRL 13
 CTRL 13
 EQUB 0

 CHAR '('               \ Token 148:    "(C) ACORNSOFT 1984"
 CHAR 'C'               \ Encoded as:   "(C) AC<153>N<135>FT 1984"
 CHAR ')'
 CHAR ' '
 CHAR 'A'
 CHAR 'C'
 TWOK 153
 CHAR 'N'
 TWOK 135
 CHAR 'F'
 CHAR 'T'
 CHAR ' '
 CHAR '1'
 CHAR '9'
 CHAR '8'
 CHAR '4'
 EQUB 0

\ ******************************************************************************
\
\ Save output/WORDS9.bin
\
\ ******************************************************************************

PRINT "WORDS9"
PRINT "Assembled at ", ~CODE_WORDS%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_WORDS%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_WORDS%

PRINT "S.WORDS9 ",~CODE%," ",~P%," ",~LOAD%," ",~LOAD_WORDS%
SAVE "output/WORDS9.bin", CODE_WORDS%, P%, LOAD%

\ ******************************************************************************
\
\ Workspace K% at &0900
\
\ Contains ship data for all the ships, planets, suns and space stations in our
\ local bubble of universe, along with their correspondingship lines heap space.
\
\ The blocks are pointed to by the lookup table at location UNIV. The first 468
\ bytes of the K% workspace holds data on up to 13 ships, with 36 (NI%) bytes
\ per ship, and the heap space grows downwards from WP at the end of the K%
\ workspace.
\
\ ******************************************************************************
\
\ Deep dive: Ship data blocks
\ ---------------------------
\ Every ship in our local bubble of universe has its own data block, stored in
\ the K% workspace. The data block contains information about the ship's status,
\ its location in space, its orientation and so on. Each ship in the local
\ bubble has an entry in the lookup table at UNIV that points to its data block
\ in K%, and along with the ship slots at FRIN and the ship blueprints at XX21,
\ we have everything we need to simulate the world of Elite.
\
\ When working with a ship's data - such as when we move a ship in MVEIT, or
\ spawn a child ship in SFS1 - we normally work with the data in the INWK
\ workspace, as INWK is in zero page and is therefore faster and more memory
\ efficient to manipulate. The ship data blocks in the workspace at K% are
\ therefore copied into INWK before they are worked on, and new ship blocks
\ are created in INWK before being copied to K%, so the layout of the INWK data
\ block is identical the layout of each blocks in K%. Because we tend to work
\ with INWK rather than K%, the comments below reflect that, talking about
\ INWK+5 for byte #5 of the ship data (y_sign), or INWK+32 for byte #32 (the AI
\ flag). Every now and then the bytes in the K% block are manipulated directly,
\ but most of the time it's all about INWK.
\
\ There are 36 bytes of data in each ship's block, and the same data structure
\ is used to describe every type of object in the universe, not just ships
\ (though we just refer to this as "ship data" for convenience). This means
\ there is a data block for the planet, another for the sun and another for the
\ space station, as well as ones for non-ship objects like asteroids and cargo
\ canisters. They all have the same format, though not all bytes are used for
\ all ship types (planets don't have AI or missiles, for example, though it
\ would be fun if they did...).
\
\ Summary of .INWK and .K% ship data block format
\ -----------------------------------------------
\ The bytes in INWK and K% are arranged as follows:
\
\   * Ship coordinates (bytes 0-8):
\
\     * x = INWK(2 1 0)
\     * y = INWK(5 4 3)
\     * z = INWK(8 7 6)
\
\   * Orientation vectors (bytes 9-26):
\
\     * nosev = (INWK(10 9),  INWK(12 11), INWK(14 13))
\     * roofv = (INWK(16 15), INWK(18 17), INWK(20 19))
\     * sidev = (INWK(22 21), INWK(24 23), INWK(26 25))
\
\   * Ship movement (bytes 27-30):
\
\     * Speed = INWK+27
\     * Acceleration = INWK+28
\     * Roll counter = INWK+29
\     * Pitch counter = INWK+30
\
\   * Ship flags (bytes 31-32):
\
\     * Exploding/killed state, scanner flag, missile count = INWK+31
\     * AI, hostility and E.C.M. flags = INWK+32
\
\   * Heap pointer and energy (bytes 33-35):
\
\     * Ship lines heap space pointer = INWK(34 33)
\     * Ship energy = INWK+35
\ 
\ Let's look at these in more detail.
\
\ Ship coordinates (bytes 0-8)
\ ----------------------------
\ INWK   = x_lo
\ INWK+1 = x_hi
\ INWK+2 = x_sign
\
\ INWK+3 = y_lo
\ INWK+4 = y_hi
\ INWK+5 = y_sign
\
\ INWK+6 = z_lo
\ INWK+7 = z_hi
\ INWK+8 = z_sign
\
\ The x, y and z coordinates in INWK to INWK+8 are stored as 24-bit
\ sign-magnitude numbers, where the sign of the number is stored in bit 7 of the
\ sign byte, and the other 23 bits contain the magnitude of the number without
\ any sign (i.e. the absolute value, |x|, |y| or |z|). So an x value of &123456
\ would be stored like this:
\
\      x_sign          x_hi          x_lo
\         &12           &34           &56
\   0 0010010      00110100      01010110
\
\ while -&123456 is identical, just with bit 7 of the x_sign byte set:
\
\      x_sign          x_hi          x_lo
\        -&12           &34           &56
\   1 0010010      00110100      01010110
\
\ We can also write it like this:
\
\   x-coordinate = (x_sign x_hi x_lo) = INWK(2 1 0)
\   y-coordinate = (y_sign y_hi y_lo) = INWK(5 4 3)
\   z-coordinate = (z_sign z_hi z_lo) = INWK(8 7 6)
\
\ Orientation vectors (bytes 9-26)
\ --------------------------------
\ INWK+9  = nosev_x_lo
\ INWK+10 = nosev_x_hi
\ INWK+11 = nosev_y_lo
\ INWK+12 = nosev_y_hi
\ INWK+13 = nosev_z_lo
\ INWK+14 = nosev_z_hi
\
\ INWK+15 = roofv_x_lo
\ INWK+16 = roofv_x_hi
\ INWK+17 = roofv_y_lo
\ INWK+18 = roofv_y_hi
\ INWK+19 = roofv_z_lo
\ INWK+20 = roofv_z_hi
\
\ INWK+21 = sidev_x_lo
\ INWK+22 = sidev_x_hi
\ INWK+23 = sidev_y_lo
\ INWK+24 = sidev_y_hi
\ INWK+25 = sidev_z_lo
\ INWK+26 = sidev_z_hi
\
\ The vectors in INWK+9 to INWK+26 are stored as 24-bit sign-magnitude numbers,
\ where the sign of the number is stored in bit 7 of the high byte. See above
\ for more on this number format.
\
\ The ship's orientation vectors determine its orientation in space. There are
\ three different vectors, nosev, roofv and sidev, with each of them pointing
\ along one of the ship's main axes, like this:
\
\   roofv (points up out of the ship's sunroof...
\   ^       or it would if it had one)
\   |
\   |
\   |
\   |    nosev (points forward out of the ship's nose
\   |   /        and into the screen)
\   |  /
\   | /
\   |/
\   +-----------------------> sidev (points out of the
\                                    ship's right view)
\
\ These vectors are orthonormal, which means they are orthogonal (i.e. they are
\ perpendicular to each other), and normal (i.e. each of the vectors has length
\ 1). We can rotate a ship in space by rotating these vectors, as in the MVS4
\ and MVS5 routines. Because we use the small angle approximation to rotate in
\ space, and it is is not completely accurate, the three vectors tend to get
\ stretched over time, so periodically we tidy the vectors in the TIDY routine
\ to ensure they remain as orthonormal as possible.
\ 
\ We can refer to these three vectors in various ways, such as these variations
\ for the nosev vector:
\
\
\   nosev = (nosev_x, nosev_y, nosev_z)
\
\            [ nosev_x ]
\          = [ nosev_y ]
\            [ nosev_z ]
\           
\            [ (nosev_x_hi nosev_x_lo) ]
\          = [ (nosev_y_hi nosev_y_lo) ]
\            [ (nosev_z_hi nosev_z_lo) ]
\           
\            [ INWK(10 9) ]
\          = [ INWK(12 11) ]
\            [ INWK(14 13) ]
\
\ The vectors are initialised in ZINF as follows:
\
\   nosev = (0,  0, -1)
\   roofv = (0,  1,  0)
\   sidev = (1,  0,  0)
\
\ so new ships are spawned facing out of the screen, as their nosev vectors
\ point in a negative direction along the z-axis, which is positive into the
\ screen and negative out of the screen.
\ 
\ Internally, we store a vector value of 1 as 96, to support fractional values,
\ and the orientation vectors are stored as 16-bit sign-magnitude numbers. 96 is
\ &60, and &60 with bit 7 set is &E0, so we store the above vectors like this:
\
\   nosev = (0, 0, &E000)
\   roofv = (0, &6000, 0)
\   sidev = (&6000, 0, 0)
\
\ so nosev_z_hi = &E0, sidev_x_hi = &60 and so on.
\
\ Sometimes we might refer to the orientation vectors as a matrix, with nosev
\ as the first row, roofv as the second row, and sidev as the third row, like
\ this:
\
\   [nosev_x nosev_y nosev_z]
\   [roofv_x roofv_y roofv_z]
\   [sidev_x sidev_y sidev_z]
\
\ though generally we deal with the individual vectors, because that's easier
\ to understand.
\
\ Ship movement (bytes 27-30)
\ ---------------------------
\ INWK+27 = speed
\
\   * 31 = fast
\
\ INWK+28 = acceleration
\
\   * Gets added to the speed once, in MVEIT, before being zeroed again
\
\ INWK+29 = roll counter
\
\   * Ship rolls when bits 0-6 counter > 0
\
\   * Bit 7 = direction of roll (sign)
\
\   * Bits 0-6 = counter, reduces by 1 every iteration of the main flight loop
\     if damping is enabled
\
\ INWK+30 = pitch counter
\
\   * Ship pitches when bits 0-6 counter > 0
\
\   * Bit 7 = direction of pitch (sign)
\
\   * Bits 0-6 = counter, reduces by 1 every iteration of the main flight loop
\     if damping is enabled
\
\ Ship flags (bytes 31-32)
\ ------------------------
\ INWK+31 = exploding/killed state, scanner flag, or missile count
\
\   * Bits 0-2: n = number of missiles or Thargons
\   * Bit 3:    0 = no explosion cloud   1 = keep updating explosion cloud
\   * Bit 4:    0 = hide on scanner      1 = show on scanner
\   * Bit 5:    0 = not exploding        1 = exploding
\   * Bit 6:    0 = no laser fire        1 = this ship's laser is firing at us
\   * Bit 7:    0 = ship is alive        1 = ship has been killed
\
\ INWK+32 = AI, hostility and E.C.M. flags
\
\   * For ships:
\
\     * Bit 0:    0 = no E.C.M.          1 = has E.C.M.
\     * Bits 1-5: n = aggression level, high = aggressive (see TACTICS part 7)
\     * Bit 6:    0 = friendly           1 = hostile
\     * Bit 7:    0 = dumb               1 = AI enabled (tactics get applied)
\
\   * For the space station:
\
\     * Bit 7:    0 = friendly           1 = hostile
\
\   * For missiles:
\
\     * Bit 0:    0 = no lock/launched   1 = target locked
\     * Bits 1-4: n = target's slot number
\     * Bit 6:    0 = friendly           1 = hostile
\     * Bit 7:    0 = dumb               1 = AI enabled (tactics get applied)
\
\ Heap pointer and energy (bytes 33-34)
\ -------------------------------------
\ INWK(34 33) = ship lines heap space address pointer
\
\ INWK+35 = ship energy
\
\ ******************************************************************************

ORG &0900

.K%                     \ Ship data blocks and ship lines heap space

\ ******************************************************************************
\
\ Workspace WP at &0D40 - &0F34
\
\ ******************************************************************************

ORG &0D40

.WP                     \ Start of workspace WP

.FRIN

 SKIP NOSH + 1          \ Slots for the 13 ships in the local bubble of universe
                        \
                        \ Each slot contains a ship type from 1-13 (see the list
                        \ of ship types in location XX21), 0 if the slot is
                        \ empty, 128 or 130 for the planet, or 129 if this is
                        \ the sun
                        \
                        \ The corresponding address in the lookup table at UNIV
                        \ points to the ship's data block, which in turn points
                        \ to that ship's line heap space
                        \
                        \ The first ship slot at location FRIN is reserved for
                        \ the planet, which will have 128 or 130 in the slot
                        \ (128 is a planet with an equator and meridian, 130 is
                        \ a planet with a crater)
                        \
                        \ The second ship slot at FRIN+1 is reserved for the
                        \ sun or space station (we only ever have one of these
                        \ in our local bubble of space). If FRIN+1 is #SST (8)
                        \ then we show the space station, otherwise it is 129
                        \ and we show the sun
                        \
                        \ Ships in our local bubble start at FRIN+2 onwards

.CABTMP                 \ Cabin temperature
                        \
                        \ 30 = cabin temperature in deep space (i.e. one notch
                        \      on the dashboard bar)
                        \
                        \ We get higher temperatures closer to the sun
                        \
                        \ Shares a location with MANY, but that's OK because
                        \ MANY would contain the number of ships of type 0, but
                        \ isn't used because ship types start at 1

.MANY

 SKIP SST               \ Ship counts by type
                        \
                        \ Contains a count of how many ships there are of each
                        \ type in our local bubble of universe, with the number
                        \ of ships of type X being stored at offset X, so the
                        \ current number of Sidewinders is at MANY+1, the number
                        \ of Mambas is at MANY+2, and so on

.SSPR

 SKIP 14 - SST          \ "Space station present" flag
                        \
                        \ Non-zero if we are inside the space station safe zone
                        \
                        \ 0 if we aren't (in which case we can show the sun)
                        \
                        \ This flag is at MANY+SST, which is no coincidence, as
                        \ MANY+SST is a count of how many space stations there
                        \ are in our local bubble, which is the same as saying
                        \ "space station present"

.ECMP

 SKIP 1                 \ Our E.C.M. status
                        \
                        \ 0 is off, non-zero is on

.MJ

 SKIP 1                 \ Are we in witchspace (i.e. we mis-jumped)?
                        \
                        \ 0 = no, &FF = yes

.LAS2

 SKIP 1                 \ Laser power for the current laser
                        \
                        \ Bits 0-6 of the laser power of the current space view
                        \ (bit 7 doesn't denote laser power, just whether or
                        \ not the laser pulses)

.MSAR

 SKIP 1                 \ Leftmost missile is currently armed and seeking a
                        \ target
                        \
                        \ 0 = missile is not looking for a target, or it already
                        \     has a target lock (indicator is not yellow/white)
                        \
                        \ non-zero = missile is currently looking for a target
                        \            (indicator is yellow/white)

.VIEW

 SKIP 1                 \ Current space view
                        \
                        \ 0 = front
                        \ 1 = rear
                        \ 2 = left
                        \ 3 = right

.LASCT

 SKIP 1                 \ Laser pulse count for the current laser
                        \
                        \ Defines the gap between pulses of a pulse laser
                        \
                        \ 0 for beam laser, 10 for pulse laser
                        \
                        \ This gets decremented every vertical sync (in LINSCN),
                        \ and is set to a non-zero value for pulse lasers only.
                        \ The laser only fires when the value of LASCT hits
                        \ zero, so for pulse lasers with a value of 10, that
                        \ means it fires once every 10 vertical syncs (or 5
                        \ times a second). In comparison, beam lasers fire
                        \ continuously

.GNTMP

 SKIP 1                 \ Laser ("gun") temperature
                        \
                        \ If the laser temperature exceeds 242 then the laser
                        \ overheats and cannot be fired again until it has
                        \ cooled down

.HFX

 SKIP 1                 \ Toggle hyperspace colour effects
                        \
                        \ 0 = no effects, non-zero = hyperspace effects
                        \
                        \ When this is set to 1, the mode 4 screen that makes
                        \ up the top part of the display is switched to mode 5
                        \ (the same as the dashboard), which has the effect of
                        \ blurring and colouring the hyperspace rings. The code
                        \ to do this is in the LINSCN routine, where HFX is
                        \ checked and the mode 4 code is skipped if it is 1,
                        \ thus leaving the top part of the screen in mode 5

.EV

 SKIP 1                 \ Extra vessels spawning counter
                        \
                        \ This counter is set to 0 on arrival in a system and
                        \ following an in-system jump, and is bumped up when we
                        \ spawn bounty hunters or pirates ("extra vessels")
                        \
                        \ It decreases by 1 each time we consider spawning more
                        \ "extra vessels" the main game loop (TT100 part 4), so
                        \ increasing the value of EV delays their spawning
                        \
                        \ In other words, this counter stops bounty hunters and
                        \ pirates from continually appearing, and instead adds
                        \ a delay between spawnings

.DLY

 SKIP 1                 \ In-flight message delay
                        \
                        \ This counter is used to keep an in-flight message up
                        \ for a specified time before it gets removed. The value
                        \ in DLY is decremented each time we enter the main
                        \ loop at TT100

.de

 SKIP 1                 \ Equipment destruction flag
                        \
                        \ Bit 1 set means " DESTROYED" is appended to the
                        \ in-flight message printed by MESS

.LSX

.LSO

 SKIP 192               \ This block is shared by LSX and LSO:
                        \
                        \ LSX is the the line buffer for the sun
                        \
                        \ LSO is the ship lines heap space for the space station
                        \
                        \ This space can be shared as our local bubble of
                        \ universe can support either the sun or a space
                        \ station, but not both
.LSX2

 SKIP 78                \

.LSY2

 SKIP 78                \

.SY

 SKIP NOST + 1          \

.SYL

 SKIP NOST + 1          \

.SZ

 SKIP NOST + 1          \

.SZL

 SKIP NOST + 1          \

.XSAV2

 SKIP 1                 \ Temporary storage for the X register (e.g. used in
                        \ TT27 to store X while printing is performed)

.YSAV2

 SKIP 1                 \ Temporary storage for the Y register (e.g. used in
                        \ TT27 to store X while printing is performed)

.MCH

 SKIP 1                 \ The text token of the in-flight message that is
                        \ currently being shown, and which will be removed by
                        \ me2 when the counter in DLY reaches zero

.FSH

 SKIP 1                 \ Forward shield status
                        \
                        \ 0 = empty, &FF = full

.ASH

 SKIP 1                 \ Aft shield status
                        \
                        \ 0 = empty, &FF = full

.ENERGY

 SKIP 1                 \ Energy bank status
                        \
                        \ 0 = empty, &FF = full

.LASX

 SKIP 1                 \

.LASY

 SKIP 1                 \

.COMX

 SKIP 1                 \

.COMY

 SKIP 1                 \

.QQ24

 SKIP 1                 \ Temporary storage (e.g. used in TT151 for the current
                        \ market item's price)

.QQ25

 SKIP 1                 \ Temporary storage (e.g. used in TT151 for the current
                        \ market item's availability)

.QQ28

 SKIP 1                 \ Temporary storage (e.g. used in var for the economy
                        \ byte of the current system)

.QQ29

 SKIP 1                 \ Temporary storage (e.g. used in TT219 for the current
                        \ market item)

.gov

 SKIP 1                 \ Government of current system

.tek

 SKIP 1                 \ Tech level of current system (0-14)

.SLSP

 SKIP 2                 \ Points to the bottom of the ship lines heap space,
                        \ which is a descending block that starts at WP and
                        \ descends down to SLSP, and which can be extended
                        \ downwards by lowering SLSP if more heap space is
                        \ required

.XX24

 SKIP 1                 \

.ALTIT

 SKIP 1                 \ Our altitude above the planet
                        \
                        \ &FF = maximum
                        \
                        \ Otherwise this contains our altitude as the square
                        \ root of x_hi^2 + y_hi^2 + z_hi^2 - 6^2, where our
                        \ ship is at the origin, the centre of the planet is at
                        \ (x_hi, y_hi, z_hi), and the radius of the planet is 6
                        \
                        \ If this value drops to zero, we have crashed

.QQ2

 SKIP 6                 \ Contains the three 16-bit seeds for the current system
                        \ (see QQ15 above for details of how the three seeds are
                        \ stored in memory)

.QQ3

 SKIP 1                 \ Selected system's economy (0-7)

.QQ4

 SKIP 1                 \ Selected system's government (0-7)

.QQ5

 SKIP 1                 \ Selected system's tech level (0-14)

.QQ6

 SKIP 2                 \ Selected system's population * 10 in billions (1-71)

.QQ7

 SKIP 2                 \ Selected system's productivity in M CR (96-62480)

.QQ8

 SKIP 2                 \ Distance to the selected system * 10 in light years,
                        \ stored as a 16-bit number
                        \
                        \ Will be 0 if this is the current system
                        \
                        \ The galaxy chart is 102.4 light years wide and 51.2
                        \ light years tall (see the intra-system distance
                        \ calculations in TT111 for details), which would be
                        \ 1024 x 512 in terms of QQ8

.QQ9

 SKIP 1                 \ The galactic x-coordinate of the crosshairs in the
                        \ galaxy chart (and, most of the time, the selected
                        \ system's galactic x-coordinate)

.QQ10

 SKIP 1                 \ The galactic y-coordinate of the crosshairs in the
                        \ galaxy chart (and, most of the time, the selected
                        \ system's galactic y-coordinate)

.NOSTM

 SKIP 1                 \ Number of stardust particles

PRINT "WP workspace from  ", ~WP," to ", ~P%

\ ******************************************************************************
\
\ ELITE A
\
\ Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
\
\ The main game code (ELITE A through G, plus the ship data) is loaded at &1128
\ and is moved down to &0F40 as part of elite-loader.asm.
\
\ ******************************************************************************

CODE% = &0F40
LOAD% = &1128

ORG CODE%

LOAD_A% = LOAD%

.S%

 EQUW TT170             \ Entry point for Elite game; once the main code has
                        \ been loaded, decrypted and moved to the right place
                        \ by elite-loader.asm, the game is started by a
                        \ JMP (S%) instruction, which jumps to the main entry
                        \ point TT170 via this location

 EQUW TT26              \ WRCHV is set to point here by elite-loader.asm

 EQUW IRQ1              \ IRQ1V is set to point here by elite-loader.asm

 EQUW BR1               \ BRKV is set to point here by elite-loader.asm

.COMC

 EQUB 0                 \ Compass colour
                        \
                        \ &F0 = in front, &FF = behind

.DNOIZ

 EQUB 0                 \ Sound on/off configuration setting
                        \
                        \ 0 = on (default), &10 = off
                        \
                        \ Toggled by pressing "S" when paused, see DK4

.DAMP

 EQUB 0                 \ Keyboard damping configuration setting
                        \
                        \ 0 = enabled (default), &FF = disabled
                        \
                        \ Toggled by pressing Caps Lock when paused, see DKS3

.DJD

 EQUB 0                 \ Keyboard auto-recentre configuration setting
                        \
                        \ 0 = enabled (default), &FF = disabled
                        \
                        \ Toggled by pressing "A" when paused, see DKS3

.PATG

 EQUB 0                 \ Configuration setting to show author names on start-up
                        \ screen and enable manual hyperspace mis-jumps
                        \
                        \ 0 = off (default), &FF = on
                        \
                        \ Toggled by pressing "X" when paused, see DKS3
                        \
                        \ This needs to be turned on for manual mis-jumps to be
                        \ possible. To to do a manual mis-jump, first toggle the
                        \ author display by pausing the game (Copy) and pressing
                        \ X, and during the next hyperspace, hold down CTRL to
                        \ force a mis-jump; see routine ee5 for the "AND PATG"
                        \ instruction that implements this

.FLH

 EQUB 0                 \ Flashing console bars configuration setting
                        \
                        \ 0 = static (default), &FF = flashing
                        \
                        \ Toggled by pressing "F" when paused, see DKS3

.JSTGY

 EQUB 0                 \ Reverse joystick Y channel configuration setting
                        \
                        \ 0 = standard (default), &FF = reversed
                        \
                        \ Toggled by pressing "Y" when paused, see DKS3

.JSTE

 EQUB 0                 \ Reverse both joystick channels configuration setting
                        \
                        \ 0 = standard (default), &FF = reversed
                        \
                        \ Toggled by pressing "J" when paused, see DKS3

.JSTK

 EQUB 0                 \ Keyboard or joystick configuration setting
                        \
                        \ 0 = keyboard (default), &FF = joystick
                        \
                        \ Toggled by pressing "K" when paused, see DKS3

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 1 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Seed the random number generator
\
\ ******************************************************************************

.M%
{
 LDA K%                 \ Seed the random number generator with whatever is in
 STA RAND               \ location K%, which will be fairly random as this is
                        \ where we store the ship data blocks

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 2 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Calculate the alpha and beta angles from the current roll and pitch
\
\ Here we take the current rate of roll and pitch, as set by the joystick or
\ keyboard, and convert them into alpha and beta angles that we can use in the
\ matrix functions to rotate space around our ship. The alpha angle covers
\ roll, while the beta angle covers pitch (there is no yaw in this version of
\ Elite). The angles are in radians, which allows us to use the small angle
\ approximation when moving objects in the sky (see the MVEIT routine for more
\ on this). Also, the signs of the two angles are stored separately, in both
\ the sign and the flipped sign, as this makes calculations easier.
\
\ ******************************************************************************

 LDX JSTX               \ Set X to the current rate of roll in JSTX, and
 JSR cntr               \ apply keyboard damping twice (if enabled) so the roll
 JSR cntr               \ rate in X creeps towards the centre by 2

                        \ The roll rate increases if we press ">" (and the RL
                        \ indicator on the dashboard goes to the right). This
                        \ rolls our ship to the right (clockwise), but we
                        \ actually implement this by rolling everything else
                        \ to the left (anticlockwise), so a positive roll rate
                        \ in JSTX translates to a negative alpha angle

 TXA                    \ Set A and Y to the roll rate but with the sign
 EOR #%10000000         \ bit flipped (i.e. the sign of alpha)
 TAY

 AND #%10000000         \ Extract the flipped sign of the roll rate and store
 STA ALP2               \ in ALP2 (so ALP2 contains the sign of the alpha angle)

 STX JSTX               \ Update JSTX with the damped value that's still in X

 EOR #%10000000         \ Extract the correct sign of the roll rate and store
 STA ALP2+1             \ in ALP2+1 (so ALP2+1 contains the flipped sign of the
                        \ angle alpha)

 TYA                    \ If the roll rate but with the sign bit flipped is
 BPL P%+7               \ positive (i.e. if the current roll rate is negative),
                        \ skip the following 3 instructions

 EOR #%11111111         \ The current roll rate is negative, so change the sign
 CLC                    \ of A using two's complement, so A is now -A, or |A|
 ADC #1

 LSR A                  \ Divide the (positive) roll rate in A by 4
 LSR A

 CMP #8                 \ If A >= 8, skip the following two instructions
 BCS P%+4

 LSR A                  \ A < 8, so halve A again and clear the carry flag, so
 CLC                    \ so we can do addition later without the carry flag
                        \ affecting the result

 STA ALP1               \ Store A in ALP1, so:
                        \
                        \   ALP1 = |JSTX| / 8    if |JSTX| <= 32
                        \
                        \   ALP1 = |JSTX| / 4    if |JSTX| > 32
                        \
                        \ So higher roll rates are reduced closer to zero and
                        \ because JSTX is in the range -127 to +127, ALP1 is
                        \ in the range 0 to 31

 ORA ALP2               \ Store A in ALPHA, but with the sign set to ALP2 (so
 STA ALPHA              \ ALPHA has a different sign to the actual roll rate)

 LDX JSTY               \ Set X to the current rate of pitch in JSTY, and
 JSR cntr               \ apply keyboard damping so the pitch rate in X creeps
                        \ towards the centre by 1

 TXA                    \ Set A and Y to the pitch rate but with the sign
 EOR #%10000000         \ flipped
 TAY

 AND #%10000000         \ Extract the flipped sign of the pitch rate into A

 STX JSTY               \ Update JSTY with the damped value that's still in X

 STA BET2+1             \ Store the flipped sign of the pitch rate into BET2+1

 EOR #%10000000         \ Extract the correct sign of the pitch rate and store
 STA BET2               \ in BET2

 TYA                    \ If the pitch rate but with the sign bit flipped is
 BPL P%+4               \ positive (i.e. if the current pitch rate is
                        \ negative), skip the following instruction

 EOR #%11111111         \ The current pitch rate is negative, so flip the bits

 ADC #4                 \ Add 4 to the (positive) pitch rate, so the maximum
                        \ value is now up to 131 (rather than 127)

 LSR A                  \ Divide the (positive) pitch rate in A by 16
 LSR A
 LSR A
 LSR A

 CMP #3                 \ If A >= 3, skip the following instruction
 BCS P%+3

 LSR A                  \ A < 3, so halve A again

 STA BET1               \ Store A in BET1, and because JSTY is in the range -131
                        \ to +131, BET1 is in the range 0 to 8

 ORA BET2               \ Store A in BETA, but with the sign set to BET2 (so
 STA BETA               \ BETA has the same sign as the actual pitch rate)

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 3 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Scan for flight keys and process the results
\
\ Flight keys are logged in the key logger at location KY1 onwards, with a
\ non-zero value in the relevant location indicating a key press. See the KL
\ and KY1 locations for more details.
\
\ The keypresses that are processed are as follows:
\
\   * Space and "?" to speed up and slow down
\   * "U", "T" and "M" for disarming, arming and firing missiles
\   * Tab for firing an energy bomb
\   * Escape for launching an escape pod
\   * "J" for initiating an in-system jump
\   * "E" to deploy E.C.M. anti-missile countermeasures
\   * "C" to use the docking computer
\   * "A" to fire lasers
\
\ ******************************************************************************

 LDA KY2                \ If Space is being pressed, keep going, otherwise jump
 BEQ MA17               \ down to MA17 to skip the following

 LDA DELTA              \ The "go faster" key is being pressed, so first we
 CMP #40                \ fetch the current speed from DELTA into A, and if
 BCS MA17               \ A >= 40, we are already going at full pelt, so jump
                        \ down to MA17 to skip the following

 INC DELTA              \ We can go a bit faster, so increment the speed in
                        \ location DELTA

.MA17

 LDA KY1                \ If "?" is being pressed, keep going, otherwise jump
 BEQ MA4                \ down to MA4 to skip the following

 DEC DELTA              \ The "slow down" key is being pressed, so we decrement
                        \ the current ship speed in DELTA

 BNE MA4                \ If the speed is still greater then zero, jump to MA4

 INC DELTA              \ Otherwise we just braked a little too hard, so bump
                        \ the speed back up to the minimum value of 1

.MA4

 LDA KY15               \ If "U" is being pressed and the number of missiles
 AND NOMSL              \ in NOMSL is non-zero, keep going, otherwise jump down
 BEQ MA20               \ to MA20 to skip the following

 LDY #&EE               \ The "disarm missiles" key is being pressed, so call
 JSR ABORT              \ ABORT to disarm the missile and update the missile
                        \ indicators on the dashboard to green/cyan (Y = &EE)

 LDA #40                \ Call the NOISE routine with A = 40 to make a low,
 JSR NOISE              \ long beep to indicate the missile is now disarmed

.MA31

 LDA #0                 \ Set MSAR to 0 to indicate that no missiles are
 STA MSAR               \ currently armed

.MA20

 LDA MSTG               \ If MSTG is positive (i.e. does not have bit 7 set),
 BPL MA25               \ then it indicates we already have a missile locked on
                        \ a target (in which case MSTG contains the ship number
                        \ of the target), so jump to MA25 to skip targetting (or
                        \ put another way, if MSTG = &FF, which means there is
                        \ no current target lock, keep going)

 LDA KY14               \ If "T" is being pressed, keep going, otherwise jump
 BEQ MA25               \ down to MA25 to skip the following

 LDX NOMSL              \ If the number of missiles in NOMSL is zero, jump down
 BEQ MA25               \ to MA25 to skip the following

 STA MSAR               \ The "target missile" key is being pressed and we have
                        \ at least one missile, so set MSAR = &FF to denote that
                        \ our missile is currently armed (we know A has the
                        \ value &FF, as we just loaded it from MSTG and checked
                        \ that it was negative)

 LDY #&E0               \ Change the leftmost missile indicator to yellow/white
 JSR MSBAR              \ on the missile bar (this changes the leftmost
                        \ indicator because we set X to the number of missiles
                        \ in NOMSL above, and the indicators are numbered from
                        \ right to left, so X is the number of the leftmost
                        \ indicator)

.MA25

 LDA KY16               \ If "M" is being pressed, keep going, otherwise jump
 BEQ MA24               \ down to MA24 to skip the following

 LDA MSTG               \ If MSTG = &FF there is no target lock, so jump to
 BMI MA64               \ MA64 to skip the following (skipping the checks for
                        \ Tab, Escape, "J" and "E")

 JSR FRMIS              \ The "fire missile" key is being pressed and we have
                        \ a missile lock, so call the FRMIS routine to fire
                        \ the missile

.MA24

 LDA KY12               \ If Tab is being pressed, keep going, otherwise jump
 BEQ MA76               \ jump down to MA76 to skip the following

 ASL BOMB               \ The "energy bomb" key is being pressed, so double
                        \ the value in BOMB (so if we have an energy bomb
                        \ fitted, BOMB now contains %11111110, or -2, otherwise
                        \ it still contains 0). The bomb explosion is dealt
                        \ with in the MAL1 routine below - this just registers
                        \ the fact that we've set the bomb ticking

.MA76

 LDA KY13               \ If Escape is being pressed and we have an escape pod
 AND ESCP               \ fitted, keep going, otherwise skip the next
 BEQ P%+5               \ instruction

 JMP ESCAPE             \ The "launch escape pod" button is being pressed and
                        \ we have an escape pod fitted, so jump to ESCAPE to
                        \ launch it

 LDA KY18               \ If "J" is being pressed, keep going, otherwise skip
 BEQ P%+5               \ the next instruction

 JSR WARP               \ Call the WARP routine to do an in-system jump

 LDA KY17               \ If "E" is being pressed and we have an E.C.M. fitted,
 AND ECM                \ keep going, otherwise jump down to MA64 to skip the
 BEQ MA64               \ following

 LDA ECMA               \ If ECMA is non-zero, that means an E.C.M. is already
 BNE MA64               \ operating and is counting down (this can be either
                        \ our E.C.M. or an opponent's), so jump down to MA64 to
                        \ skip the following (as we can't have two E.C.M.s
                        \ operating at the same time)

 DEC ECMP               \ The "E.C.M." button is being pressed and nobody else
                        \ is operating their E.C.M., so decrease the value of
                        \ ECMP to make it non-zero, to denote that our E.C.M.
                        \ is now on

 JSR ECBLB2             \ Call ECBLB2 to light up the E.C.M. indicator bulb on
                        \ the dashboard, set the E.C.M. countdown timer to 32,
                        \ and start making the E.C.M. sound

.MA64

 LDA KY19               \ If "C" is being pressed, we have a docking computer
 AND DKCMP              \ fitted, and we are inside the space station's safe
 AND SSPR               \ zone, keep going, otherwise jump down to MA68 to
 BEQ MA68               \ skip the following

 LDA K%+NI%+32          \ Fetch the AI counter (byte 32) of the second ship
 BMI MA68               \ in the ship data workspace at K%, which is reserved
                        \ for the sun or the space station (in this case it's
                        \ the latter), and if it's negative, meaning the
                        \ station is hostile, jump down to MA68 to skip the
                        \ following (so we can't use the docking computer to
                        \ dock at a station that has turned against us)

 JMP GOIN               \ The "docking computer" button has been pressed and
                        \ we are allowed to dock at the station, so jump to
                        \ GOIN to dock (or "go in")

.MA68

 LDA #0                 \ Set LAS = 0, to switch the laser off while we do the
 STA LAS                \ following logic

 STA DELT4              \ Take the 16-bit value (DELTA 0) - i.e. a two-byte
 LDA DELTA              \ number with DELTA as the high byte and 0 as the low
 LSR A                  \ byte - and divide it by 4, storing the 16-bit result
 ROR DELT4              \ in (DELT4 DELT4+1). This is the same as storing the
 LSR A                  \ current speed * 64 in the 16-bit location DELT4
 ROR DELT4
 STA DELT4+1

 LDA LASCT              \ If LASCT is zero, keep going, otherwise the laser is
 BNE MA3                \ a pulse laser that is between pulses, so jump down to
                        \ MA3 to skip the following

 LDA KY7                \ If "A" is being pressed, keep going, otherwise jump
 BEQ MA3                \ down to MA3 to skip the following

 LDA GNTMP              \ If the laser temperature >= 242 then the laser has
 CMP #242               \ overheated, so jump down to MA3 to skip the following
 BCS MA3

 LDX VIEW               \ If the current space has a laser fitted (i.e. the
 LDA LASER,X            \ laser power for this view is greater than zero),
 BEQ MA3                \ then keep going, otherwise jump down to MA3 to skip
                        \ the following

                        \ If we get here, then the "fire" button is being
                        \ pressed, our laser hasn't overheated and isn't
                        \ already beign fired, and we actually have a laser
                        \ fitted to the current space view, so it's time to hit
                        \ me with those laser beams

 PHA                    \ Store the current view's laser power on the stack

 AND #%01111111         \ Set LAS and LAS2 to bits 0-6 of the laser power
 STA LAS
 STA LAS2

 LDA #0                 \ Call the NOISE routine with A = 0 to make the sound
 JSR NOISE              \ of our laser firing

 JSR LASLI              \ Draw laser lines

 PLA                    \ Restore the current view's laser power into A

 BPL ma1                \ If the laser power has bit 7 set, it's an "always
                        \ on" laser, so keep going, otherwise jump down to ma1
                        \ to skip the following instruction

 LDA #0                 \ This is an "always on" laser (i.e. a beam laser,
                        \ as tape Elite doesn't have military lasers), so
                        \ set A = 0, which will be stored in LASCT to denote
                        \ that this is not a pulsing laser

.ma1

 AND #%11111010         \ LASCT will be set to 0 for beam lasers, and to the
 STA LASCT              \ laser power AND %11111010 for pulse lasers, which
                        \ comes to 10 (as pulse lasers have a power of 15). See
                        \ MA23 below for more on laser pulsing and LASCT

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 4 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Start looping through all the ships in the local bubble, and for each
\     one:
\
\     * Copy the ship's data block from K% to INWK
\
\ Other entry points:
\
\   MAL1                Marks the beginning of the ship analysis loop, so we
\                       can jump back here from part 12 of the main flight loop
\                       to work our way through each ship in the local bubble.
\                       We also jump back here when a ship is removed from the
\                       bubble, so we can continue processing from the next ship
\
\ ******************************************************************************

.MA3

 LDX #0                 \ We're about to work our way through all the ships in
                        \ our little bubble of universe, so set a counter in X,
                        \ starting from 0, to refer to each ship slot in turn

.^MAL1

 STX XSAV               \ Store the slot number in XSAV

 LDA FRIN,X             \ Fetch the contents of this slot into A. If it is 0
 BNE P%+5               \ then this slot is empty and we have no more ships to
 JMP MA18               \ process, so jump tp MA18 below, otherwise A contains
                        \ the type of ship in this slot, so skip the JMP MA18
                        \ and keep going

 STA TYPE               \ Store the ship type in TYPE

 JSR GINF               \ Get the address of the data block for ship slot X
                        \ and store it in INF

                        \ Next we want to copy the ship data from INF to the
                        \ local workspace at INWK, so we can process it

 LDY #NI%-1             \ There are NI% bytes in the INWK workspace, so set a
                        \ counter in Y so we can loop through them

.MAL2

 LDA (INF),Y            \ Load the Y-th byte of INF and store it in the Y-th
 STA INWK,Y             \ byte of INWK

 DEY                    \ Decrement the loop counter

 BPL MAL2               \ Loop back for the next byte, ending when we have
                        \ copied the last byte from INF to INWK

 LDA TYPE               \ If the ship type is negative then this indicates a
 BMI MA21               \ planet or sun, so jump down to MA21, as the next
                        \ section sets up a ship data block, which doesn't
                        \ apply to planets and suns

 ASL A                  \ Set Y = ship type * 2
 TAY

 LDA XX21-2,Y           \ The ship blueprints at XX21 start with a lookup
 STA XX0                \ table that points to the individual ship blueprints,
                        \ so this fetches the low byte of this particular ship
                        \ type's blueprint and stores it in XX0

 LDA XX21-1,Y           \ Fetch the high byte of this particular ship type's
 STA XX0+1              \ blueprint and store it in XX0+1

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 5 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * If an energy bomb has been set off and this ship can be killed, kill it
\       and increase the kill tally
\
\ ******************************************************************************

 LDA BOMB               \ If we set off our energy bomb by pressing Tab (see
 BPL MA21               \ MA24 above), then BOMB is now negative, so this skips
                        \ to MA21 if our energy bomb is not going off

 CPY #2*SST             \ If the ship in Y is the space station, jump to BA21
 BEQ MA21               \ as energy bombs have no effect on space stations

 LDA INWK+31            \ If the ship we are checking has bit 5 set in their
 AND #%00100000         \ INWK+31 byte, then they are already exploding, so
 BNE MA21               \ jump to BA21 as they can't explode more than once

 LDA INWK+31            \ The energy bomb is killing this ship, so set bit 7
 ORA #%10000000         \ of the ship's INWK+31 byte to indicate that it has
 STA INWK+31            \ now been killed

 JSR EXNO2              \ Call EXNO2 to process the fact that we have killed a
                        \ ship (so increase the kill tally, make an explosion
                        \ sound and so on)

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 6 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Move the ship in space and update K% with the new data
\
\ ******************************************************************************

.MA21

 JSR MVEIT              \ Move the ship we are processing in space

 LDY #(NI%-1)           \ Now that we are done processing this ship, we need
                        \ to copy the ship data back from INWK to INF, so set
                        \ a counter in Y so we can loop through the NI% bytes
                        \ once again

.MAL3

 LDA INWK,Y             \ Load the Y-th byte of INWK and store it in the Y-th
 STA (INF),Y            \ byte of INF

 DEY                    \ Decrement the loop counter

 BPL MAL3               \ Loop back for the next byte, ending when we have
                        \ copied the last byte from INWK back to INF

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 7 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Check how close we are to this ship and work out if we are docking,
\       scooping or colliding with it
\
\ ******************************************************************************

 LDA INWK+31            \ Fetch the status of this ship from bits 5 (is ship
 AND #%10100000         \ exploding?) and bit 7 (has ship been killed?) from
                        \ INWK+31 into A

 JSR MAS4               \ Or this value with x_hi, y_hi and z_hi

 BNE MA65               \ If this value is non-zero, then either the ship is
                        \ far away (i.e. has a non-zero high byte in at least
                        \ one of the three axes), or it is already exploding,
                        \ or has been flagged as being killed - in which case
                        \ jump to MA65 to skip the following

 LDA INWK               \ Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
 ORA INWK+3             \ result is set, the ship is still a fair distance
 ORA INWK+6             \ away, so jump to MA65 to skip the following
 BMI MA65

 LDX TYPE               \ If the ship type is negative then this indicates a
 BMI MA65               \ planet or sun, so jump down to MA65 to skip the
                        \ following

 CPX #SST               \ If this ship is the space station, jump to ISDK to
 BEQ ISDK               \ check for docking

 AND #%11000000         \ If bit 6 of (x_lo OR y_lo OR z_lo) is set, then we
 BNE MA65               \ are still a reasonable distance away, so jump to
                        \ MA65 to skip the following

 CPX #MSL               \ If this ship is a missile, jump down to MA65 to skip
 BEQ MA65               \ the following

 CPX #OIL               \ If ship type >= OIL (i.e. it's a cargo canister,
 BCS P%+5               \ Thargon or escape pod), skip the JMP instruction and
 JMP MA58               \ continue on, otherwise jump to MA58 to process a
                        \ collision

 LDA BST                \ If we have fuel scoops fitted then BST will be 127,
                        \ otherwise it will be 0

 AND INWK+5             \ INWK+5 contains the y_sign of this ship, so a -1 here
                        \ means the canister is below us, so this result will
                        \ be negative if the canister is below us and we have a
                        \ fuel scoop fitted

 BPL MA58               \ If the result is positive, then we either have no
                        \ scoop or the canister is above us, and in both cases
                        \ this means we can't scoop the item, so jump to MA58
                        \ to process a collision

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 8 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Process scooping of items
\
\ ******************************************************************************

 LDA #3                 \ Set A to 3 to denote we may be scooping an escape pod

 CPX #TGL               \ If ship type < Thargon, i.e. it's a canister, jump
 BCC oily               \ to oily to scoop the canister

 BNE slvy2              \ If ship type <> Thargon, i.e. it's an escape pod,
                        \ jump to slvy2 with A = 3

 LDA #16                \ Otherwise this is a Thargon, so jump to slvy2 with
 BNE slvy2              \ A = 16 (this BNE is effectively a JMP as A will never
                        \ be zero)

.oily

 JSR DORND              \ Set A and X to random numbers and reduce A to a
 AND #7                 \ random number in the range 0-7

.slvy2                  \ By the time we get here, we are scooping, and A
                        \ contains the type of item we are scooping (a random
                        \ number 0-7 if we are scooping a cargo canister, 3 if
                        \ we are scooping an escape pod, or 16 if we are
                        \ scooping a Thargon). These numbers correspond to the
                        \ relevant market items (see QQ23 for a list), so a
                        \ cargo canister can contain anything from food to
                        \ computers, while escape pods contain slaves, and
                        \ Thargons become alien items when scooped

 STA QQ29               \ Call tnpr with the scooped cargo type stored in QQ29
 LDA #1                 \ and A = 1 to work out whether we have room in the
 JSR tnpr               \ hold for the scooped item (A is preserved by this
                        \ call, and the carry flag contains the result)

 LDY #78                \ This instruction has no effect, so presumably it used
                        \ to do something, and didn't get removed

 BCS MA59               \ If carry is set then we have no room in the hold for
                        \ the scooped item, so jump down to MA59 make a sound
                        \ to indicate failure, and destroy the canister

 LDY QQ29               \ Scooping was successful, so set Y to the type of
                        \ item we just scooped

 ADC QQ20,Y             \ Add A to the number of items of type Y in the cargo
 STA QQ20,Y             \ hold, as we just successfully scooped A units of Y

 TYA                    \ Print recursive token 48 + A as an in-flight token,
 ADC #208               \ which will be in the range 48 ("FOOD") to 64 ("ALIEN
 JSR MESS               \ ITEMS"), so this prints the scooped item's name

 JMP MA60               \ We are done scooping, so jump down to MA60 to
                        \ set the kill flag on the canister, as it no longer
                        \ exists in the local bubble

.MA65

 JMP MA26               \ If we get here, then the ship we are processing was
                        \ too far away to be scooped, docked or collided with,
                        \ so jump to MA26 to skip over the collision routines
                        \ and to move on to missile targeting

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 9 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Process docking with space station
\
\ Other entry points:
\
\   GOIN                We jump here from part 3 of the main flight loop if the
\                       docking computer is activated by pressing "C"
\
\ ******************************************************************************
\
\ Deep dive: Docking
\ ------------------
\ The following routine does five tests to confirm whether we are docking
\ safely, as opposed to slamming into the sides of the space station, leaving
\ a trail of sparks and dented pride. They are:
\
\   1. Make sure the station isn't hostile.
\
\   2. Make sure our ship is pointed in the right direction, by checking that
\      our angle of approach is less than 26 degrees off the perfect, head-on
\      approach.
\
\   3. Confirm that we are moving towards the centre of the space station.
\
\   4. Confirm that we are within a small "cone" of safe approach.
\
\   5. Unsure at this point - needs more investigation.
\
\ Here's a further look at the more complicated of these tests.
\
\ 2. Check the angle of approach
\ ------------------------------
\ The space station's ship data is in INWK. The nosev vector in INWK+9 to
\ INWK+14 is the station's forward-facing normal vector, and it's perpendicular
\ to the face containing the slot, pointing straight out into space out of the
\ docking slot. You can see this in the diagram on the left, which is a side-on
\ view of the station, with us approaching at a jaunty angle from the top-right,
\ with the docking slot on the top face of the station. You can imagine this
\ vector as a big stick, sticking out of the slot.
\
\        nosev
\          ^         ship
\          :       /
\          :      /
\          :     L
\          :    /
\          : t / <--- approach
\          :  /       vector
\          : /
\          :/
\     ____====____
\    /     /\     \
\   |    /    \    |
\   |  /        \  |
\   : . station  . :
\
\ We want to check whether the angle t is too large, because if it is, we are
\ coming in at the wrong angle and will probably bounce off the front of the
\ space station. To find out the value of t, we need to look at the geometry
\ of ths situation.
\
\ The station's nose vector has length 1, because it's a unit vector. We
\ actually store a 1 in a unit vector as &6000, because this means we don't
\ have to deal with fractions. We can also just consider the high byte of
\ this figure, so 1 has a high byte of &60 when we're talking about vectors
\ like the station's nose vector.
\
\ So the nose vector is a big stick, poking out of the slot, with a length of
\ 1 unit (stored as a high byte of &60 internally).
\
\ Now, if that vector was coming perpendicularly out of the screen towards us,
\ we would be on a perfect approach angle, the stick would be poking in our
\ face, and the length of the stick in our direction would be the full length
\ of 1, or &60. However, if our angle of approach is off by a bit, then the
\ nose vector won't be pointing straight at us, and the end of the stick will
\ be further away from us - less "in our face", if you like.
\
\ In other words, the end of the stick is less in our direction, or to put it
\ yet another way, it's not so far towards us along the z-axis, which goes in
\ and out of the screen.
\
\ Or, to put it mathematically, the z-coordinate of the end of the stick, or
\ nosev_z, is smaller when our approach angle is off. The routine below uses
\ this method to see how well we are approaching the slot, by comparing nosev_z
\ with &D6, so what does that mean?
\
\ We can draw a triangle showing this whole stick-slot situation, like this. The
\ left triangle is from the diagram above, while the triangle on the right is
\ the same triangle, rotated slightly to the left:
\
\          ^         ship                 ________  ship
\          :       /                      \       |
\          :      /                        \      |
\          :     L                          \     v
\          :    /                         1  \    | nosev_z
\          : t /                              \ t |
\          :  /                                \  |
\          : /                                  \ |
\          :/                                    \|
\          + station                              + station
\
\ The stick is the left edge of each triangle, poking out of the slot at the
\ bottom, and the ship is at the top, looking down towards the slot. We know
\ that the right-hand edge of the triangle - the adjacent side - has length
\ nosev_z, while the hypotenuse is the length of the space station's vector, 1
\ (stored as &60). So we can do some trigonometry, like this, if we just
\ consider the high bytes of our vectors:
\
\   cos(t) = adjacent / hypotenuse
\          = nosev_z_hi / &60
\
\ so:
\
\   nosev_z_hi = &60 * cos(t)
\
\ We need our approach angle to be off by less than 26 degrees, so this
\ becomes the following, if we round down the result to an integer:
\
\   nosev_z_hi = &60 * cos(26)
\               = &56
\
\ So, we get this:
\
\   The angle of approach is less than 26 degrees if nosev_z_hi >= &56
\
\ There is one final twist, however, because we are approaching the slot head
\ on, the z-zxis from our perspective points into the screen, so that means
\ the station's nose vector is coming out of the screen towards us, so it has
\ a negative z-coordinate. So the station's nose vector in this case is
\ actually in the reverse direction, so we need to reverse the check and set
\ the sign bit, to this:
\
\   The angle of approach is less than 26 degrees if nosev_z_hi <= &D6
\
\ And that's the check we make below to make sure our docking angle is correct.
\
\ 4. Cone of safe approach
\ ------------------------
\ This is similar to the angle-of-approach check, but where check 2 only looked
\ at the orientation of our ship, this check makes sure we are in the right
\ place in space. That place is within a cone that extends out from the slot
\ and into space, and we can check where we are in that cone by checking the
\ angle of the vector between our position and the space station.
\
\ ******************************************************************************

.ISDK

 LDA K%+NI%+32          \ 1. Fetch the AI counter (byte 32) of the second ship
 BMI MA62               \ in the ship data workspace at K%, which is reserved
                        \ for the sun or the space station (in this case it's
                        \ the latter), and if it's negative, meaning the
                        \ station is hostile, jump down to MA62 to fail docking
                        \ (so trying to dock at a station that we have annoyed
                        \ does not end well)

 LDA INWK+14            \ 2. If nosev_z_hi < &D6, jump down to MA62 to fail
 CMP #&D6               \ docking, as the angle of approach is greater than 26
 BCC MA62               \ degrees (see the notes on test 2 above)

 JSR SPS4               \ Call SPS4 to get the vector to the space station
                        \ into XX15

 LDA XX15+2             \ 3. Check the sign of the z-axis (bit 7 of XX15+2) and
 BMI MA62               \ if it is negative, we are facing away from the
                        \ station, so jump to MA62 to fail docking

 CMP #&59               \ 4. If z-axis < &59, jump to MA62 to fail docking
 BCC MA62

 LDA INWK+16            \ 5. If |roofv_x_hi| < &50, jump to MA62 to fail
 AND #%01111111         \ docking
 CMP #&50               \ Is this something to do with matching the slot
 BCC MA62               \ rotation?

.^GOIN                  \ If we arrive here, either the docking computer has
                        \ been activated, or we just docked successfully

 LDA #0                 \ Set the on-screen hyperspace counter to 0
 STA QQ22+1

 LDA #8                 \ This instruction has no effect, so presumably it used
                        \ to do something, and didn't get removed

 JSR LAUN               \ Show the space station launch tunnel

 JSR RES4               \ Reset the shields and energy banks, stardust and INWK
                        \ workspace

 JMP BAY                \ Go to the docking bay (i.e. show the Status Mode
                        \ screen)

.MA62                   \ If we arrive here, docking has just failed

 LDA DELTA              \ If the ship's speed is < 5, jump to MA67 to register
 CMP #5                 \ some damage, but not a huge amount
 BCC MA67

 JMP DEATH              \ Otherwise we have just crashed into the station, so
                        \ process our death

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 10 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Remove scooped item after both successful and failed scoopings
\
\     * Process collisions
\
\ ******************************************************************************

.MA59                   \ If we get here then scooping failed

 JSR EXNO3              \ Make the sound of the cargo canister being destroyed
                        \ and fall through into MA60 to remove the canister
                        \ from our local bubble

.MA60                   \ If we get here then scooping was successful

 ASL INWK+31            \ Set bit 7 of the scooped or destroyed item, to denote
 SEC                    \ that it has been killed and should be removed from
 ROR INWK+31            \ the local bubble

.MA61                   \ This label is not used but is in the original source

 BNE MA26               \ Jump to MA26 to skip over the collision routines and
                        \ to move on to missile targeting (this BNE is
                        \ effectively a JMP as A will never be zero)

.MA67                   \ If we get here then we have collided with something,
                        \ but not fatally

 LDA #1                 \ Set the speed in DELTA to 1 (i.e. a sudden stop)
 STA DELTA
 LDA #5                 \ Set the amount of damage in A to 5 (a small dent) and
 BNE MA63               \ jump down to MA63 to process the damage (this BNE is
                        \ effectively a JMP as A will never be zero)

.MA58                   \ If we get here, we have collided with something in a
                        \ fatal way

 ASL INWK+31            \ Set bit 7 of the ship we just collided with, to
 SEC                    \ denote that it has been killed and should be removed
 ROR INWK+31            \ from the local bubble

 LDA INWK+35            \ Load A with the energy level of the ship we just hit

 SEC                    \ Set the amount of damage in A to 128 + A / 2, so
 ROR A                  \ this is quite a big dent, and colliding with higher
                        \ energy ships will cause more damage

.MA63

 JSR OOPS               \ The amount of damage is in A, so call OOPS to reduce
                        \ our shields, and if the shields are gone, there's a
                        \ a chance of cargo loss or even death

 JSR EXNO3              \ Make the sound of colliding with the other ship and
                        \ fall through into MA26 to try targeting a missile

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 11 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Process missile lock
\
\     * Process our laser firing
\
\ ******************************************************************************

.MA26

 LDA QQ11               \ If this is not a space view, jump to MA15 to skip
 BNE MA15               \ missile and laser locking

 JSR PLUT               \ Call PLUT to update the geometric axes in INWK to
                        \ match the view (forward, rear, left, right)

 JSR HITCH              \ Call HITCH to see if this ship is in the crosshairs,
 BCC MA8                \ in which case carry will be set (so if there is no
                        \ missile or laser lock, we jump to MA8 to skip the
                        \ following)

 LDA MSAR               \ We have missile lock, so check whether the leftmost
 BEQ MA47               \ missile is currently armed, and if not, jump to MA47
                        \ to process laser fire, as we can't lock an unarmed
                        \ missile

 JSR BEEP               \ We have missile lock and an armed missile, so call
                        \ the BEEP subroutine to make a short, high beep

 LDX XSAV               \ Call ABORT2 to store the details of this missile
 LDY #&0E               \ lock, with the targeted ship's slot number in X
 JSR ABORT2             \ (which we stored in XSAV at the start of this ship's
                        \ loop at MAL1), and set the colour of the misile
                        \ indicator to the colour in Y (red = &0E)

.MA47                   \ If we get here then the ship is in our sights, but
                        \ we didn't lock a missile, so let's see if we're
                        \ firing the laser

 LDA LAS                \ If we are firing the laser then LAS will contain the
 BEQ MA8                \ laser power (which we set in MA68 above), so if this
                        \ is zero, jump down to MA8 to skip the following

 LDX #15                \ We are firing our laser and the ship in INWK is in
 JSR EXNO               \ the crosshairs, so call EXNO to make the sound of
                        \ us making a laser strike on another ship

 LDA INWK+35            \ Fetch the hit ship's energy from INWK+35 and subtract
 SEC                    \ our current laser power, and if the result is greater
 SBC LAS                \ than zero, the other ship has survived the hit, so
 BCS MA14               \ jump down to MA14

 LDA TYPE               \ Did we just hit the space station? If so, jump to
 CMP #SST               \ MA14+2 to make the station hostile, skipping the
 BEQ MA14+2             \ following as we can't destroy a space station

 LDA INWK+31            \ Set bit 7 of the enemy ship's INWK+31 flag, to
 ORA #%10000000         \ to indicate that it has been killed
 STA INWK+31

 BCS MA8                \ If the enemy ship type is >= SST (i.e. missile,
                        \ asteroid, canister, Thargon or escape pod) then
                        \ jump down to MA8

 JSR DORND              \ Fetch a random number, and jump to oh if it is
 BPL oh                 \ positive (50% chance)

 LDY #0                 \ Fetch the first byte of the hit ship's blueprint,
 AND (XX0),Y            \ which determines the maximum number of bits of
                        \ debris shown when the ship is destroyed, and AND
                        \ with the random number we just fetched

 STA CNT                \ Store the result in CNT, so CNT contains a random
                        \ number between 0 and the maximum number of bits of
                        \ debris that this ship will release when destroyed

.um

 BEQ oh                 \ We're going to go round a loop using CNT as a counter
                        \ so this checks whether the counter is zero and jumps
                        \ to oh when it gets there (which might be straight
                        \ away)

 LDX #OIL               \ Call SFS1 to spawn a cargo canister from the now
 LDA #0                 \ deceased parent ship, giving the spawned canister an
 JSR SFS1               \ AI flag of 0 (no AI, no E.C.M., non-hostile)

 DEC CNT                \ Decrease the loop counter

 BPL um                 \ Jump back up to um (this BPL is effectively a JMP as
                        \ CNT will never be negative)

.oh

 JSR EXNO2              \ Call EXNO2 to process the fact that we have killed a
                        \ ship (so increase the kill tally, make an explosion
                        \ sound and so on)

.MA14

 STA INWK+35            \ Store the hit ship's updated energy in INWK+35

 LDA TYPE               \ Call ANGRY to make this ship hostile, now that we
 JSR ANGRY              \ have hit it

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 12 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Continue looping through all the ships in the local bubble, and for each
\     one:
\
\     * Draw the ship
\
\     * Process removal of killed ships
\
\   * Loop back up to MAL1 to move onto the next ship in the local bubble
\
\ ******************************************************************************

.MA8

 JSR LL9                \ Call LL9 to draw the ship we're processing on screen

.MA15

 LDY #35                \ Fetch the ship's energy from INWK+35 and copy it to
 LDA INWK+35            \ byte 35 in INF (so the ship's data in K% gets
 STA (INF),Y            \ updated)

 LDA INWK+31            \ If bit 7 of the ship's INWK+31 byte is clear, then
 BPL MAC1               \ the ship hasn't been killed by energy bomb, collision
                        \ or laser fire, so jump to MAC1 to skip the following

 AND #%00100000         \ If bit 5 of the ship's INWK+31 byte is clear then the
 BEQ NBOUN              \ ship is no longer exploding, so jump to NBOUN to skip
                        \ the following

 LDA TYPE               \ If the ship we just destroyed was a cop, keep going,
 CMP #COPS              \ otherwise jump to q2 to skip the following
 BNE q2

 LDA FIST               \ We shot the sheriff, so update our FIST flag
 ORA #64                \ ("fugitive/ innocent status") to at least 64, which
 STA FIST               \ will instantly make us a fugitive

.q2

 LDA DLY                \ If we already have an in-flight message on screen (in
 ORA MJ                 \ which case DLY > 0), or we are in witchspace (in
 BNE KS1S               \ which case MJ > 0), jump to KS1S to skip showing an
                        \ on-screen bounty for this kill

 LDY #10                \ Fetch byte #10 of the ship's blueprint, which is the
 LDA (XX0),Y            \ low byte of the bounty awarded when this ship is
 BEQ KS1S               \ killed (in Cr * 10), and if it's zero jump to KS1S as
                        \ there is no on-screen bounty to display

 TAX                    \ Put the low byte of the bounty into X

 INY                    \ Fetch byte #11 of the ship's blueprint, which is the
 LDA (XX0),Y            \ high byte of the bounty awarded (in Cr * 10), and put
 TAY                    \ it into Y

 JSR MCASH              \ Call MCASH to add (Y X) to the cash pot

 LDA #0                 \ Print control code 0 (current cash, right-aligned to
 JSR MESS               \ width 9, then " CR", newline) as an in-flight message

.KS1S

 JMP KS1                \ Process the killing of this ship (which removes this
                        \ ship from its slot and shuffles all the other ships
                        \ down to close up the gap)

.NBOUN

.MAC1

 LDA TYPE               \ If the ship we are processing is a planet or sun,
 BMI MA27               \ jump to MA27 to skip the following two instructions

 JSR FAROF              \ If the ship we are processing is a long way away (its
 BCC KS1S               \ distance in any one direction is > &E0, jump to KS1S
                        \ to remove the ship from our local bubble, as it's just
                        \ left the building

.MA27

 LDY #31                \ Fetch the ship's explosion/killed state from INWK+31
 LDA INWK+31            \ and copy it to byte 31 in INF (so the ship's data in
 STA (INF),Y            \ K% gets updated)

 LDX XSAV               \ We're done processing this ship, so fetch the ship's
                        \ slot number, which we saved in XSAV back at the start
                        \ of the loop

 INX                    \ Increment the slot number to move on to the next slot

 JMP MAL1               \ And jump back up to the beginning of the loop to get
                        \ the next ship in the local bubble for processing

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 13 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Show energy bomb effect (if applicable)
\
\   * Charge shields and energy banks (every 7 iterations of the main loop)
\
\ ******************************************************************************

.MA18

 LDA BOMB               \ If we set off our energy bomb by pressing Tab (see
 BPL MA77               \ MA24 above), then BOMB is now negative, so this skips
                        \ to MA77 if our energy bomb is not going off

 ASL BOMB               \ We set off our energy bomb, so rotate BOMB to the
                        \ left by one place. BOMB was rotated left once already
                        \ during this iteration of the main loop, back at MA24,
                        \ so if this is the first pass it will already be
                        \ %11111110, and this will shift it to %11111100 - so
                        \ if we set off an energy bomb, it stays activated
                        \ (BOMB > 0) for four iterations of the main loop

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn and the following palette change
                        \ won't kick in while the screen is still refreshing

 LDA #%00110000         \ Set the palette byte at SHEILA+&21 to map logical
 STA SHEILA+&21         \ colour 0 to physical colour 7 (white), but with only
                        \ one mapping (rather than the 7 mappings requires to
                        \ do the mapping properly). This makes the space screen
                        \ flash with black and white stripes. See p.382 of the
                        \ Advanced User Guide for details of why this single
                        \ palette change creates a special effect

.MA77

 LDA MCNT               \ Fetch the main loop counter and look at bits 0-2,
 AND #%00000111         \ jumping to MA22 if they are zero (so the following
 BNE MA22               \ section only runs every 8 iterations of the main loop)

 LDX ENERGY             \ Fetch our ship's energy levels and skip to b if bit 7
 BPL b                  \ is not set, i.e. only charge the shields from the
                        \ energy banks if they are at more than 50% charge

 LDX ASH                \ Call SHD to recharge our aft shield and update the
 JSR SHD                \ shield status in ASH
 STX ASH

 LDX FSH                \ Call SHD to recharge our forward shield and update
 JSR SHD                \ the shield status in FSH
 STX FSH

.b

 SEC                    \ Set A = ENERGY + ENGY + 1, so our ship's energy
 LDA ENGY               \ level goes up by 2 if we have an energy unit fitted,
 ADC ENERGY             \ otherwise it goes up by 1

 BCS P%+5               \ If the value of A did not overflow (the maximum
 STA ENERGY             \ energy level is &FF), then store A in ENERGY

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 14 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Spawn a space station if we are close enough to the planet (every 32
\     iterations of the main loop)
\
\ ******************************************************************************

 LDA MJ                 \ If we are in witchspace, jump down to MA23S to skip
 BNE MA23S              \ the following, as there are no space stations in
                        \ witchspace

 LDA MCNT               \ Fetch the main loop counter and look at bits 0-4,
 AND #%00011111         \ jumping to MA93 if they are zero (so the following
 BNE MA93               \ section only runs every 32 iterations of the main loop)

 LDA SSPR               \ If we are inside the space station safe zone, jump to
 BNE MA23S              \ MA23S to skip the following, as we already have a
                        \ space station and don't need another

 TAY                    \ Set Y = A = 0 (A is 0 as we didn't branch with the
                        \ previous BNE instruction)

 JSR MAS2               \ Call MAS2 to calculate the largest distance to the
 BNE MA23S              \ planet in any of the three axes, and if it's
                        \ non-zero, jump to MA23S to skip the following, as we
                        \ are too far from the planet to bump into a space
                        \ station

                        \ We now want to spawn a space station, so first we
                        \ need to set up a ship data block for the station in
                        \ INWK that we can then pass to NWSPS to add a new
                        \ station to our bubble of universe. We do this by
                        \ copying the planet data block from K% to INWK so we
                        \ can work on it, but we only need the first 29 bytes,
                        \ as we don't need to worry about INWK+29 to INWK+35
                        \ for planets (as they don't have rotation counters,
                        \ AI, explosions, missiles, a ship lines heap or energy
                        \ levels)

 LDX #28                \ So we set a counter in X to copy 29 bytes from K%+0
                        \ to K%+28

.MAL4

 LDA K%,X               \ Load the X-th byte of K% and store in the X-th byte
 STA INWK,X             \ of the INWK workspace

 DEX                    \ Decrement the loop counter

 BPL MAL4               \ Loop back for the next byte until we have copied the
                        \ first 28 bytes of K% to INWK

                        \ We now check the distance from our ship (at the
                        \ origin) towards the planet's surface, by adding the
                        \ planet's nosev vector to the planet's centre at
                        \ (x, y, z) and checking our distance to the end
                        \ point along the relevant axis

 INX                    \ Set X = 0 (as we ended the above loop with X as &FF)

 LDY #9                 \ Call MAS1 with X = 0, Y = 9 to do the following:
 JSR MAS1               \
                        \ (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
                        \
                        \ A = |x_hi|

 BNE MA23S              \ If A > 0, jump to MA23S to skip the following, as we
                        \ are too far from the planet in the x-direction to
                        \ bump into a space station

 LDX #3                 \ Call MAS1 with X = 3, Y = 11 to do the following:
 LDY #11                \
 JSR MAS1               \ (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
                        \
                        \ A = |y_hi|

 BNE MA23S              \ If A > 0, jump to MA23S to skip the following, as we
                        \ are too far from the planet in the y-direction to
                        \ bump into a space station

 LDX #6                 \ Call MAS1 with X = 6, Y = 13 to do the following:
 LDY #13                \
 JSR MAS1               \ (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
                        \
                        \ A = |z_hi|

 BNE MA23S              \ If A > 0, jump to MA23S to skip the following, as we
                        \ are too far from the planet in the z-direction to
                        \ bump into a space station

 LDA #&C0               \ Call FAROF2 to compare x_hi, y_hi and z_hi with &C0,
 JSR FAROF2             \ which will set the C flag if all three are < &C0, or
                        \ clear the C flag if any of them are >= &C0

 BCC MA23S              \ Jump to MA23S if any one of x_hi, y_hi or z_hi are
                        \ >= &C0 (i.e. they must all be < &C0 for us to be near
                        \ enough to the planet to bump into a space station)

 LDA QQ11               \ If the current view is a space view, call WPLS to
 BNE P%+5               \ remove the sun from the screen, as we can't have both
 JSR WPLS               \ the sun and the space station at the same time

 JSR NWSPS              \ Add a new space station to our little bubble of
                        \ universe

.MA23S

 JMP MA23               \ Jump to MA23 to skip the following planet and sun
                        \ altitude checks

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 15 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Altitude check (every 32 iterations of the main loop, on iteration 10
\     of each 32)
\
\   * Sun altitude check and fuel scooping (every 32 iterations of the main
\     loop, on iteration 20 of each 32)
\
\ ******************************************************************************

.MA22

 LDA MJ                 \ If we are in witchspace, jump down to MA23 to skip
 BNE MA23               \ the following, as there are no planets or suns to
                        \ bump into in witchspace

 LDA MCNT               \ Fetch the main loop counter and look at bits 0-4,
 AND #%00011111         \ so this tells us the position of this loop in each
                        \ block of 32 iterations

.MA93

 CMP #10                \ If this is the tenth iteration in this block of 32,
 BNE MA29               \ do the following, otherwise jump to MA29 to skip the
                        \ planet altitude check and move on to the sun distance
                        \ check

 LDA #50                \ If our energy bank status in ENERGY is >= 50, skip
 CMP ENERGY             \ printing the following message (so the message is
 BCC P%+6               \ only shown if our energy is low)

 ASL A                  \ Print recursive token 100 ("ENERGY LOW{beep}") as an
 JSR MESS               \ in-flight message

 LDY #&FF               \ Set our altitude in ALTIT to &FF, the maximum
 STY ALTIT

 INY                    \ Set Y = 0

 JSR m                  \ Call m to calculate the maximum distance to the
                        \ planet in any of the three axes, returned in A

 BNE MA23               \ If A > 0 then we are a fair distance away from the
                        \ planet in at least one axis, so jump to MA23 to skip
                        \ the rest of the altitude check

 JSR MAS3               \ Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
                        \ we now know that A now contains the square of the
                        \ distance between our ship (at the origin) and the
                        \ centre of the planet at (x_hi, y_hi, z_hi)

 BCS MA23               \ If the C flag was set by MAS3, then the result
                        \ overflowed (was greater than &FF) and we are still a
                        \ fair distance from the planet, so jump to MA23 as we
                        \ haven't crashed into the planet

 SBC #36                \ Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2. The radius
                        \ of the planet is defined as 6 units and 6^2 = 36, so
                        \ A now contains the high byte of our altitude above
                        \ the planet surface, squared

 BCC MA28               \ If A < 0 then jump to MA28 as we have crashed into
                        \ the planet

 STA R                  \ We are getting close to the planet, so we need to
 JSR LL5                \ work out how close. We know from the above that A
                        \ contains our altitude squared, so we store A in R
                        \ and call LL5 to calculate:
                        \
                        \   Q = SQRT(R Q) = SQRT(A Q)
                        \
                        \ Interestingly, Q doesn't appear to be set to 0 for
                        \ this calculation, so presumably this doesn't make a
                        \ difference

 LDA Q                  \ Store the result in ALTIT, our altitude
 STA ALTIT

 BNE MA23               \ If our altitude is non-zero then we haven't crashed,
                        \ so jump to MA23 to skip to the next section

.MA28

 JMP DEATH              \ If we get here then we just crashed into the planet
                        \ or got too close to the sun, so call DEATH to start
                        \ the funeral preparations

.MA29

 CMP #20                \ If this is the 20th iteration in this block of 32,
 BNE MA23               \ do the following, otherwise jump to MA23 to skip the
                        \ sun altitude check

 LDA #30                \ Set CABTMP to 30, the cabin temperature in deep space
 STA CABTMP             \ (i.e. one notch on the dashboard bar)

 LDA SSPR               \ If we are inside the space station safe zone, jump to
 BNE MA23               \ MA23 to skip the following, as we can't have both the
                        \ sun and space station at the same time, so we clearly
                        \ can't be flying near the sun

 LDY #NI%               \ Set Y to NI%, which is the offset in K% for the sun's
                        \ data block, as the second block at K% is reserved for
                        \ the sun (or space station)

 JSR MAS2               \ Call MAS2 to calculate the largest distance to the
 BNE MA23               \ sun in any of the three axes, and if it's non-zero,
                        \ jump to MA23 to skip the following, as we are too far
                        \ from the sun for scooping or temperature changes

 JSR MAS3               \ Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
                        \ we now know that A now contains the square of the
                        \ distance between our ship (at the origin) and the
                        \ heart of the sun at (x_hi, y_hi, z_hi)

 EOR #%11111111         \ Invert A, so A is now small if we are far from the
                        \ sun and large if we are close to the sun, in the
                        \ range 0 = far away to &FF = extremely close, ouch,
                        \ hot, hot, hot!

 ADC #30                \ Add the minimum cabin temperature of 30, so we get
                        \ one of the following:
                        \
                        \ If the C flag is clear, A contains the cabin
                        \ temperature, ranging from 30 to 255, that's hotter
                        \ the closer we are to the sun
                        \
                        \ If the C flag is set, the addition has rolled over
                        \ and the cabin temperature is over 255

 STA CABTMP             \ Store the updated cabin temperature

 BCS MA28               \ If the C flag is set then jump to MA28 to die, as
                        \ our temperature is off the scale

 CMP #&E0               \ If the cabin temperature < 224 then jump to MA23 to
 BCC MA23               \ to skip fuel scooping, as we aren't close enough

 LDA BST                \ If we don't have fuel scoops fitted, jump to BA23 to
 BEQ MA23               \ skip fuel scooping, as we can't scoop without fuel
                        \ scoops

 LDA DELT4+1            \ We are now cuccessfully fuel scooping, so it's time
 LSR A                  \ to work out how much fuel we're scooping. Fetch the
                        \ high byte of DELT4, which contains our current speed
                        \ divided by 4, and halve it to get our current speed
                        \ divided by 8 (so it's now a value between 1 and 5, as
                        \ our speed is normally between 1 and 40). This gives
                        \ us the amount of fuel that's being scooped in A, so
                        \ the faster we go, the more fuel we scoop, and because
                        \ the fuel levels are stored as 10 * the fuel in light
                        \ years, that means we just scooped between 0.1 and 0.5
                        \ light years of free fuel

 ADC QQ14               \ Set A = A + the current fuel level * 10 (from QQ14)

 CMP #70                \ If A > 70 then set A = 70 (as 70 is the maximum fuel
 BCC P%+4               \ level, or 7.0 light years)
 LDA #70

 STA QQ14               \ Store the updated fuel level in QQ14

 LDA #160               \ Print recursive token 0 ("FUEL SCOOPS ON") as an
 JSR MESS               \ in-flight message

\ ******************************************************************************
\
\ Subroutine: Main flight loop (Part 16 of 16)
\
\ M% is called as part of the main game loop at TT100, and covers most of the
\ flight-specific aspects of Elite. This section of M% covers the following:
\
\   * Process laser pulsing
\
\   * Process E.C.M. energy drain
\
\   * Jump to the stardust routine if we are in space
\
\   * Return from the main flight loop
\
\ ******************************************************************************

.MA23

 LDA LAS2               \ If the current view has no laser, jump to MA16 to skip
 BEQ MA16               \ the following

 LDA LASCT              \ If LASCT >= 8, jump to MA16 to skip the following, so
 CMP #8                 \ for a pulse laser with a LASCT between 8 and 10, the
 BCS MA16               \ the laser stays on, but for a LASCT of 7 or less it
                        \ gets turned off and stays off until LASCT reaches zero
                        \ and the next pulse can start (if the fire button is
                        \ still being pressed)
                        \
                        \ For pulse lasers, LASCT gets set to 10 in ma1 above,
                        \ and it decrements every vertical sync (50 times a
                        \ second), so this means it pulses five times a second,
                        \ with the laser being on for the first 3/10 of each
                        \ pulse and off for the rest of the pulse
                        \
                        \ If this is a beam laser, LASCT is 0 so we always keep
                        \ going here. This means the laser doesn't pulse, but it
                        \ does get drawn and removed every cycle, in a slightly
                        \ different place each time, so the beams still flicker
                        \ around the screen

 JSR LASLI2             \ Redraw the existing laser lines, which has the effect
                        \ of removing them from the screen

 LDA #0                 \ Set LAS2 to 0 so if this is a pulse laser, it will
 STA LAS2               \ skip over the above until the next pulse (this has no
                        \ effect if this is a beam laser)

.MA16

 LDA ECMP               \ If our E.C.M is not on, skip to MA69, otherwise keep
 BEQ MA69               \ going to drain some energy

 JSR DENGY              \ Call DENGY to deplete our energy banks by 1

 BEQ MA70               \ If we have no energy left, jump to MA70 to turn our
                        \ E.C.M. off

.MA69

 LDA ECMA               \ If an E.C.M is going off (our's or an opponent's) then
 BEQ MA66               \ keep going, otherwise skip to MA66

 DEC ECMA               \ Decrement the E.C.M. countdown timer, and if it has
 BNE MA66               \ reached zero, keep going, otherwise skip to MA66

.MA70

 JSR ECMOF              \ If we get here then either we have either run out of
                        \ energy, or the E.C.M. timer has run down, so switch
                        \ off the E.C.M.

.MA66

 LDA QQ11               \ If this is not a space view (i.e. QQ11 is non-zero)
 BNE MA9                \ then jump to MA9 to return from the main flight loop
                        \ (as MA9 is an RTS)

 JMP STARS              \ This is a space view, so jump to the STARS routine to
                        \ process the stardust, and return from the main flight
                        \ loop using a tail call
}

\ ******************************************************************************
\
\ Subroutine: MAS1
\
\ Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
\ an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
\ coordinate. The axes used in each side of the addition are specified by the
\ arguments X and Y.
\
\ In the comments below, we document the routine as if we are doing the
\ following, i.e. if X = 0 and Y = 11:
\
\   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
\
\ as that way the variable names in the comments contain "x" and "y" to match
\ the registers that specify the vector axis to use.
\
\ Arguments:
\
\   X                   The coordinate to add, as follows:
\
\                         * If X = 0, add (x_sign x_hi x_lo)
\                         * If X = 3, add (y_sign y_hi y_lo)
\                         * If X = 6, add (z_sign z_hi z_lo)
\
\   Y                   The vector to add, as follows:
\
\                         * If Y = 9,  add (nosev_x_hi nosev_x_lo)
\                         * If Y = 11, add (nosev_y_hi nosev_y_lo)
\                         * If Y = 13, add (nosev_z_hi nosev_z_lo)
\
\ Returns:
\
\   A                   The high byte of the result with the sign cleared (e.g.
\                       |x_hi| if X = 0, etc.)
\
\ Other entry points:
\
\   MA9                 Contains an RTS
\
\ ******************************************************************************

.MAS1
{
 LDA INWK,Y             \ Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
 ASL A
 STA K+1
 LDA INWK+1,Y
 ROL A
 STA K+2

 LDA #0                 \ Set K+3 bit 7 to the carry flag, so the sign bit
 ROR A                  \ of the above result goes into K+3
 STA K+3

 JSR MVT3               \ Add (x_sign x_hi x_lo) to K(3 2 1)

 STA INWK+2,X           \ Store the sign of the result in x_sign

 LDY K+1                \ Store K(2 1) in (x_hi x_lo)
 STY INWK,X
 LDY K+2
 STY INWK+1,X

 AND #%01111111         \ Set A to the sign byte with the sign cleared

.^MA9

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: m
\
\ Given a value in Y that points to the start of a ship data block as an offset
\ from K%, calculate the following:
\
\   A = x_sign OR y_sign OR z_sign
\
\ and clear the sign bit of the result. The K% workspace contains the ship data
\ blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
\ K% contains NI% bytes).
\
\ The result effectively contains a maximum cap of the three values (though it
\ might not be one of the three input values - it's just guaranteed to be
\ larger than all of them).
\
\ If Y = 0, then this calculates the maximum distance to the planet in any of
\ the three axes, as K%+2 = x_sign, K%+5 = y_sign and K%+8 = z_sign (the first
\ slot in the K% workspace represents the planet).
\
\ Arguments:
\
\   Y                   The offset from K% for the three values to OR
\
\ Returns:
\
\   A                   K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
\
\ ******************************************************************************

.m
{
 LDA #0                 \ Set A = 0 and fall through into MAS2 to calculate the
                        \ OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y
}

\ ******************************************************************************
\
\ Subroutine: MAS2
\
\ Given a value in Y that points to the start of a ship data block as an offset
\ from K%, calculate the following:
\
\   A = A OR x_sign OR y_sign OR z_sign
\
\ and clear the sign bit of the result. The K% workspace contains the ship data
\ blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
\ K% contains NI% bytes).
\
\ The result effectively contains a maximum cap of the three values (though it
\ might not be one of the three input values - it's just guaranteed to be
\ larger than all of them).
\
\ If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
\ containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
\ K%+8 = z_sign (the first slot in the K% workspace represents the planet).
\
\ Arguments:
\
\   Y                   The offset from K% for the start of the ship data block
\                       to use
\
\ Returns:
\
\   A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
\
\ ******************************************************************************

.MAS2
{
 ORA K%+2,Y             \ Set A = A OR x_sign OR y_sign OR z_sign
 ORA K%+5,Y
 ORA K%+8,Y

 AND #%01111111         \ Clear bit 7 in A

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MAS3
\
\ Given a value in Y that points to the start of a ship data block as an offset
\ from K%, calculate the following:
\
\   A = x_hi^2 + y_hi^2 + z_hi^2
\
\ returning A = &FF if the calculation overflows a one-byte result. The K%
\ workspace contains the ship data blocks, so the offset in Y must be 0 or a
\ multiple of NI% (as each block in K% contains NI% bytes).
\
\ Arguments:
\
\   Y                   The offset from K% for the start of the ship data block
\                       to use
\
\ Returns
\
\   A                   A = x_hi^2 + y_hi^2 + z_hi^2
\
\                       A = &FF if the calculation overflows a one-byte result
\
\ ******************************************************************************

.MAS3
{
 LDA K%+1,Y             \ Set (A P) = x_hi * x_hi
 JSR SQUA2

 STA R                  \ Store A (high byte of result) in R

 LDA K%+4,Y             \ Set (A P) = y_hi * y_hi
 JSR SQUA2

 ADC R                  \ Add A (high byte of second result) to R

 BCS MA30               \ If the addition of the two high bytes caused a carry
                        \ (i.e. they overflowed), jump to MA30 to return A = &FF

 STA R                  \ Store A (sum of the two high bytes) in R

 LDA K%+7,Y             \ Set (A P) = z_hi * z_hi
 JSR SQUA2

 ADC R                  \ Add A (high byte of third result) to R, so R now
                        \ contains the sum of x_hi^2 + y_hi^2 + z_hi^2

 BCC P%+4               \ If there is no carry, skip the following instruction
                        \ to return straight from the subroutine

.MA30

 LDA #&FF               \ The calculation has overflowed, so set A = &FF

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 1 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Tidy ship slots
\
\ Arguments:
\
\   INWK                The current ship/planet/sun's data block
\
\   XSAV                The slot number of the current ship/planet/sun
\
\   TYPE                The type of the current ship/planet/sun
\
\ ******************************************************************************

.MVEIT
{
 LDA INWK+31            \ If bits 5 or 7 are set, jump to MV30 as the ship is
 AND #%10100000         \ either exploding or has been killed, so we don't need
 BNE MV30               \ to tidy its orientation vectors or apply tactics

 LDA MCNT               \ Fetch the main loop counter

 EOR XSAV               \ Fetch the slot number of the ship we are moving, EOR
 AND #15                \ with the loop counter and apply mod 15 to the result.
 BNE MV3                \ The result will be zero when "counter mod 15" matches
                        \ the slot number, so this makes sure we call TIDY 13
                        \ times every 16 main loop iteration, like this:
                        \
                        \   Iteration 0, tidy the ship in slot 0
                        \   Iteration 1, tidy the ship in slot 1
                        \   Iteration 2, tidy the ship in slot 2
                        \     ...
                        \   Iteration 11, tidy the ship in slot 11
                        \   Iteration 12, tidy the ship in slot 12
                        \   Iteration 13, do nothing
                        \   Iteration 14, do nothing
                        \   Iteration 15, do nothing
                        \   Iteration 16, tidy the ship in slot 0
                        \     ...
                        \
                        \ and so on

 JSR TIDY               \ Call TIDY to tidy up the orientation vectors, to
                        \ prevent the ship from getting elongated and out of
                        \ shape due to the imprecise nature of trigonometry
                        \ in assembly language

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 2 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Apply tactics to ships with AI enabled
\
\   * Remove the ship from the scanner, so we can move it
\
\ ******************************************************************************

.MV3

 LDX TYPE               \ If the type of the ship we are moving is positive,
 BPL P%+5               \ i.e. it is not a planet (types 128 and 130) or sun
                        \ (type 129), then skip the following instruction

 JMP MV40               \ This item is the planet or sun, so jump to MV40 to
                        \ move it, which ends by jumping back into this routine
                        \ at MV45 (after all the rotation, tactics and scanner
                        \ code, which we don't need to apply to planets or suns)

 LDA INWK+32            \ Fetch the ship's INWK+32 byte (AI flag) into A

 BPL MV30               \ If bit 7 of the AI flag is clear, then if this is a
                        \ ship or missile it is dumb and has no AI, and if this
                        \ is the space station it is not hostile, so in both
                        \ cases skip the following as it has no tactics

 CPX #MSL               \ If the ship is a missile, skip straight to MV26 to
 BEQ MV26               \ call the TACTICS routine, as we do this every
                        \ iteration of the main loop for missiles only

 LDA MCNT               \ Fetch the main loop counter

 EOR XSAV               \ Fetch the slot number of the ship we are moving, EOR
 AND #7                 \ with the loop counter and apply mod 7 to the result.
 BNE MV30               \ The result will be zero when "counter mod 7" matches
                        \ the slot number mod 7, so this makes sure we call
                        \ TACTICS 13 times every 8 main loop iteration, like
                        \ this:
                        \
                        \   Iteration 0, apply tactics to slots 0 and 8
                        \   Iteration 1, apply tactics to slots 1 and 9
                        \   Iteration 2, apply tactics to slots 2 and 10
                        \   Iteration 3, apply tactics to slots 3 and 11
                        \   Iteration 4, apply tactics to slots 4 and 12
                        \   Iteration 5, apply tactics to slot 5
                        \   Iteration 6, apply tactics to slot 6
                        \   Iteration 7, apply tactics to slot 7
                        \   Iteration 8, apply tactics to slots 0 and 8
                        \     ...
                        \
                        \ and so on

.MV26

 JSR TACTICS            \ Call TACTICS to apply AI tactics to this ship

.MV30

 JSR SCAN               \ Draw the ship on the scanner, which has the effect of
                        \ removing it, as it's already at this point and hasn't
                        \ yet moved

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 3 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Move the ship forward (along the vector pointing in the direction of
\     travel) according to its speed:
\
\     (x, y, z) += nosev_hi * speed / 64
\
\ ******************************************************************************

 LDA INWK+27            \ Set Q = the ship's speed (INWK+27) * 4
 ASL A
 ASL A
 STA Q

 LDA INWK+10            \ Set A = |nosev_x_hi|
 AND #%01111111

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |nosev_x_hi| * speed / 64

 LDA INWK+10            \ If INWK+10 (nosev_x_hi) is positive, then:
 LDX #0                 \
 JSR MVT1-2             \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
                        \
                        \ If INWK+10 (nosev_x_hi) is negative, then:
                        \
                        \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
                        \
                        \ So in effect, this does:
                        \
                        \   (x_sign x_hi x_lo) += nosev_x_hi * speed / 64

 LDA INWK+12            \ Set A = |nosev_y_hi|
 AND #%01111111

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |nosev_y_hi| * speed / 64

 LDA INWK+12            \ If INWK+12 (nosev_y_hi) is positive, then:
 LDX #3                 \
 JSR MVT1-2             \   (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
                        \
                        \ If INWK+12 (nosev_y_hi) is negative, then:
                        \
                        \   (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
                        \
                        \ So in effect, this does:
                        \
                        \   (y_sign y_hi y_lo) += nosev_y_hi * speed / 64

 LDA INWK+14            \ Set A = |nosev_z_hi|
 AND #%01111111

 JSR FMLTU              \ Set R = A * Q / 256
 STA R                  \       = |nosev_z_hi| * speed / 64

 LDA INWK+14            \ If INWK+14 (nosev_y_hi) is positive, then:
 LDX #6                 \
 JSR MVT1-2             \   (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
                        \
                        \ If INWK+14 (nosev_z_hi) is negative, then:
                        \
                        \   (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
                        \
                        \ So in effect, this does:
                        \
                        \   (z_sign z_hi z_lo) += nosev_z_hi * speed / 64

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 4 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Apply acceleration to the ship's speed (if acceleration is non-zero),
\     and then zero the acceleration as it's a one-off change
\
\ ******************************************************************************

 LDA INWK+27            \ Set A = the ship's speed (INWK+24) + the ship's
 CLC                    \ acceleration (INWK+28)
 ADC INWK+28

 BPL P%+4               \ If the result is positive, skip the following
                        \ instruction

 LDA #0                 \ Set A to 0 to stop the speed from going negative

 LDY #15                \ Fetch byte #15 from the ship's blueprint, which
                        \ contains the ship's maximum speed

 CMP (XX0),Y            \ If A < the ship's maximum speed, skip the following
 BCC P%+4               \ instruction

 LDA (XX0),Y            \ Set A to the ship's maximum speed

 STA INWK+27            \ We have now calculated the new ship's speed after
                        \ accelerating and keeping the speed within the ship's
                        \ limits, so store the updated speed in INWK+27

 LDA #0                 \ We have added the ship's acceleration, so we now set
 STA INWK+28            \ it back to 0 in INWK+28, as it's a one-off change

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 5 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Rotate the ship's location in space by the amount of pitch and roll of
\     our ship. See below for a deeper explanation of this routine
\
\ ******************************************************************************
\
\ Deep dive: Rotating the universe
\ --------------------------------
\ When we rotate our ship with the keyboard or joystick, we actually just rotate
\ the whole universe around our Cobra, as everything is drawn from the
\ perspective of our cockpit. This routine therefore applies the rotation
\ equations, which are described in MVS4, to the (x, y, z) coordinate of the
\ ship we are processing, so the ship moves as we pitch and roll. Specifically,
\ the calculation is as follows:
\
\   x -> x + alpha * (y - alpha * x - beta * z)
\   y -> y - alpha * x - beta * z
\   z -> z + beta * (y - alpha * x)
\
\ which we implement like this:
\
\   1. K2 = y - alpha * x
\   2. z = z + beta * K2        z = z + beta * (y - alpha * x)
\   3. y = K2 - beta * z        y = y - alpha * x - beta * z
\   4. x = x + alpha * y        x = x + alpha * y
\
\ We also discard the low bytes from the angle multiplications, so all of the
\ above multiplications get divided by 256. This effectively converts the values
\ of alpha and beta from their stored value ranges of 0 to 31 and 0 to 8 in
\ ALP1 and BET1 into the ranges 0 to 0.125 and 0 to 0.03125. These figures work
\ well as small angles in radians, which is why we can apply the small angle
\ approximation to them above.
\
\ ******************************************************************************

 LDX ALP1               \ Fetch the magnitude of the current roll into X, so
                        \ if the roll angle is alpha, X contains |alpha|

 LDA INWK               \ Set P = ~x_lo (i.e. with all its bits flipped) so that
 EOR #%11111111         \ we can pass x_lo to MLTU2 below)
 STA P

 LDA INWK+1             \ Set A = x_hi

 JSR MLTU2-2            \ Set (A P+1 P) = (A ~P) * X
                        \               = (x_hi x_lo) * alpha

 STA P+2                \ Store the high byte of the result in P+2, so we now
                        \ have:
                        \
                        \ P(2 1 0) = (x_hi x_lo) * alpha

 LDA ALP2+1             \ Fetch the flipped sign of the current roll angle alpha
 EOR INWK+2             \ from ALP2+1 and EOR with INWK+2 (x_sign), so if the
                        \ flipped roll angle and x_sign have the same sign, A
                        \ will be positive, else it will be negative. So A will
                        \ contain the sign bit of x_sign * flipped alpha sign,
                        \ which is the opposite to the sign of the above result,
                        \ so we now have:
                        \
                        \ (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256

 LDX #3                 \ Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
 JSR MVT6               \                 = y - x * alpha / 256

 STA K2+3               \ Set K2(3) = A = the sign of the result

 LDA P+1                \ Set K2(1) = P+1, the low byte of the result
 STA K2+1

 EOR #%11111111         \ Set P = ~K2+1 (i.e. with all its bits flipped) so
 STA P                  \ that we can pass K2+1 to MLTU2 below)

 LDA P+2                \ Set K2(2) = A = P+2
 STA K2+2

                        \ So we now have result 1 above:
                        \
                        \ K2(3 2 1) = (A P+2 P+1)
                        \           = y - x * alpha / 256

 LDX BET1               \ Fetch the magnitude of the current pitch into X, so
                        \ if the pitch angle is beta, X contains |beta|

 JSR MLTU2-2            \ Set (A P+1 P) = (A ~P) * X
                        \               = K2(2 1) * beta

 STA P+2                \ Store the high byte of the result in P+2, so we now
                        \ have:
                        \
                        \ P(2 1 0) = K2(2 1) * beta

 LDA K2+3               \ Fetch the sign of the above result in K(3 2 1) from
 EOR BET2               \ K2+3 and EOR with BET2, the sign of the current pitch
                        \ rate, so if the pitch and K(3 2 1) have the same sign,
                        \ A will be positive, else it will be negative. So A
                        \ will contain the sign bit of K(3 2 1) * beta, which is
                        \ the same as the sign of the above result, so we now
                        \ have:
                        \
                        \ (A P+2 P+1) = K2(3 2 1) * beta / 256

 LDX #6                 \ Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
 JSR MVT6               \                 = z + K2 * beta / 256

 STA INWK+8             \ Set z_sign = A = the sign of the result

 LDA P+1                \ Set z_lo = P+1, the low byte of the result
 STA INWK+6

 EOR #%11111111         \ Set P = ~z_lo (i.e. with all its bits flipped) so that
 STA P                  \ we can pass z_lo to MLTU2 below)

 LDA P+2                \ Set z_hi = P+2
 STA INWK+7

                        \ So we now have result 2 above:
                        \
                        \ (z_sign z_hi z_lo) = (A P+2 P+1)
                        \                    = z + K2 * beta / 256

 JSR MLTU2              \ MLTU2 doesn't change Q, and Q was set to beta in
                        \ the previous call to MLTU2, so this call does:
                        \
                        \ (A P+1 P) = (A ~P) * Q
                        \           = (z_hi z_lo) * beta

 STA P+2                \ Set P+2 = A = the high byte of the result, so we
                        \ now have:
                        \
                        \ P(2 1 0) = (z_hi z_lo) * beta

 LDA K2+3               \ Set y_sign = K2+3
 STA INWK+5

 EOR BET2               \ EOR y_sign with BET2, the sign of the current pitch
 EOR INWK+8             \ rate, and z_sign. If the result is positive jump to
 BPL MV43               \ MV43, otherwise this means beta * z and y have
                        \ different signs, i.e. P(2 1) and K2(3 2 1) have
                        \ different signs, so we need to add them in order to
                        \ calculate K2(2 1) - P(2 1)

 LDA P+1                \ Set (y_hi y_lo) = K2(2 1) + P(2 1)
 ADC K2+1
 STA INWK+3
 LDA P+2
 ADC K2+2
 STA INWK+4

 JMP MV44               \ Jump to MV44 to continue the calculation

.MV43

 LDA K2+1               \ Reversing the logic above, we need to subtract P(2 1)
 SBC P+1                \ and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
 STA INWK+3             \ sets (y_hi y_lo) = K2(2 1) - P(2 1)
 LDA K2+2
 SBC P+2
 STA INWK+4

 BCS MV44               \ If the above subtraction did not underflow, then
                        \ jump to MV44, otherwise we need to negate the result

 LDA #1                 \ Negate (y_sign y_hi y_lo) using two's complement,
 SBC INWK+3             \ first doing the low bytes:
 STA INWK+3             \
                        \ y_lo = 1 - y_lo

 LDA #0                 \ Then the high bytes:
 SBC INWK+4             \
 STA INWK+4             \ y_hi = 0 - y_hi

 LDA INWK+5             \ And finally flip the sign in y_sign
 EOR #%10000000
 STA INWK+5

.MV44

                        \ So we now have result 3 above:
                        \
                        \ (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
                        \                    = K2 - beta * z

 LDX ALP1               \ Fetch the magnitude of the current roll into X, so
                        \ if the roll angle is alpha, X contains |alpha|

 LDA INWK+3             \ Set P = ~y_lo (i.e. with all its bits flipped) so that
 EOR #&FF               \ we can pass y_lo to MLTU2 below)
 STA P

 LDA INWK+4             \ Set A = y_hi

 JSR MLTU2-2            \ Set (A P+1 P) = (A ~P) * X
                        \               = (y_hi y_lo) * alpha

 STA P+2                \ Store the high byte of the result in P+2, so we now
                        \ have:
                        \
                        \ P(2 1 0) = (y_hi y_lo) * alpha

 LDA ALP2               \ Fetch the correct sign of the current roll angle alpha
 EOR INWK+5             \ from ALP2 and EOR with INWK+5 (y_sign), so if the
                        \ correct roll angle and y_sign have the same sign, A
                        \ will be positive, else it will be negative. So A will
                        \ contain the sign bit of x_sign * correct alpha sign,
                        \ which is the same as the sign of the above result,
                        \ so we now have:
                        \
                        \ (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256

 LDX #0                 \ Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
 JSR MVT6               \                 = x + y * alpha / 256

 STA INWK+2             \ Set x_sign = A = the sign of the result

 LDA P+2                \ Set x_hi = P+2, the high byte of the result
 STA INWK+1

 LDA P+1                \ Set x_lo = P+1, the low byte of the result
 STA INWK

                        \ So we now have result 4 above:
                        \
                        \ x = x + alpha * y
                        \
                        \ and the rotation of (x, y, z) is done

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 6 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Move the ship in space according to our speed (we already moved it
\     according to its own speed in part 3).
\
\ We do this by subtracting our speed (i.e. the distance we travel in this
\ iteration of the loop) from the other ship's z-coordinate. We subtract because
\ they appear to be "moving" in the opposite direction to us, and the whole
\ MVEIT routine is about moving the other ships rather than us (even though we
\ are the one doing the moving).
\
\ ******************************************************************************

.^MV45

 LDA DELTA              \ Set R to our speed in DELTA
 STA R

 LDA #%10000000         \ Set A to zeroes but with bit 7 set, so that (A R) is
                        \ a 16-bit number containing -R, or -speed

 LDX #6                 \ Set X to the z-axis so the call to MVT1 does this:
 JSR MVT1               \
                        \ (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
                        \                    = (z_sign z_hi z_lo) - speed

 LDA TYPE               \ If the ship type is not the sun (129) then skip the
 AND #%10000001         \ next instruction, otherwise return from the subroutine
 CMP #129               \ as we don't need to rotate the sun around its origin.
 BNE P%+3               \ Having both the AND and the CMP is a little odd, as
                        \ the sun is the only ship type with bits 0 and 7 set,
                        \ so the AND has no effect and could be removed

 RTS                    \ Return from the subroutine, as the ship we are moving
                        \ is the sun and doesn't need any of the following

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 7 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * Rotate the ship's orientation vectors according to our pitch and roll
\
\ As with the previous step, this is all about moving the other ships rather
\ than us (even though we are the one doing the moving). So we rotate the
\ current ship's orientation vectors (which defines its orientation in space),
\ by the angles we are "moving" the rest of the sky through (alpha and beta, our
\ roll and pitch), so the ship appears to us to be stationary while we rotate.
\
\ ******************************************************************************

 LDY #9                 \ Apply our pitch and roll rotations to the current
 JSR MVS4               \ ship's nosev vector

 LDY #15                \ Apply our pitch and roll rotations to the current
 JSR MVS4               \ ship's roofv vector

 LDY #21                \ Apply our pitch and roll rotations to the current
 JSR MVS4               \ ship's sidev vector

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 8 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * If the ship we are processing is rolling or pitching itself, rotate it and
\     apply damping if required
\
\ ******************************************************************************

 LDA INWK+30            \ Fetch the ship's pitch counter and extract the sign
 AND #%10000000         \ into RAT2
 STA RAT2

 LDA INWK+30            \ Fetch the ship's pitch counter and extract the value
 AND #%01111111         \ without the sign bit into A

 BEQ MV8                \ If the pitch counter is 0, then jump to MV8 to skip
                        \ the following, as the ship is not pitching

 CMP #%01111111         \ If bits 0-6 are set in the pitch counter (i.e. the
                        \ ship's pitch is not damping down), then the C flag
                        \ will be set by this instruction

 SBC #0                 \ Set A = A - 0 - (1 - C), so if we are damping then we
                        \ reduce A by 1, otherwise it is unchanged

 ORA RAT2               \ Change bit 7 of A to the sign we saved in RAT2, so
                        \ the updated pitch counter in A retains its sign

 STA INWK+30            \ Store the updated pitch counter in INWK+30

 LDX #15                \ Rotate (roofv_x, nosev_x) by a small angle (pitch)
 LDY #9
 JSR MVS5

 LDX #17                \ Rotate (roofv_y, nosev_y) by a small angle (pitch)
 LDY #11
 JSR MVS5

 LDX #19                \ Rotate (roofv_z, nosev_z) by a small angle (pitch)
 LDY #13
 JSR MVS5

.MV8

 LDA INWK+29            \ Fetch the ship's roll counter and extract the sign
 AND #%10000000         \ into RAT2
 STA RAT2

 LDA INWK+29            \ Fetch the ship's roll counter and extract the value
 AND #%01111111         \ without the sign bit into A

 BEQ MV5                \ If the roll counter is 0, then jump to MV5 to skip the
                        \ following, as the ship is not rolling

 CMP #%01111111         \ If bits 0-6 are set in the roll counter (i.e. the
                        \ ship's roll is not damping down), then the C flag
                        \ will be set by this instruction

 SBC #0                 \ Set A = A - 0 - (1 - C), so if we are damping then we
                        \ reduce A by 1, otherwise it is unchanged

 ORA RAT2               \ Change bit 7 of A to the sign we saved in RAT2, so
                        \ the updated roll counter in A retains its sign

 STA INWK+29            \ Store the updated pitch counter in INWK+29

 LDX #15                \ Rotate (roofv_x, sidev_x) by a small angle (roll)
 LDY #21
 JSR MVS5

 LDX #17                \ Rotate (roofv_y, sidev_y) by a small angle (roll)
 LDY #23
 JSR MVS5

 LDX #19                \ Rotate (roofv_z, sidev_z) by a small angle (roll)
 LDY #25
 JSR MVS5

\ ******************************************************************************
\
\ Subroutine: MVEIT (Part 9 of 9)
\
\ Move the current ship, planet or sun in space. This routine has multiple
\ stages. This stage does the following:
\
\   * If the ship is exploding or being removed, hide it on the scanner
\
\   * Otherwise redraw the ship on the scanner, now that it's been moved
\
\ ******************************************************************************

.MV5

 LDA INWK+31            \ Fetch the ship's exploding/killed state from INWK+31

 AND #%10100000         \ If we are exploding or removing this ship then jump to
 BNE MVD1               \ MVD1 to remove it from the scanner permanently

 LDA INWK+31            \ Set bit 4 to keep the ship visible on the scanner
 ORA #%00010000
 STA INWK+31

 JMP SCAN               \ Display the ship on the scanner, returning from the
                        \ subroutine with a tail call

.MVD1

 LDA INWK+31            \ Clear bit 4 to hide the ship on the scanner
 AND #%11101111
 STA INWK+31

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MVT1
\
\ Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
\ Mathematically speaking, this routine translates the ship along a single axis
\ by a signed delta. Taking the example of X = 0, the x-axis, it does the
\ following:
\
\   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
\
\ (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
\ it is always called via MVT-2, which clears A apart from the sign bit. The
\ routine is written to cope with a non-zero delta_hi, so it supports a full
\ 16-bit delta, but it appears that delta_hi is only ever used to carry the
\ sign of the delta.)
\
\ The comments below assume we are adding delta to the x-axis, though the axis
\ is determined by the value of X.
\
\ Arguments:
\
\   (A R)               The signed delta, so A = delta_hi and R = delta_lo
\
\   X                   Determines which coordinate axis of INWK to change:
\
\                         * X = 0 adds the delta to (x_lo, x_hi, x_sign)
\
\                         * X = 3 adds the delta to (y_lo, y_hi, y_sign)
\
\                         * X = 6 adds the delta to (z_lo, z_hi, z_sign)
\
\ Other entry points:
\
\   MVT1-2              Clear bits 0-6 of A before entering MVT1
\
\ ******************************************************************************

{
 AND #%10000000         \ Clear bits 0-6 of A

.^MVT1

 ASL A                  \ Set the C flag to the sign bit of the delta, leaving
                        \ delta_hi << 1 in A

 STA S                  \ Set S = delta_hi << 1
                        \
                        \ This also clears bit 0 of S

 LDA #0                 \ Set T = just the sign bit of delta (in bit 7)
 ROR A
 STA T

 LSR S                  \ Set S = delta_hi >> 1
                        \       = |delta_hi|
                        \
                        \ This also clear the C flag, as we know that bit 0 of
                        \ S was clear before the LSR

 EOR INWK+2,X           \ If T EOR x_sign has bit 7 set, then x_sign and delta
 BMI MV10               \ have different signs, so jump to MV10

                        \ At this point, we know x_sign and delta have the same
                        \ sign, that sign is in T, and S contains |delta_hi|,
                        \ so now we want to do:
                        \
                        \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
                        \
                        \ and then set the sign of the result to the same sign
                        \ as x_sign and delta

 LDA R                  \ First we add the low bytes, so:
 ADC INWK,X             \
 STA INWK,X             \   x_lo = x_lo + R

 LDA S                  \ Then we add the high bytes:
 ADC INWK+1,X           \
 STA INWK+1,X           \   x_hi = x_hi + S

 LDA INWK+2,X           \ And finally we add any carry into x_sign, and if the
 ADC #0                 \ sign of x_sign and delta in T is negative, make sure
 ORA T                  \ the result is negative (by OR'ing with T)
 STA INWK+2,X

 RTS                    \ Return from the subroutine

.MV10                   \ If we get here, we know x_sign and delta have
                        \ different signs, with delta's sign in T, and
                        \ |delta_hi| in S, so now we want to do:
                        \
                        \   (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
                        \
                        \ and then set the sign of the result according to
                        \ the signs of x_sign and delta

 LDA INWK,X             \ First we subtract the low bytes, so:
 SEC                    \
 SBC R                  \   x_lo = x_lo - R
 STA INWK,X

 LDA INWK+1,X           \ Then we subtract the high bytes:
 SBC S                  \
 STA INWK+1,X           \   x_hi = x_hi - S

 LDA INWK+2,X           \ And finally we subtract any borrow from bits 0-6 of
 AND #%01111111         \ x_sign, and give the result the opposite sign bit to T
 SBC #0                 \ (i.e. give it the sign of the original x_sign)
 ORA #%10000000
 EOR T
 STA INWK+2,X

 BCS MV11               \ If the C flag is set by the above SBC, then our sum
                        \ above didn't underflow and is correct - to put it
                        \ another way, (x_sign x_hi x_lo) >= (S R) so the result
                        \ should indeed have the same sign as x_sign, so jump to
                        \ MV11 to return from the subroutine

                        \ Otherwise our subtraction underflowed because
                        \ (x_sign x_hi x_lo) < (S R), so we now need to flip the
                        \ subtraction around by using two's complement to this:
                        \
                        \   (S R) - (x_sign x_hi x_lo)
                        \
                        \ and then we need to give the result the same sign as
                        \ (S R), the delta, as that's the dominant figure in the
                        \ sum

 LDA #1                 \ First we subtract the low bytes, so:
 SBC INWK,X             \
 STA INWK,X             \   x_lo = 1 - x_lo

 LDA #0                 \ Then we subtract the high bytes:
 SBC INWK+1,X           \
 STA INWK+1,X           \   x_high = 0 - x_high

 LDA #0                 \ And then we subtract the sign bytes:
 SBC INWK+2,X           \
                        \   x_sign = 0 - x_sign

 AND #%01111111         \ Finally, we set the sign bit to the sign in T, the
 ORA T                  \ sign of the original delta, as the delta is the
 STA INWK+2,X           \ dominant figure in the sum

.MV11

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MVT3
\
\ Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
\
\   K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
\
\ The INWK coordinate to add to K(3 2 1) is specified by X.
\
\ Arguments:
\
\   X                   The coordinate to add to K(3 2 1), as follows:
\
\                         * If X = 0, add (x_sign x_hi x_lo)
\
\                         * If X = 3, add (y_sign y_hi y_lo)
\
\                         * If X = 6, add (z_sign z_hi z_lo)
\
\ Returns:
\
\   A                   Contains a copy of the high byte of the result, K+3
\
\   X                   X is preserved
\
\ ******************************************************************************

.MVT3
{
 LDA K+3                \ Set S = K+3
 STA S

 AND #%10000000         \ Set T = sign bit of K(3 2 1)
 STA T

 EOR INWK+2,X           \ If x_sign has a different sign to K(3 2 1), jump to
 BMI MV13               \ MV13 to process the addition as a subtraction

 LDA K+1                \ Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
 CLC                    \ starting with the low bytes
 ADC INWK,X
 STA K+1

 LDA K+2                \ Then the middle bytes
 ADC INWK+1,X
 STA K+2

 LDA K+3                \ And finally the high bytes
 ADC INWK+2,X

 AND #%01111111         \ Setting the sign bit of K+3 to T, the original sign
 ORA T                  \ of K(3 2 1)
 STA K+3

 RTS                    \ Return from the subroutine

.MV13

 LDA S                  \ Set S = |K+3| (i.e. K+3 with the sign bit cleared)
 AND #%01111111
 STA S

 LDA INWK,X             \ Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
 SEC                    \ starting with the low bytes
 SBC K+1
 STA K+1

 LDA INWK+1,X           \ Then the middle bytes
 SBC K+2
 STA K+2

 LDA INWK+2,X           \ And finally the high bytes, doing A = |x_sign| - |K+3|
 AND #%01111111         \ and setting the C flag for testing below
 SBC S

 ORA #%10000000         \ Set the sign bit of K+3 to the opposite sign of T,
 EOR T                  \ i.e. the opposite sign to the original K(3 2 1)
 STA K+3

 BCS MV14               \ If the C flag is set, i.e. |x_sign| >= |K+3|, then
                        \ the sign of K(3 2 1). In this case, we want the
                        \ result to have the same sign as the largest argument,
                        \ which is (x_sign x_hi x_lo), which we know has the
                        \ oposite sign to K(3 2 1), and that's what we just set
                        \ the sign of K(3 2 1) to... so we can jump to MV14 to
                        \ return from the subroutine

 LDA #1                 \ We need to swap the sign of the result in K(3 2 1),
 SBC K+1                \ which we do by calculating 0 - K(3 2 1), which we can
 STA K+1                \ do with 1 - C - K(3 2 1), as we know the C flag is
                        \ clear. We start with the low bytes

 LDA #0                 \ Then the middle bytes
 SBC K+2
 STA K+2

 LDA #0                 \ And finally the high bytes
 SBC K+3

 AND #%01111111         \ Set the sign bit of K+3 to the same sign as T,
 ORA T                  \ i.e. the same sign as the original K(3 2 1), as
 STA K+3                \ that's the largest argument

.MV14

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MVS4
\
\ Apply pitch and roll angles alpha and beta to the orientation vector in Y.
\
\ Specifically, this routine rotates a point (x, y, z) around the origin by
\ pitch alpha and roll beta, using the small angle approximation to make the
\ maths easier, and incorporating the Minsky circle algorithm to make the
\ rotation more stable (though more elliptic).
\
\ If that paragraph makes sense to you, then you should probably be writing
\ this commentary! For the rest of us, there's an explanation below.
\
\ Arguments:
\
\   Y                   Determines which row of the INWK orientation vectors to
\                       transform:
\
\                         * Y = 9 rotates nosev:
\                               (nosev_x, nosev_y, nosev_z)
\
\                         * Y = 15 rotates roofv:
\                               (roofv_x, roofv_y, roofv_z)
\
\                         * Y = 21 rotates sidev:
\                               (sidev_x, sidev_y, sidev_z)
\
\ ******************************************************************************
\
\ Deep dive: Rolling ansd pitching
\ --------------------------------
\ In order to understand this routine, we need first to understand what it's
\ for, so consider our Cobra Mk III sitting in deep space, minding its own
\ business, when an enemy ship appears in the distance. Inside the little
\ bubble of universe that Elite creates to simulate this scenario, our ship is
\ at the origin (0, 0, 0), and the enemy ship has just popped into existence at
\ (x, y, z), where the x-axis is to our right, the y-axis is up, and the z-axis
\ is in the direction our Cobra is pointing in.
\
\ Of course, our first thought is to roll and pitch our Cobra to get the new
\ arrival firmly into the crosshairs, and in doing this the enemy ship will
\ appear to move in space, relative to us. For example, if we do a pitch by
\ pulling back on the joystick or pressing "X", this will pull the nose of our
\ Cobra Mk III up, and the point (x, y, z) will appear to move down in the sky
\ in front of us.
\
\ So this routine calculates the movement of the enemy ship in space when we
\ pitch and roll, as then the game can show the ship on screen and work out
\ whether our lasers are pointing in the correct direction to unleash fiery
\ death on the pirate/cop/innocent trader in our sights.
\
\ Roll and pitch
\ --------------
\ To make it easier to work with the 3D rotations of pitching and rolling, we
\ break down the movement into two separate rotations, the roll and the pitch,
\ and we apply one of them first, and then the other (in Elite, we do the roll
\ first, and then the pitch).
\
\ So let's look at the first one: the roll. Imagine we're sitting in our
\ spaceship and do a roll to the right by pressing ">". From our perspective
\ this is the same as the universe doing a roll to the left, so if we're
\ looking out of the front of our ship, and there's a stationary enemy ship at
\ (x, y, z), then rolling by an angle of a will look something like this:
\
\   y
\
\   ^         (x, y, z)
\   |       /
\   |      /    <-.
\   |     /       a`.
\   |    /          |
\   |   /
\   |  /              __ (x, y, z)
\   | /       __..--''
\   |/__..--''
\   +-----------------------> x
\
\ So the enemy ship will move from (x, y, z) to (x, y, z) in our little
\ bubble of universe. Moreover, because the enemy ship is stationary, rolling
\ our ship won't change the enemy ship's z-coordinate - it will always be the
\ same distance in front of us, however far we roll. So we know that z = z,
\ but how do we calculate x and y?
\
\ First, let's ditch the z-coordinate, as we know this doesn't change. This
\ leaves us with a 2D rotation to consider; we are effectively only interested
\ in what happens in the 2D plane at distance z in front of our ship (imagine a
\ cinema screen at distance z, and that's what we're about to draw graphs on).
\
\ Now, let's look at the triangle formed by the original (x, y) point:
\
\   ^
\   |
\   |
\   |
\   |
\   |
\   |         h        __ (x, y)
\   |         __..--''  |
\   | __..--''    t     | <------- y
\   +----------------------->
\        <---- x ---->
\
\ In this triangle, let's call the angle at the origin t and the hypotenuse h,
\ and we already know the adjacent side is x and the opposite side is y. If we
\ plug these into the equations for sine and cosine, we get:
\
\   cos t = adjacent / hypotenuse = x / h
\   sin t = opposite / hypotenuse = y / h
\
\ which gives us the following when we multiply both sides by h:
\
\   x = h * cos(t)
\   y = h * sin(t)
\
\ (We could use Pythagoras to calculate h from x and y, but we don't need to -
\ you'll see why in a minute.)
\
\ Now let's look at the 2D triangle formed by the new, post-roll (x, y)
\ point:
\
\   ^         (x, y)
\   |       /|
\   |      / |
\   |     /  |
\   |  h /   |
\   |   /    | <------- y
\   |  /     |
\   | /      |
\   |/ t+a   |
\   +----------------------->
\   <-- x -->
\
\ In this triangle, the angle is now t + a (as we have rolled left by an angle
\ of a), the hypotenuse is still h (because we're rotating around the origin),
\ the adjacent is x and the opposite is y. If we plug these into the
\ equations for sine and cosine, we get:
\
\  cos(t + a) = adjacent / hypotenuse = x / h
\  sin(t + a) = opposite / hypotenuse = y / h
\
\ which gives us the following when we multiply both sides by h:
\
\   x = h * cos(t + a)                                   (i)
\   y = h * sin(t + a)                                   (ii)
\
\ We can expand these using the standard trigonometric formulae for compound
\ angles, like this:
\
\   x = h * cos(t + a)                                   (i)
\      = h * (cos(t) * cos(a) - * sin(t) * sin(a))
\      = h * cos(t) * cos(a) - h * sin(t) * sin(a)        (iii)
\
\   y = h * sin(t + a)                                   (ii)
\      = h * (sin(t) * cos(a) + cos(t) * sin(a))
\      = h * sin(t) * cos(a) + h * cos(t) * sin(a)        (iv)
\
\ and finally we can substitute the values of x and y that we calculated from
\ the first triangle above:
\
\   x = h * cos(t) * cos(a) - h * sin(t) * sin(a)        (iii)
\      = x * cos(a) - y * sin(a)
\
\   y = h * sin(t) * cos(a) + h * cos(t) * sin(a)        (iv)
\      = y * cos(a) + x * sin(a)
\
\ So, to summarise, if we do a roll of angle a, then the ship at (x, y, z) will
\ move to (x, y, z), where:
\
\   x = x * cos(a) - y * sin(a)
\   y = y * cos(a) + x * sin(a)
\   z = z
\
\ Tranformation matrices
\ ----------------------
\ We can express the exact same thing in matrix form, like this:
\
\   [  cos(a)  sin(a)  0 ]     [ x ]     [ x * cos(a) + y * sin(a) ]
\   [ -sin(a)  cos(a)  0 ]  x  [ y ]  =  [ y * cos(a) - x * sin(a) ]
\   [    0       0     1 ]     [ z ]     [            z            ]
\
\ The matrix on the left is therefore the transformation matrix for rolling
\ through an angle a.
\
\ We can apply the exact same process to the pitch rotation, which gives us a
\ transformation matrix for pitching through an angle b, as follows:
\
\   [ 1    0        0    ]     [ x ]     [            x            ]
\   [ 0  cos(b)  -sin(b) ]  x  [ y ]  =  [ y * cos(b) - z * sin(a) ]
\   [ 0  sin(b)   cos(b) ]     [ z ]     [ y * sin(b) + z * cos(b) ]
\
\ Finally, we can multiply these two rotation matrices together to get a
\ transformation matrix that applies roll and then pitch in one go:
\
\   [       cos(a)           sin(a)         0    ]     [ x ]
\   [ -sin(a) * cos(b)  cos(a) * cos(b)  -sin(b) ]  x  [ y ]
\   [ -sin(a) * sin(b)  cos(a) * sin(b)   cos(b) ]     [ z ]
\
\ So, to move our enemy ship in space when we pitch and roll, we simply need
\ to do this matrix multiplication. In 6502 assembly language. In a very small
\ memory footprint. Oh, and it needs to be quick, too, because we're going to
\ be using this routine a lot. Got that?
\
\ Small angle approximation
\ -------------------------
\ Luckily we can simplify the maths considerably by applying the "small angle
\ approximation". This states that for small angles in radians, the following
\ approximations hold true:
\
\   sin a ~= a
\   cos a ~= 1 - (a * a) / 2 ~= 1
\   tan a ~= a
\
\ These approximations make sense when you look at the triangle geometry that
\ is used to show the ratios of trigonometry, and imagine what happens when the
\ angle gets small; for example, cosine is defined as the adjacent over the
\ hypotenuse, and as the angle tends to 0, the hypotenuse "hinges" down on top
\ of the adjacent, so it's intuitive that cos a tends to 1 for small angles.
\
\ (A quick aside: the approximations actually state that cos a approximates to
\ 1 - a^2/2, but Elite uses 1 and corrects for this in the TIDY routine, so
\ let's stick to the simpler version.)
\
\ So dropping the small angle approximations into our rotation calculation above
\ gives the following, much simpler version:
\
\   [  1   a   0 ]     [ x ]     [    x + ay     ]
\   [ -a   1  -b ]  x  [ y ]  =  [ y - ax  - bz  ]
\   [ -ab  b   1 ]     [ z ]     [ z + b(y - ax) ]
\
\ So to move rotate a point (x, y, z) around the origin (the centre of our
\ ship) by the current pitch and roll angles (alpha and beta), we just need to
\ calculate these three relatively simple equations:
\
\   x -> x + alpha * y
\   y -> y - alpha * x - beta * z
\   z -> z + beta * (y - alpha * x)
\
\ There's a fascinating document on Ian Bell's Elite website that shows this
\ exact calculation, in the author's own handwritten notes for the game. You
\ can see it in the second image here:
\
\   http://www.iancgbell.clara.net/elite/design/index.htm
\
\ just below the original design for the cockpit, before the iconic 3D scanner
\ was added (which is a whole other story...).
\
\ Minsky circles
\ --------------
\ So that's what this routine does... it transforms x, y and z when we roll and
\ pitch. But there is a twist. Let's write the transformation equations as you
\ might write them in code (and, indeed this is how the routine itself is
\ structured).
\
\ First, we do the roll calculations:
\
\   y = y - alpha * x
\   x = x + alpha * y
\
\ and then we do the pitch calculations:
\
\   y = y - beta * z
\   z = z + beta * y
\
\ At first glance this code looks the same as the matrix calculation above, but
\ then you notice that the value of y used in the calculations of x and z is not
\ the original value of y, but the updated value of y. In fact, the above code
\ actually does the following transformation of (x, y, z):
\
\   x -> x + alpha * (y - alpha * x)
\   y -> y - alpha * x - beta * z
\   z -> z + beta * (y - alpha * x - beta * z)
\
\ Oops, that isn't what we wanted to calculate... except this version turns out
\ to do a better job than our original matrix multiplication above. This new
\ version, where we reuse the updated y in the calculations of x and z instead
\ of the original y, was "invented by mistake when [Marvin Minsky] tried to save
\ one register in a display hack", and inadvertently discovered a way to rotate
\ points within a pretty good approximation of a circle without using complex
\ maths. The method appeared as item 149 in the 1972 HAKMEM memo, and if that
\ doesn't mean anything to you, see if you can take the time to look it up.
\ It's worth the effort if you're interested in this kind of thing (and you're
\ the one reading a commentary on 8-bit code from 1984, so I'm guessing this
\ might include you).
\
\ Anyway, the rotation in Minsky's method doesn't describe a perfect circle,
\ but instead it follows a slightly sheared ellipse, but that's close enough
\ for 8-bit space combat in 192 x 256 pixels. So, coming back to the Elite
\ sourced code, the routine below implements the rotation like this (shown
\ here for the nosev orientation vectors, i.e. nosev_x, nosev_y and
\ nosev_z):
\
\ Roll calculations:
\
\   nosev_y = nosev_y - alpha * nosev_x_hi
\   nosev_x = nosev_x + alpha * nosev_y_hi
\
\ Pitch calculations:
\
\   nosev_y = nosev_y - beta * nosev_z_hi
\   nosev_z = nosev_z + beta * nosev_y_hi
\
\ And that's how we rotate a point around the origin by pitch alpha and roll
\ beta, using the small angle approximation to make the maths easier, and
\ incorporating the Minsky circle algorithm to make the rotation more stable.
\
\ ******************************************************************************

.MVS4

 LDA ALPHA              \ Set Q = alpha (the roll angle to rotate through)
 STA Q

 LDX INWK+2,Y           \ Set (S R) = nosev_y
 STX R
 LDX INWK+3,Y
 STX S

 LDX INWK,Y             \ These instructions have no effect as MAD overwrites
 STX P                  \ X and P when called, but they set X = P = nosev_x_lo

 LDA INWK+1,Y           \ Set A = -nosev_x_hi
 EOR #%10000000

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+3,Y           \           = alpha * -nosev_x_hi + nosev_y
 STX INWK+2,Y           \
                        \ and store (A X) in nosev_y, so this does:
                        \
                        \ nosev_y = nosev_y - alpha * nosev_x_hi

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_y_lo

 LDX INWK,Y             \ Set (S R) = nosev_x
 STX R
 LDX INWK+1,Y
 STX S

 LDA INWK+3,Y           \ Set A = nosev_y_hi

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+1,Y           \           = alpha * nosev_y_hi + nosev_x
 STX INWK,Y             \
                        \ and store (A X) in nosev_x, so this does:
                        \
                        \ nosev_x = nosev_x + alpha * nosev_y_hi

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_x_lo

 LDA BETA               \ Set Q = beta (the pitch angle to rotate through)
 STA Q

 LDX INWK+2,Y           \ Set (S R) = nosev_y
 STX R
 LDX INWK+3,Y
 STX S
 LDX INWK+4,Y

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_y

 LDA INWK+5,Y           \ Set A = -nosev_z_hi
 EOR #%10000000

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+3,Y           \           = beta * -nosev_z_hi + nosev_y
 STX INWK+2,Y           \
                        \ and store (A X) in nosev_y, so this does:
                        \
                        \ nosev_y = nosev_y - beta * nosev_z_hi

 STX P                  \ This instruction has no effect as MAD overwrites P,
                        \ but it sets P = nosev_y_lo

 LDX INWK+4,Y           \ Set (S R) = nosev_z
 STX R
 LDX INWK+5,Y
 STX S

 LDA INWK+3,Y           \ Set A = nosev_y_hi

 JSR MAD                \ Set (A X) = Q * A + (S R)
 STA INWK+5,Y           \           = beta * nosev_y_hi + nosev_z
 STX INWK+4,Y           \
                        \ and store (A X) in nosev_z, so this does:
                        \
                        \ nosev_z = nosev_z + beta * nosev_y_hi

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\ Subroutine: MVS5
\
\ Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
\ in a specified direction, by rotating the orientation vectors. The vectors to
\ rotate are given in X and Y, and the direction of the rotation is given in
\ RAT2. The calculation is as follows:
\
\   * If the direction is positive:
\
\     X = X * (1 - 1/512) + Y / 16
\     Y = Y * (1 - 1/512) - X / 16
\
\   * If the direction is negative:
\
\     X = X * (1 - 1/512) - Y / 16
\     Y = Y * (1 - 1/512) + X / 16
\
\ So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
\
\   roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
\   sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
\
\ Arguments:
\
\   X                   The first vector to rotate:
\
\                         * If X = 15, rotate roofv_x
\
\                         * If X = 17, rotate roofv_y
\
\                         * If X = 19, rotate roofv_z
\
\   Y                   The second vector to rotate:
\
\                         * If Y = 9,  rotate nosev_x
\
\                         * If Y = 11, rotate nosev_y
\
\                         * If Y = 13, rotate nosev_z
\
\                         * If Y = 21, rotate sidev_x
\
\                         * If Y = 23, rotate sidev_y
\
\                         * If Y = 25, rotate sidev_z
\
\   RAT2                The direction of the pitch or roll to perform, positive
\                       or negative (i.e. the sign of the roll or pitch counter
\                       in bit 7)
\
\ ******************************************************************************
\
\ Deep dive: Rolling and pitching by a fixed angle
\ ------------------------------------------------
\ This routine applies the same trigonomety as described in routine MVS4, but
\ this time the angle is fixed at a very small 1/16 radians (around 3.6 degrees)
\ so the maths is rather simpler. If you refer to the documentation for MVS4,
\ you can see that the equations for rolling a point (x, y, z) through an angle
\ a to (x, y, z) are:
\
\   x = x * cos(a) - y * sin(a)
\   y = y * cos(a) + x * sin(a)
\   z = z
\
\ In this case, angle a is fixed at 1/16 radians, so we can take the small angle
\ approximations described in MVS4, and reduce them like this:
\
\   sin a ~= a
\          = 1/16
\
\   cos a ~= 1 - (a * a) / 2
\          = 1 - (1/16 * 1/16) / 2
\          = 1 - (1/256) / 2
\          = 1 - 1/512
\
\ Plugging these into the above equations, we get:
\
\   x = x * cos(a) - y * sin(a)
\      = x * (1 - 1/512) - y / 16
\
\   y = y * cos(a) + x * sin(a)
\      = y * (1 - 1/512) + x / 16
\
\   z = z
\
\ so this is what this routine implements.
\
\ To clarify further, let's consider the example when X = 15 (roofv_x) and
\ Y = 21 (sidev_x), which applies roll to the ship. If we consider the
\ orientation vectors, this it how the three vectors look if we're sitting in
\ in the ship's cockpit:
\
\   roofv (points up out of the ship's sunroof...
\   ^       or it would if it had one)
\   |
\   |
\   |
\   |    nosev (points forward out of the ship's nose
\   |   /        and into the screen)
\   |  /
\   | /
\   |/
\   +-----------------------> sidev (points out of the
\                                    ship's right view)
\
\ If we are doing a roll, then the nosev vector won't change, but roofv and
\ sidev will rotate around, so let's just consider the x-y plane (i.e. the
\ screen) and ignore the z-axis. It looks like this when we roll to the left by
\ angle a, rotating roofv to roofv and sidev to sidev:
\
\             roofv
\                ^
\   roofv       |
\         \      |
\          \     |
\           \    |
\            \   |
\             \  |                 __ sidev     <-.
\              \ |         __..--''                a`.
\               \| __..--''                          |
\                +-----------------------> sidev
\
\ Applying trigonometry to the above diagram, we get:
\
\   roofv = roofv * cos(a) - sidev * sin(a)
\
\   sidev = sidev * cos(a) + roofv * sin(a)
\
\ so calling MVS5 with X = 15 (roofv_x) and Y = 21 (sidev_x) and a negative
\ RAT2 (as the roll angle a is anticlockwise in our example), we get the
\ following if we do the calculation for the x coordinates in-place:
\
\   roofv_x = roofv_x * (1 - 1/512) - sidev_x / 16
\
\   sidev_x = sidev_x * (1 - 1/512) + roofv_x / 16
\
\ Subsequent calls with X = 17, Y = 23 and X = 19, Y = 25 cover the y and z
\ coordinates, so that's exactly what the roll section of this routine does,
\ with the pitch section doing the same maths, but on roofv and nosev.
\
\ ******************************************************************************

.MVS5
{
 LDA INWK+1,X           \ Fetch roofv_x_hi, clear the sign bit, divide by 2 and
 AND #%01111111         \ store in T, so:
 LSR A                  \
 STA T                  \ T = |roofv_x_hi| / 2
                        \   = |roofv_x| / 512
                        \
                        \ The above is true because:
                        \
                        \ |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
                        \
                        \ so:
                        \
                        \ |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
                        \                    + roofv_x_lo / 512
                        \                  = |roofv_x_hi| / 2

 LDA INWK,X             \ Now we do the following subtraction:
 SEC                    \
 SBC T                  \ (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
 STA R                  \       = (1 - 1/512) * roofv_x
                        \
                        \ by doing the low bytes first

 LDA INWK+1,X           \ And then the high bytes (the high byte of the right
 SBC #0                 \ side of the subtraction being 0)
 STA S

 LDA INWK,Y             \ Set P = nosev_x_lo
 STA P

 LDA INWK+1,Y           \ Fetch the sign of nosev_x_hi (bit 7) and store in T
 AND #%10000000
 STA T

 LDA INWK+1,Y           \ Fetch nosev_x_hi into A and clear the sign bit, so
 AND #%01111111         \ A = |nosev_x_hi|

 LSR A                  \ Set (A P) = (A P) / 16
 ROR P                  \           = |nosev_x_hi nosev_x_lo| / 16
 LSR A                  \           = |nosev_x| / 16
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P

 ORA T                  \ Set the sign of A to the sign in T (i.e. the sign of
                        \ the original nosev_x), so now:
                        \
                        \ (A P) = nosev_x / 16

 EOR RAT2               \ Give it the sign as if we multiplied by the direction
                        \ by the pitch or roll direction

 STX Q                  \ Store the value of X so it can be restored after the
                        \ call to ADD

 JSR ADD                \ (A X) = (A P) + (S R)
                        \       = +/-nosev_x / 16 + (1 - 1/512) * roofv_x

 STA K+1                \ Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
 STX K

 LDX Q                  \ Restore the value of X from before the call to ADD

 LDA INWK+1,Y           \ Fetch nosev_x_hi, clear the sign bit, divide by 2 and
 AND #%01111111         \ store in T, so:
 LSR A                  \
 STA T                  \ T = |nosev_x_hi| / 2
                        \   = |nosev_x| / 512

 LDA INWK,Y             \ Now we do the following subtraction:
 SEC                    \
 SBC T                  \ (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
 STA R                  \       = (1 - 1/512) * nosev_x
                        \
                        \ by doing the low bytes first

 LDA INWK+1,Y           \ And then the high bytes (the high byte of the right
 SBC #0                 \ side of the subtraction being 0)
 STA S

 LDA INWK,X             \ Set P = roofv_x_lo
 STA P

 LDA INWK+1,X           \ Fetch the sign of roofv_x_hi (bit 7) and store in T
 AND #%10000000
 STA T

 LDA INWK+1,X           \ Fetch roofv_x_hi into A and clear the sign bit, so
 AND #%01111111         \ A = |roofv_x_hi|

 LSR A                  \ Set (A P) = (A P) / 16
 ROR P                  \           = |roofv_x_hi roofv_x_lo| / 16
 LSR A                  \           = |roofv_x| / 16
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P

 ORA T                  \ Set the sign of A to the opposite sign to T (i.e. the
 EOR #%10000000         \ sign of the original -roofv_x), so now:
                        \
                        \ (A P) = -roofv_x / 16

 EOR RAT2               \ Give it the sign as if we multiplied by the direction
                        \ by the pitch or roll direction

 STX Q                  \ Store the value of X so it can be restored after the
                        \ call to ADD

 JSR ADD                \ (A X) = (A P) + (S R)
                        \       = -/+roofv_x / 16 + (1 - 1/512) * nosev_x

 STA INWK+1,Y           \ Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
 STX INWK,Y

 LDX Q                  \ Restore the value of X from before the call to ADD

 LDA K                  \ Set roofv_x = K(1 0)
 STA INWK,X             \              = (1-1/512) * roofv_x +/- nosev_x / 16
 LDA K+1
 STA INWK+1,X

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MVT6
\
\ Do the following calculation, for the coordinate given by X (so this is what
\ it does for the x-coordinate):
\
\   (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
\
\ A is a sign bit and is not included in the calculation, but bits 0-6 of A are
\ preserved. Bit 7 is set to the sign of the result.
\
\ Arguments:
\
\   A                   The sign of P(2 1) in bit 7
\
\   P(2 1)              The 16-bit value we want to add the coordinate to
\
\   X                   The coordinate to add, as follows:
\
\                         * If X = 0, add to (x_sign x_hi x_lo)
\
\                         * If X = 3, add to (y_sign y_hi y_lo)
\
\                         * If X = 6, add to (z_sign z_hi z_lo)
\
\ Returns:
\
\   A                   The sign of the result (in bit 7)
\
\ ******************************************************************************

.MVT6
{
 TAY                    \ Store argument A into Y, for later use

 EOR INWK+2,X           \ Set A = A EOR x_sign

 BMI MV50               \ If the sign is negative, i.e. A and x_sign have
                        \ different signs, jump to MV50

                        \ The signs are the same, so we can add the two
                        \ arguments and keep the sign to get the result

 LDA P+1                \ First we add the low bytes:
 CLC                    \
 ADC INWK,X             \   P+1 = P+1 + x_lo
 STA P+1

 LDA P+2                \ And then the high bytes:
 ADC INWK+1,X           \
 STA P+2                \   P+2 = P+2 + x_hi

 TYA                    \ Restore the original A argument that we stored earlier
                        \ so that we keep the original sign

 RTS                    \ Return from the subroutine

.MV50

 LDA INWK,X             \ First we subtract the low bytes:
 SEC                    \
 SBC P+1                \   P+1 = x_lo - P+1
 STA P+1

 LDA INWK+1,X           \ And then the high bytes:
 SBC P+2                \
 STA P+2                \   P+2 = x_hi - P+2

 BCC MV51               \ If the last subtraction underflowed, then the C flag
                        \ will be clear and x_hi < P+2, so jump to MV51 to
                        \ negate the result

 TYA                    \ Restore the original A argument that we stored earlier
 EOR #%10000000         \ but flip bit 7, which flips the sign. We do this
                        \ because x_hi >= P+2 so we want the result to have the
                        \ same sign as x_hi (as it's the dominant side in this
                        \ calculation). The sign of x_hi is x_sign, and x_sign
                        \ has the opposite sign to A, so we flip the sign in A
                        \ to return the correct result

 RTS                    \ Return from the subroutine

.MV51

 LDA #1                 \ Our subtraction underflowed, so we negate the result
 SBC P+1                \ using two's complement, first with the high byte:
 STA P+1                \
                        \   P+1 = 1 - P+1

 LDA #0                 \ And then the high byte:
 SBC P+2                \
 STA P+2                \   P+2 = 0 - P+2

 TYA                    \ Restore the original A argument that we stored earlier
                        \ as this is the correct sign for the result. This is
                        \ because x_hi < P+2, so we want to return the same sign
                        \ as P+2, the dominant side. P+2 and

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MV40
\
\ Rotate the planet or sun's location in space by the amount of pitch and roll
\ of our ship.
\
\ We implement this using the same equations as in part 5 of MVEIT. Specifically,
\ the calculation is as follows:
\
\   x -> x + alpha * (y - alpha * x)
\   y -> y - alpha * x - beta * z
\   z -> z + beta * (y - alpha * x - beta * z)
\
\ which we implement like this:
\
\   1. K2 = y - alpha * x
\   2. z = z + beta * K2        z = z + beta * (y - alpha * x)
\   3. y = K2 - beta * z        y = y - alpha * x - beta * z
\   4. x = x + alpha * y        x = x + alpha * y
\
\ See MVET (Part 5) for more details of this calculation.
\
\ ******************************************************************************

.MV40
{
 LDA ALPHA              \ Set Q = -ALPHA, so Q contains the angle we want to
 EOR #%10000000         \ roll the planet through (i.e. in the opposite
 STA Q                  \ direction to our ship's roll)

 LDA INWK               \ Set P(1 0) = (x_hi x_lo)
 STA P
 LDA INWK+1
 STA P+1

 LDA INWK+2             \ Set A = x_sign

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \
                        \ which also means:
                        \
                        \ K(3 2 1) = (A P+1 P) * Q / 256
                        \          = x * -alpha / 256
                        \          = - alpha * x / 256

 LDX #3                 \ Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
 JSR MVT3               \              = y - alpha * x / 256

 LDA K+1                \ Set K2(2 1) = P(1 0) = K(2 1)
 STA K2+1
 STA P

 LDA K+2                \ Set K2+2 = K+2
 STA K2+2

 STA P+1                \ Set P+1 = K+2

 LDA BETA               \ Set Q = beta, the pitch angle of our ship
 STA Q

 LDA K+3                \ Set K+3 to K2+3, so now we have result 1 above:
 STA K2+3               \
                        \ K2(3 2 1) = K(3 2 1)
                        \           = y - alpha * x / 256

                        \ We also have:
                        \
                        \ A = K+3
                        \
                        \ P(1 0) = K(2 1)
                        \
                        \ so combined, these mean:
                        \
                        \ (A P+1 P) = K(3 2 1)
                        \           = K2(3 2 1)

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \
                        \ which also means:
                        \
                        \ K(3 2 1) = (A P+1 P) * Q / 256
                        \          = K2(3 2 1) * beta / 256
                        \          = beta * K2 / 256

 LDX #6                 \ K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
 JSR MVT3               \          = z + beta * K2 / 256

 LDA K+1                \ Set P = K+1
 STA P

 STA INWK+6             \ Set z_lo = K+1

 LDA K+2                \ Set P+1 = K+2
 STA P+1

 STA INWK+7             \ Set z_hi = K+2

 LDA K+3                \ Set A = z_sign = K+3, so now we have:
 STA INWK+8             \
                        \ (z_sign z_hi z_lo) = K(3 2 1)
                        \                    = z + beta * K2 / 256

                        \ So we now have result 2 above:
                        \
                        \ z = z + beta * K2

 EOR #%10000000         \ Flip the sign bit of A to give A = -z_sign

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \                = (-z_sign z_hi z_lo) * beta
                        \                = -z * beta

 LDA K+3                \ Set T to the sign bit of K(3 2 1 0), i.e. to the sign
 AND #%10000000         \ bit of -z * beta
 STA T

 EOR K2+3               \ If K2(3 2 1 0) has a different sign to K(3 2 1 0),
 BMI MV1                \ then EOR'ing them will produce a 1 in bit 7, so jump
                        \ to MV1 to take this into account

                        \ If we get here, K and K2 have the same sign, so we can
                        \ add them together to get the result we're after, and
                        \ then set the sign afterwards

 LDA K                  \ We now do the following sum:
\CLC                    \
 ADC K2                 \ (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
                        \
                        \ starting with the low bytes (which we don't keep)
                        \
                        \ The CLC instruction is commented out in the original
                        \ source. It isn't needed because MULT3 clears the C
                        \ flag, so this is an example of the authors finding
                        \ one more precious byte to save

 LDA K+1                \ We then do the middle bytes, which go into y_lo
 ADC K2+1
 STA INWK+3

 LDA K+2                \ And then the high bytes, which go into y_hi
 ADC K2+2
 STA INWK+4

 LDA K+3                \ And then the sign bytes into A, so overall we have the
 ADC K2+3               \ following, if we drop the low bytes from the result:
                        \
                        \ (A y_hi y_lo) = (K + K2) / 256

 JMP MV2                \ Jump to MV2 to skip the calculation for when K and K2
                        \ have different signs

.MV1

 LDA K                  \ If we get here then K2 and K have different signs, so
 SEC                    \ instead of adding, we need to subtract to get the
 SBC K2                 \ result we want, like this:
                        \
                        \ (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
                        \
                        \ starting with the low bytes (which we don't keep)

 LDA K+1                \ We then do the middle bytes, which go into y_lo
 SBC K2+1
 STA INWK+3

 LDA K+2                \ And then the high bytes, which go into y_hi
 SBC K2+2
 STA INWK+4

 LDA K2+3               \ Now for the sign bytes, so first we extract the sign
 AND #%01111111         \ byte from K2 without the sign bit, so P = |K2+3|
 STA P

 LDA K+3                \ And then we extract the sign byte from K without the
 AND #%01111111         \ sign bit, so A = |K+3|

 SBC P                  \ And finally we subtract the sign bytes, so P = A - P
 STA P

                        \ By now we have the following, if we drop the low bytes
                        \ from the result:
                        \
                        \ (A y_hi y_lo) = (K - K2) / 256
                        \
                        \ so now we just need to make sure the sign of the
                        \ result is correct

 BCS MV2                \ If the C flag is set, then the last subtraction above
                        \ didn't underflow and the result is correct, so jump to
                        \ MV2 as we are done with this particular stage

 LDA #1                 \ Otherwise the subtraction above underflowed, as K2 is
 SBC INWK+3             \ the dominant part of the subtraction, so we need to
 STA INWK+3             \ negate the result using two's complement, starting
                        \ with the low bytes:
                        \
                        \   y_lo = 1 - y_lo

 LDA #0                 \ And then the high bytes:
 SBC INWK+4             \
 STA INWK+4             \   y_hi = 0 - y_hi

 LDA #0                 \ And finally the sign bytes:
 SBC P                  \
                        \   A = 0 - P

 ORA #%10000000         \ We now force the sign bit to be negative, so that the
                        \ final result below gets the opposite sign to K, which
                        \ we want as K2 is the dominant part of the sum

.MV2

 EOR T                  \ T contains the sign bit of K, so if K is negative,
                        \ this flips the sign of A

 STA INWK+5             \ Store A in y_sign

                        \ So we now have result 3 above:
                        \
                        \ y = K2 + K
                        \   = K2 - beta * z

 LDA ALPHA              \ Set A = alpha
 STA Q

 LDA INWK+3             \ Set P(1 0) = (y_hi y_lo)
 STA P
 LDA INWK+4
 STA P+1

 LDA INWK+5             \ Set A = y_sign

 JSR MULT3              \ Set K(3 2 1 0) = (A P+1 P) * Q
                        \                = (y_sign y_hi y_lo) * alpha
                        \                = y * alpha

 LDX #0                 \ Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
 JSR MVT3               \              = x + y * alpha / 256

 LDA K+1                \ Set (x_sign x_hi x_lo) = K(3 2 1)
 STA INWK               \                        = x + y * alpha / 256
 LDA K+2
 STA INWK+1
 LDA K+3
 STA INWK+2

                        \ So we now have result 4 above:
                        \
                        \ x = x + y * alpha

 JMP MV45               \ We have now finished rotating the planet or sun by
                        \ our pitch and roll, so jump back into the MVEIT routine
                        \ at MV45 to apply all the other movements
}

\ ******************************************************************************
\
\ Save output/ELTA.bin
\
\ ******************************************************************************

PRINT "ELITE A"
PRINT "Assembled at ", ~CODE%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_A%

PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
SAVE "output/ELTA.bin", CODE%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE B
\
\ Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_B% = P%
LOAD_B% = LOAD% + P% - CODE%
Q% = _ENABLE_MAX_COMMANDER

\ ******************************************************************************
\
\ Variable: NA%
\
\ Contains the last saved commander data, with the name at NA% and the data at
\ NA%+8 onwards. The size of the data block is given in NT% (which also includes
\ the two checksum bytes that follow this block. This block is initially set up
\ with the default commander, which can be maxed out for testing purposes by
\ setting Q% to TRUE.
\
\ The commander's name is stored at NA%, and can be up to 7 characters long
\ (the DFS filename limit). It is terminated with a carriage return character,
\ ASCII 13.
\
\ ******************************************************************************

.NA%
{
 EQUS "JAMESON"         \ Default commander name
 EQUB 13                \ Terminated by a carriage return; commander name can
                        \ be up to 7 characters (the DFS limit for file names)

                        \ NA%+8 - the start of the commander data block
                        \
                        \ This block contains the last saved commander data
                        \ block. As the game is played it uses an identical
                        \ block at location TP to store the current commander
                        \ state, and that block is copied here when the game is
                        \ saved. Conversely, when the game starts up, the block
                        \ here is copied to TP, which restores the last saved
                        \ commander when we die
                        \
                        \ The intial state of this block defines the default
                        \ commander. Q% can be set to TRUE to give the default
                        \ commander lots of credits and equipment

 EQUB 0                 \ Mission status. The disc version of the game has two
                        \ missions, and this byte contains the status of those
                        \ missions (the possible values are 0, 1, 2, &A, &E). As
                        \ the tape version doesn't have missions, this byte will
                        \ always be zero, which means no missions have been
                        \ started
                        \
                        \ Note that this byte must not have bit 7 set, or
                        \ loading this commander will cause the game to restart

 EQUB 20                \ QQ0 = current system X-coordinate (Lave)
 EQUB 173               \ QQ1 = current system Y-coordinate (Lave)

 EQUW &5A4A             \ QQ21 = Seed w0 for system 0 in galaxy 0 (Tibedied)
 EQUW &0248             \ QQ21 = Seed w1 for system 0 in galaxy 0 (Tibedied)
 EQUW &B753             \ QQ21 = Seed w2 for system 0 in galaxy 0 (Tibedied)

IF Q%
 EQUD &00CA9A3B         \ CASH = Amount of cash (100,000,000 Cr)
ELSE
 EQUD &E8030000         \ CASH = Amount of cash (100 Cr)
ENDIF

 EQUB 70                \ QQ14 = Fuel level

 EQUB 0                 \ COK = Competition code

 EQUB 0                 \ GCNT = Galaxy number, 0-7

 EQUB POW+(128 AND Q%)  \ LASER = Front laser

IF Q% OR _FIX_REAR_LASER
 EQUB (POW+128) AND Q%  \ LASER+1 = Rear laser, as in ELITEB source
ELSE
 EQUB POW               \ LASER+1 = Rear laser, as in extracted ELTB binary
ENDIF

 EQUB 0                 \ LASER+2 = Left laser

 EQUB 0                 \ LASER+3 = Right laser

 EQUW 0                 \ Not used (reserved for up/down lasers, maybe?)

 EQUB 22+(15 AND Q%)    \ CRGO = Cargo capacity

 EQUD 0                 \ QQ20 = Contents of cargo hold (17 bytes)
 EQUD 0
 EQUD 0
 EQUD 0
 EQUB 0

 EQUB Q%                \ ECM = E.C.M.

 EQUB Q%                \ BST = Fuel scoops ("barrel status")

 EQUB Q% AND 127        \ BOMB = Energy bomb

 EQUB Q% AND 1          \ ENGY = Energy/shield level

 EQUB Q%                \ DKCMP = Docking computer

 EQUB Q%                \ GHYP = Galactic hyperdrive

 EQUB Q%                \ ESCP = Escape pod

 EQUD FALSE             \ Not used

 EQUB 3+(Q% AND 1)      \ NOMSL = Number of missiles

 EQUB FALSE             \ FIST = Legal status ("fugitive/innocent status")

 EQUB 16                \ AVL = Market availability (17 bytes)
 EQUB 15
 EQUB 17
 EQUB 0
 EQUB 3
 EQUB 28
 EQUB 14
 EQUB 0
 EQUB 0
 EQUB 10
 EQUB 0
 EQUB 17
 EQUB 58
 EQUB 7
 EQUB 9
 EQUB 8
 EQUB 0

 EQUB 0                 \ QQ26 = Random byte that changes for each visit to a
                        \ system, for randomising market prices

 EQUW 0                 \ TALLY = Number of kills

 EQUB 128               \ SVC = Save count
}

\ ******************************************************************************
\
\ Variable: CHK2
\
\ Second checksum byte, see elite-checksum.py for more details.
\
\ ******************************************************************************

IF _FIX_REAR_LASER
 CH% = &3
ELSE
 CH% = &92
ENDIF

.CHK2
{
 EQUB CH% EOR &A9       \ Commander checksum byte, EOR'd with &A9 to make it
                        \ harder to tamper with the checksum byte
}

\ ******************************************************************************
\
\ Variable: CHK
\
\ Commander checksum byte, see elite-checksum.py for more details.
\
\ ******************************************************************************

.CHK
{
EQUB CH%
}

PRINT "CH% = ", ~CH%

\ ******************************************************************************
\
\ Variable: UNIV
\
\ The little bubble of the universe that we simulate in Elite can contain up to
\ NOSH + 1 (13) ships. Each of those ships has its own block of 36 (NI%) bytes
\ that contains information such as the ship's position in space, speed,
\ rotation, energy and so on, as well as a pointer to the line data for
\ plotting it on screen. These 13 blocks of ship data live in the first 468
\ bytes of the workspace at K% (&0900 to &0AD4).
\
\ In order to update the ship data, the whole block is copied to the INWK ship
\ workspace in zero page, as it's easier and quicker to work with zero page
\ locations. See the INWK documentation for details of the 36 bytes and the
\ information that they contain.
\
\ UNIV contains a table of address pointers to these data blocks, one for each
\ of the 13 ships. So if we want to read the data for ship number 3 in our
\ little bubble of the universe, we would look at the address held in UNIV+3
\ (ship numbers start at 0).
\
\ Along with FRIN, which has a slot for each of the ships in the local bubble
\ containing the ship types (or 0 for an empty slot), UNIV and K% contain all
\ the information about the 13 ships and objects that can populate local space
\ in Elite.
\
\ ******************************************************************************

.UNIV
{
FOR I%, 0, NOSH
 EQUW K% + I% * NI%     \ Address of block no. I%, of size NI%, in workspace K%
NEXT
}

\ ******************************************************************************
\
\ Variable: TWOS
\
\ Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
\ split screen). See the PIXEL routine for details.
\
\ ******************************************************************************

.TWOS
{
 EQUB %10000000
 EQUB %01000000
 EQUB %00100000
 EQUB %00010000
 EQUB %00001000
 EQUB %00000100
 EQUB %00000010
 EQUB %00000001
}

\ ******************************************************************************
\
\ Variable: TWOS2
\
\ Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
\ split screen). See the PIXEL routine for details.
\
\ ******************************************************************************

.TWOS2
{
 EQUB %11000000
 EQUB %01100000
 EQUB %00110000
 EQUB %00011000
 EQUB %00001100
 EQUB %00000110
 EQUB %00000011
 EQUB %00000011
}

\ ******************************************************************************
\
\ Variable: CTWOS
\
\ Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
\ the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
\ details.
\
\ There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
\ routine. The extra row is a repeat of the first row, and saves us from having
\ to work out whether CTWOS+1+X needs to be wrapped around when drawing a
\ two-pixel dash that crosses from one character block into another. See CPIX2
\ for more details.
\
\ ******************************************************************************

.CTWOS
{
 EQUB %10001000
 EQUB %01000100
 EQUB %00100010
 EQUB %00010001
 EQUB %10001000
}

\ ******************************************************************************
\
\ Subroutine: LL30, LOIN
\
\ Draw Line using (X1,Y1) , (X2,Y2).
\
\ ******************************************************************************

.LL30                   \ draw Line using (X1,Y1) , (X2,Y2)
.LOIN
{
 STY YSAV               \ will be restored at the end

 LDA #128               \ set bit7
 STA S
 ASL A                  \ = 0
 STA SWAP
 LDA X2
 SBC X1
 BCS LI1                \ deltaX
 EOR #&FF               \ else negate
 ADC #1
 SEC

.LI1                    \ deltaX

 STA P                  \ delta-X

 LDA Y2
 SBC Y1
 BCS LI2                \ deltaY
 EOR #&FF               \ else negate
 ADC #1

.LI2                    \ deltaY

 STA Q                  \ delta-Y
 CMP P                  \ is Q < P ?
 BCC STPX               \ if yes will Step along x
 JMP STPY               \ else will step along y

.STPX                   \ Step along x for line

 LDX X1
 CPX X2
 BCC LI3                \ is X1 < X2 ? hop down, order correct
 DEC SWAP               \ set flag
 LDA X2
 STA X1
 STX X2
 TAX
 LDA Y2
 LDY Y1
 STA Y1
 STY Y2

.LI3                    \ order correct    Xreg = X1

 LDA Y1
 LSR A                  \ build screen index
 LSR A
 LSR A
 ORA #&60               \ high byte of screen memory set to page &60+ Y1/8
 STA SCH
 LDA Y1
 AND #7                 \ build lo
 TAY                    \ row in char
 TXA                    \ X1
 AND #&F8               \ keep upper 5 bits
 STA SC                 \ screen lo

 TXA                    \ X1
 AND #7                 \ keep lower 3 bits
 TAX                    \ index mask
 LDA TWOS,X             \ Mode 4 single pixel
 STA R                  \ mask byte

 LDA Q                  \ delta-Y
 LDX #254               \ roll counter
 STX Q

.LIL1                   \ roll Q

 ASL A                  \ highest bit of delta-Y
 BCS LI4                \ steep
 CMP P                  \ delta-X
 BCC LI5                \ shallow

.LI4                    \ steep

 SBC P
 SEC

.LI5                    \ shallow

 ROL Q
 BCS LIL1               \ loop Q, end with some low bits in Q

 LDX P
 INX                    \ Xreg is width
 LDA Y2
 SBC Y1
 BCS DOWN               \ draw line to the right and down

 LDA SWAP
 BNE LI6                \ else Xreg was correct after all, no need to update R
 DEX

.LIL2                   \ counter X width

 LDA R                  \ mask byte
 EOR (SC),Y
 STA (SC),Y

.LI6                    \ Xreg correct

 LSR R                  \ mask byte
 BCC LI7                \ else moving to next column to right. Bring carry in back
 ROR R
 LDA SC
 ADC #8                 \ next column
 STA SC

.LI7                    \ S += Q. this is like an overflow monitor to update Y

 LDA S
 ADC Q                  \ some low bits
 STA S
 BCC LIC2               \ skip Y adjustment
 DEY
 BPL LIC2               \ skip Y adjustment
 DEC SCH
 LDY #7

.LIC2                   \ skip Y adjustment

 DEX
 BNE LIL2               \ loop X width
 LDY YSAV               \ restore Yreg
 RTS

.DOWN                   \ Line is going to the right and down

 LDA SWAP
 BEQ LI9                \ no swap
 DEX

.LIL3                   \ counter X width

 LDA R                  \ mask byte
 EOR (SC),Y
 STA (SC),Y

.LI9                    \ no swap

 LSR R
 BCC LI10               \ still in correct column, hop
 ROR R
 LDA SC
 ADC #8                 \ next column
 STA SC

.LI10                   \ this is like an overflow monitor to update Y

 LDA S
 ADC Q
 STA S
 BCC LIC3               \ skip Y adjustment
 INY
 CPY #8
 BNE LIC3               \ have not reached bottom byte of char, hop
 INC SCH
 LDY #0

.LIC3                   \ skipped Y adjustment

 DEX
 BNE LIL3               \ loop X width
 LDY YSAV               \ restore Yreg
 RTS

.STPY                   \ Step along y for line, goes down and to right

 LDY Y1
 TYA
 LDX X1
 CPY Y2
 BCS LI15               \ skip swap if Y1 >= Y2
 DEC SWAP
 LDA X2
 STA X1
 STX X2
 TAX
 LDA Y2
 STA Y1
 STY Y2
 TAY

.LI15                   \ Y1 Y2 order is now correct

 LSR A
 LSR A
 LSR A
 ORA #&60
 STA SCH                \ screen hi
 TXA                    \ X1
 AND #&F8
 STA SC                 \ screen lo

 TXA
 AND #7                 \ mask index
 TAX
 LDA TWOS,X             \ Mode4 single pixel
 STA R                  \ mask
 LDA Y1
 AND #7
 TAY

 LDA P                  \ delta-X
 LDX #1                 \ roll counter
 STX P

.LIL4                   \ roll P

 ASL A
 BCS LI13               \ do subtraction
 CMP Q                  \ delta-Y
 BCC LI14               \ less than Q

.LI13                   \ do subtraction

 SBC Q
 SEC

.LI14                   \ less than Q

 ROL P
 BCC LIL4               \ loop P, end with some low bits in P
 LDX Q
 INX                    \ adjust height
 LDA X2
 SBC X1
 BCC LFT                \ if C cleared then line moving to the left - hop down

 CLC
 LDA SWAP
 BEQ LI17               \ skip first point
 DEX

.LIL5                   \ skipped first point, counter X

 LDA R                  \ mask byte
 EOR (SC),Y
 STA (SC),Y

.LI17                   \ skipped first point

 DEY
 BPL LI16               \ skip hi adjust
 DEC SCH
 LDY #7                 \ new char

.LI16                   \ skipped hi adjust

 LDA S
 ADC P
 STA S
 BCC LIC5               \ skip, still in same column
 LSR R                  \ mask
 BCC LIC5               \ no mask bit hop
 ROR R                  \ else moved over to next column, reset mask
 LDA SC                 \ screen lo
 ADC #8                 \ next char below
 STA SC

.LIC5                   \ same column

 DEX
 BNE LIL5               \ loop X height
 LDY YSAV               \ restore Yreg
 RTS

.LFT                    \ going left

 LDA SWAP
 BEQ LI18               \ skip first point
 DEX                    \ reduce height

.LIL6                   \ counter X height

 LDA R                  \ mask byte
 EOR (SC),Y
 STA (SC),Y

.LI18

 DEY
 BPL LI19               \ skip hi adjust
 DEC SCH
 LDY #7                 \ rest char row

.LI19                   \ skipped hi adjust

 LDA S
 ADC P                  \ some low bits
 STA S
 BCC LIC6               \ no overflow

 ASL R                  \ else move byte mask to the left
 BCC LIC6               \ no overflow
 ROL R
 LDA SC
 SBC #7                 \ down 1 char
 STA SC
 CLC

.LIC6                   \ no overflow

 DEX                    \ height
 BNE LIL6               \ loop X
 LDY YSAV               \ restore Yreg
}

.HL6
{
 RTS                    \ end Line drawing
}

\ ******************************************************************************
\
\ Subroutine: NLIN3
\
\ Print a text token and draw a horizontal line at pixel row 19.
\
\ ******************************************************************************

.NLIN3
{
 JSR TT27               \ Print the text token in A

                        \ Fall through into NLIN4 to draw a horizontal line at
                        \ pixel row 19
}

\ ******************************************************************************
\
\ Subroutine: NLIN4
\
\ Draw a horizontal line at pixel row 19.
\
\ ******************************************************************************

.NLIN4
{
 LDA #19                \ Jump to NLIN2 to draw a horizontal line at pixel row
 BNE NLIN2              \ 19, returning from the subroutine with using a tail
                        \ call (this BNE is effectively a JMP as A will never
                        \ be zero)
}

\ ******************************************************************************
\
\ Subroutine: NLIN
\
\ Draw a horizontal line at pixel row 23 and move the text cursor down one
\ line.
\
\ ******************************************************************************

.NLIN
{
 LDA #23                \ Set A = 23 so NLIN2 below draws a horizontal line at
                        \ pixel row 23

 INC YC                 \ Move the text cursor down one line

                        \ Fall through into NLIN2 to draw the horizontal line
                        \ at row 23
}

\ ******************************************************************************
\
\ Subroutine: NLIN2
\
\ Draw a screen-wide horizontal line at the pixel row given in A - so the line
\ goes from (2, A) to (254, A).
\
\ Arguments:
\
\   A                   The pixel row on which to draw the horizontal line
\
\ ******************************************************************************

.NLIN2
{
 STA Y1                 \ Set (X1, Y1) = (2, A)
 LDX #2
 STX X1

 LDX #254               \ Set X2 = 254
 STX X2

 BNE HLOIN              \ Call HLOIN to draw a horizontal line from (2, A) to
                        \ (254, A) and return from the subroutine (this BNE is
                        \ effectively a JMP as A will never be zero)

}

\ ******************************************************************************
\
\ Subroutine: HLOIN2
\
\ Horizontal line X1,X2 using YY as mid-point, Acc is half-wdith.
\
\ ******************************************************************************

.HLOIN2                 \ Horizontal line X1,X2 using YY as mid-point, Acc is half-wdith
{
 JSR EDGES              \ Clips Horizontal lines
 STY Y1
 LDA #0                 \ flag in line buffer solar at height Y1
 STA LSO,Y
}

\ ******************************************************************************
\
\ Subroutine: HLOIN
\
\ Draw a horizontal line from (X1, Y1) to (X2, Y1).
\
\ Returns:
\
\   Y                   Y is preserved
\
\ ******************************************************************************

.HLOIN                  \ Draw a horizontal lines that only needs X1,Y1,X2
{
 STY YSAV               \ protect Yreg
 LDX X1
 CPX X2
 BEQ HL6                \ no line rts
 BCC HL5                \ no swap needed
 LDA X2
 STA X1
 STX X2
 TAX                    \ Xreg=X1

.HL5                    \ no swap needed

 DEC X2

 LDA Y1
 LSR A                  \ build screen hi
 LSR A
 LSR A
 ORA #&60
 STA SCH
 LDA Y1
 AND #7
 STA SC                 \ screen lo
 TXA                    \ X1
 AND #&F8
 TAY                    \ upper 5 bits of X1

.HL1

 TXA                    \ X1
 AND #&F8
 STA T
 LDA X2
 AND #&F8
 SEC
 SBC T
 BEQ HL2                \ within one column
 LSR A
 LSR A
 LSR A
 STA R                  \ wide count

 LDA X1
 AND #7
 TAX                    \ mask index
 LDA TWFR,X             \ right
 EOR (SC),Y
 STA (SC),Y
 TYA
 ADC #8
 TAY                    \ next column
 LDX R                  \ wide count
 DEX
 BEQ HL3                \ approaching end

 CLC

.HLL1                   \ counter X wide count

 LDA #&FF               \ mask full line
 EOR (SC),Y
 STA (SC),Y
 TYA
 ADC #8                 \ next column
 TAY
 DEX
 BNE HLL1               \ loop X wide

.HL3                    \ approaching end R =1 in HL1

 LDA X2
 AND #7
 TAX                    \ mask index
 LDA TWFL,X             \ left
 EOR (SC),Y
 STA (SC),Y
 LDY YSAV               \ restore Yreg
 RTS

.HL2                    \ wide done, X1 and X2 within 1 column

 LDA X1
 AND #7
 TAX                    \ mask index
 LDA TWFR,X             \ right
 STA T                  \ temp mask
 LDA X2
 AND #7
 TAX                    \ mask index
 LDA TWFL,X             \ left
 AND T                  \ temp mask
 EOR (SC),Y
 STA (SC),Y
 LDY YSAV               \ restore Y reg
 RTS                    \ end horizontal line
}

\ ******************************************************************************
\
\ Variable: TWFL
\
\ Mask left of horizontal line.
\
\ ******************************************************************************

.TWFL                   \ mask left of horizontal line
{
 EQUD &F0E0C080
 EQUW &FCF8
 EQUB &FE
}

\ ******************************************************************************
\
\ Variable: TWFR
\
\ Mask right of horizontal line.
\
\ ******************************************************************************

.TWFR                   \ mask right of horizontal line
{
 EQUD &1F3F7FFF
 EQUD &0103070F
}

\ ******************************************************************************
\
\ Subroutine: PX3
\
\ This routine is called from PIXEL to set 1 pixel within a character block for
\ a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
\ details, as this routine is effectively part of PIXEL.
\
\ Arguments:
\
\   X                   The x-coordinate of the pixel within the character block
\
\   Y                   The y-coordinate of the pixel within the character block
\
\   (SC+1 SC)           The screen addresss of the character block
\
\   T1                  The value of Y to restore on exit, so Y is preserved by
\                       the call to PIXEL
\
\ ******************************************************************************

.PX3
{
 LDA TWOS,X             \ Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
 EOR (SC),Y
 STA (SC),Y

 LDY T1                 \ Restore Y from T1, so Y is preserved by the routine

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: PIX1
\
\ Draw a stardust pixel.
\ X1 has xscreen yscreen = R.S+P.A
\
\ Arguments:
\
\   (A P)               A is the angle ALPHA or BETA, P is always 0
\
\   (S R)               YY(1 0) or YY(1 0) + Q * A
\
\   Y                   Stardust number
\
\   X1                  The x-coordinate offset
\
\   Y1                  The y-coordinate offset
\
\   ZZ                  The distance of the point (further away = smaller point)
\
\ ******************************************************************************

.PIX1
{
 JSR ADD                \ Set (A X) = (A P) + (S R)

 STA YY+1               \ Set YY+1 to A, the high byte of the result

 TXA                    \ Set SYL+Y to X, the low byte of the result
 STA SYL,Y
}

\ ******************************************************************************
\
\ Subroutine: PIXEL2
\
\ Draw a point (X1,Y1) from the middle of the screen.
\
\ Arguments:
\
\   X1                  The x-coordinate offset
\
\   Y1                  The y-coordinate offset (positive means up the screen
\                       from the centre, negative means down the screen)
\
\   ZZ                  The distance of the point (further away = smaller point)
\
\ ******************************************************************************

.PIXEL2
{
 LDA X1                 \ Fetch the x-coordinate offset into A

 BPL PX1                \ If the x-coordinate offset is positive, jump to PX1
                        \ to skip the following negation

 EOR #%01111111         \ The x-coordinate offset is negative, so flip all the
 CLC                    \ bits apart from the sign bit and add 1, to negate
 ADC #1                 \ it to a positive number, i.e. A is now |X1|

.PX1

 EOR #%10000000         \ Set X = -|A|
 TAX                    \       = -|X1|

 LDA Y1                 \ Fetch the y-coordinate offset into A and clear the
 AND #%01111111         \ sign bit, so A = |Y1|

 CMP #96                \ If |Y1| >= 96 then it's off the screen (as 96 is half 
 BCS PX4                \ the screen height), so return from the subroutine (as
                        \ PX4 contains an RTS)

 LDA Y1                 \ Fetch the y-coordinate offset into A

 BPL PX2                \ If the y-coordinate offset is positive, jump to PX2
                        \ to skip the following negation

 EOR #%01111111         \ The y-coordinate offset is negative, so flip all the
 ADC #1                 \ bits apart from the sign bit and subtract 1, to negate
                        \ it to a positive number, i.e. A is now |Y1|

.PX2

 STA T                  \ Set A = 97 - A
 LDA #97                \       = 97 - |Y1|
 SBC T                  \
                        \ so if Y is positive we display the point up from the
                        \ centre, while a negative Y means down from the centre
}

\ ******************************************************************************
\
\ Subroutine: PIXEL
\
\ Draw a point at screen coordinate (X, A) at a distance of ZZ away, on the
\ top part of the screen (the monochrome mode 4 portion).
\
\ Arguments:
\
\   X                   The screen x-coordinate of the point to draw
\
\   A                   The screen y-coordinate of the point to draw
\
\   ZZ                  The distance of the point (further away = smaller point)
\
\ Returns:
\
\   Y                   Y is preserved
\
\ Other entry points:
\
\   PX4                 Contains an RTS
\
\ ******************************************************************************
\
\ Deep dive: Drawing monochrome pixels in mode 4
\ ----------------------------------------------
\ The top part of Elite's split screen mode - the monochrome mode 4 part -
\ consists of 192 rows of pixels, with 256 pixels in each row. That sounds nice
\ and simple... except the way the BBC Micro stores its screen memory isn't
\ completely straightforward, and to understand Elite's drawing routines, an
\ understanding of this memory structure is essential.
\
\ Screen memory
\ -------------
\ First up, the simple part. Because mode 4 is a monochrome screen mode, each
\ pixel is represented by one bit (1 for white, 0 for black). It's more complex
\ for the four-colour mode 5 that's used for the dashboard portion of the
\ screen, but for mode 4 it's as simple as it gets.
\
\ However, screen memory is not laid out as you would expect. It isn't a simple
\ sequence of 256-bit lines, one for each horizontal pixel line, but instead
\ the screen is split into rows and columns. Each row is 8 pixels high, and
\ each column is 8 pixels wide, so the 192x256 space view has 24 rows and 32
\ columns. That 8x8 size is the same size as a standard BBC Micro text
\ character, so the screen memory is effectively split up into character rows
\ and columns (and it's no coincidence that these match the character layout
\ used in Elite, where XC and YC hold the location of the text cursor, with XC
\ in the range 0 to 23 and YC in the range 0 to 32).
\
\ The mode 4 screen starts in memory at &6000, and each character row takes up
\ 8 rows of 256 bits, or 256 bytes, so that means each character row takes up
\ one page of memory. So the first character row starts at &6000, the second
\ character row starts at &6100, and so on.
\
\ Each character row on screen is laid out like this in memory, where each
\ digit (0, 1, 2 etc.) represents a pixel, or bit:
\
\         01234567 ->-.      ,------->- 01234567->-.
\                      |    |                       |
\    ,-------<--------     |     ,-------<--------
\   |                       |    |
\    `->- 01234567 ->-.     |     `->- 01234567 ->-.
\                      |    |                       |
\    ,-------<--------     |     ,-------<--------
\   |                       |    |
\    `->- 01234567 ->-.     |     `->- 01234567 ->-.
\                      |    |                       |
\    ,-------<--------     |     ,-------<--------
\   |                       |    |
\    `->- 01234567 ->-.     |     `->- 01234567 ->-.
\                      |    |                       |
\    ,-------<--------     |     ,-------<--------
\   |                       |    |
\    `->- 01234567 ->-.     |     `->- 01234567 ->-.
\                      |    |                       |
\    ,-------<--------     |     ,-------<--------
\   |                       |    |
\    `->- 01234567 ->-.     |     `->- 01234567 ->-.
\                      |    |                       |
\    ,-------<--------     |     ,-------<--------
\   |                       |    |
\    `->- 01234567 ->-.     |     `->- 01234567 ->-.      ^
\                      |    |                       |     :
\    ,-------<--------     |     ,-------<--------      :
\   |                       |    |                        |
\    `->- 01234567 ->------      `->- 01234567 ->-------
\
\ The left-hand half of the diagram displays one 8x8 character's worth of
\ pixels, while the right-hand half shows a second 8x8 character's worth, and
\ so on along the row, for 32 characters. Specifically, the diagram above would
\ produce the following pixels in the top-left corner of the screen:
\
\   0123456701234567
\   0123456701234567
\   0123456701234567
\   0123456701234567
\   0123456701234567
\   0123456701234567
\   0123456701234567
\   0123456701234567
\
\ So let's imagine we want to draw a 2x2 bit of stardust on the screen at pixel
\ location (7, 2) - where the origin (0, 0) is in the top-left corner - so that
\ the top-left corner of the screen looks like this:
\
\   ................
\   ................
\   .......XX.......
\   .......XX.......
\   ................
\   ................
\   ................
\   ................
\
\ Let's split this up to match the above diagram a bit more closely:
\
\   ........ ........
\   ........ ........
\   .......X X.......
\   .......X X.......
\   ........ ........
\   ........ ........
\   ........ ........
\   ........ ........
\
\ As this is the first screen row, the address of the top-left corner is &6000.
\ The first byte is the first row on the left, the second byte is the second
\ row, and so on, like this:
\
\   &6000 = ........    &6008 = ........
\   &6001 = ........    &6009 = ........
\   &6002 = .......X    &600A = X.......
\   &6003 = .......X    &600B = X.......
\   &6004 = ........    &600C = ........
\   &6005 = ........    &600D = ........
\   &6006 = ........    &600E = ........
\   &6007 = ........    &600F = ........
\
\ So you can see that if we want to draw our 2x2 bit of stardust, we need to do
\ the following:
\
\   Set &6002 = %00000001
\   Set &6003 = %00000001
\   Set &600A = %10000000
\   Set &600B = %10000000
\
\ Or, if we want to draw our stardust without obliterating anything that's
\ already on screen in this area, we can use EOR logic, like this:
\
\   Set &6002 = ?&6002 EOR %00000001
\   Set &6003 = ?&6002 EOR %00000001
\   Set &600A = ?&6002 EOR %10000000
\   Set &600B = ?&6002 EOR %10000000
\
\ where ?&6002 denotes the current value of location &6002. Because of the way
\ EOR works:
\
\   0 EOR x = x
\   1 EOR x = NOT x
\
\ this means that the screen display will only change when we want to poke a
\ bit with value 1 into the screen memory (i.e. paint it white), and when we're
\ doing this, it will invert what's already on screen. This not only means that
\ poking a 0 into the screen memory means "leave this pixel as it is", it also
\ means we can draw something on the screen, and then redraw the exact same
\ thing to remove it from the screen, which can be a lot more efficient than
\ clearing the whole screen and redrawing the whole thing every time something
\ moves.
\
\ (The downside of EOR screen logic is that when white pixels overlap, they go
\ black, but that's not a particularly big deal in space - and it also means
\ that things like in-flight messages show up as black when they overlap the
\ sun, without complex logic.)
\
\ Converting pixel coordinates to screen locations
\ ------------------------------------------------
\ Given the above, we clearly need a way of converting pixel coordinates like
\ (7, 2) into screen memory locations. There are two parts to this - first, we
\ need to find out which character block we need to write into, and second,
\ which pixel row and column within that character corresponds to the pixel we
\ want to paint.
\
\ The first step is pretty easy. The screen is split up into character rows and
\ columns, with 8 pixels per character in both directions, so we can simply
\ divide the pixel coordinates by 8 to get the character location. Let's look
\ at some examples:
\
\   (7,   2)     becomes   (0.875,  0.25)
\   (57,  82)    becomes   (7.125,  10.25)
\   (191, 255)   becomes   (23.875, 31.875)
\
\ So the first pixel is at (0.875, 0.25), which is the same as saying it's in
\ the first character block (0, 0), and is at position (0.875, 0.25) within
\ that character. For the second example, the pixel is inside character (7, 10)
\ and is at position (0.125, 0.25) within that character, and the third is in
\ character (23, 31) at (0.875, 0.875) inside the character.
\
\ We can now codify this. To get the character block that contains a specific
\ pixel, we can divide the coordinates by 8 and ignore any remainder to get the
\ result we want, which is what the div operator does. So:
\
\   (7,   2)     is in character block   (7   div 8,   2 div 8)   =   (0, 0)
\   (57,  82)    is in character block   (57  div 8,  82 div 8)   =   (7, 10)
\   (191, 255)   is in character block   (191 div 8, 255 div 8)   =   (23, 31)
\
\ We can do the div 8 operation really easily in assembly language, by shifting
\ right three times, so in assembly, we get this:
\
\   Pixel (x, y) is in the character block at (x >> 3, y >> 3)
\
\ Next, we can then use the remainder to work out where our pixel is within
\ this 8x8 character block. The remainder is given by the mod operator, so:
\
\   (7, 2)       is at pixel   (7   mod 8,   2 mod 8)   =   (7, 2)
\   (57, 82)     is at pixel   (57  mod 8,  82 mod 8)   =   (1, 2)
\   (191, 255)   is at pixel   (191 mod 8, 255 mod 8)   =   (7, 7)
\
\ We can do a mod 8 operation really easily in assembly language by simply
\ ANDing with %111, so in assembly, we get this:
\
\   Pixel (x, y) is at position (x AND %111, y AND %111) within the character
\
\ And this is the algorithm that's implemented in this routine, though with a
\ small twist.
\
\ Poking bytes into screen addresses
\ ----------------------------------
\ To summarise, in order to paint pixel (x, y) on screen, we need to update
\ this character block:
\
\   (x >> 3, y >> 3)
\
\ and this specific pixel within that character block:
\
\   (x AND %111, y AND %111)
\
\ As mentioned above, we can update this pixel by poking a byte into screen
\ memory, so now we need to work out which memory location we need to update,
\ and what to update it with.
\
\ We've already discussed how each character row takes up one page (256 bytes)
\ of memory in Elite's mode 4 screen, so we can work out the page of the
\ location we need to update by taking the y-coordinate of the character for
\ the page. So, if (SCH SC) is the 16-bit address of the byte that we need to
\ update in order to paint pixel (x, y) on screen (i.e. SCH is the high byte and
\ SC is the low byte), then we know:
\
\   SCH = &60 + y >> 3
\
\ because the first character row takes up page &60 (screen memory starts at
\ &6000), and each character row takes up one page.
\
\ Next, within this page of memory, we want to update the character number x >>
\ 3. Each character takes up 8x8 pixels, which is 64 bits, or 8 bytes, so we
\ can calculate the memory location of where that character is stored in screen
\ memory by multiplying the character number by 8, like this:
\
\   The character starts at byte (x >> 3) * 8 within the row's page
\
\ Next, we know that the pixel we want to update within this block is on row (y
\ AND %111) in the character, and because there are 8 bits in each row (one
\ byte), this is also the byte offset of the start of that row within the
\ character block. So we also know this:
\
\   The pixel is in the character byte number (y AND %111)
\
\ So, to summarise, we know we need to update this byte in the row's memory
\ page:
\
\   (x >> 3) * 8 + (y AND %111)
\
\ The final question is what to poke into this byte.
\
\ The two TWOS tables
\ -------------------
\ So we know which byte to update, and we also know which bit to set within
\ that byte - it's bit number (x AND %111). We could always fetch that byte and
\ EOR it with 1 shifted by the relevant number of spaces, but Elite chooses a
\ slightly different approach, one which makes it easier for us to plot not only
\ individual pixels, but also two pixels and even blocks of four.
\
\ The are two tables of bytes, one at TWOS and the other at TWOS2, that contain
\ ready-made bytes for plotting one-pixel and two-pixel points. In each table,
\ the byte at offset X contains a byte that, when poked into a character row,
\ will plot a single-pixel at column X (for TWOS) or a two-pixel "dash" at
\ column X (for TWOS2). As one example, this is what's in the fourth entry from
\ each table (i.e. the entry at offset 3):
\
\   TWOS+3  = %00010000
\
\   TWOS2+3 = %00011000
\
\ This is the value we need to EOR with the byte we worked out above, where the
\ offset is the bit number we want to set, i.e. (x AND %111). Or to put it
\ another way, if we set the following:
\
\   SCH = &60 + y >> 3
\   SC = (x >> 3) * 8 + (y AND %111)
\   X = x AND %111
\
\ then we want to fetch this byte:
\
\   TWOS+X
\
\ and poke it here:
\
\   (SCH SC)
\
\ to set the pixel (x, y) on screen. (Or, if we want to set two pixels at this
\ location, we can use TWOS2, and if we wants a 2x2 square of pixels setting,
\ we can do the same again on the row below.)
\
\ And that's the approach used below.
\
\ ******************************************************************************

.PIXEL
{
 STY T1                 \ Store Y in T1

 TAY                    \ Copy A into Y, for use later

 LSR A                  \ Set SCH = &60 + A >> 3
 LSR A
 LSR A
 ORA #%01100000
 STA SCH

 TXA                    \ Set SC = (X >> 3) * 8
 AND #%11111000
 STA SC

 TYA                    \ Set Y = Y AND %111
 AND #%00000111
 TAY

 TXA                    \ Set X = X AND %111
 AND #%00000111
 TAX

 LDA ZZ                 \ If distance in ZZ >= &90, then this point is a very
 CMP #&90               \ long way away, so jump to PX3 to fetch a 1-pixel point
 BCS PX3                \ from TWOS and EOR it into SC+Y

 LDA TWOS2,X            \ Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
 EOR (SC),Y             \ into SC+Y
 STA (SC),Y

 LDA ZZ                 \ If distance in ZZ >= &50, then this point is a medium
 CMP #&50               \ distance away, so jump to PX13 to stop drawing, as a
 BCS PX13               \ 2-pixel dash is enough

                        \ Otherwise we keep going to draw another 2 pixel point
                        \ either above or below the one we just drew, to make a
                        \ 4-pixel square

 DEY                    \ Reduce Y by 1 to point to the pixel row above the one
 BPL PX14               \ we just plotted, and if it is still positive, jump to
                        \ PX14 to draw our second 2-pixel dash

 LDY #1                 \ Reducing Y by 1 made it negative, which means Y was
                        \ 0 before we did the DEY above, so set Y to 1 to point
                        \ to the pixel row after the one we just plotted

.PX14

 LDA TWOS2,X            \ Fetch a 2-pixel dash from TWOS2 and EOR it into this
 EOR (SC),Y             \ second row to make a 4-pixel square
 STA (SC),Y

.PX13

 LDY T1                 \ Restore Y from T1, so Y is preserved by the routine

.^PX4

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: BLINE
\
\ Ball line for Circle2 uses (X.T) as next y offset for arc
\
\ ******************************************************************************

.BLINE                  \ Ball line for Circle2 uses (X.T) as next y offset for arc
{
 TXA
 ADC K4                 \ y0 offset from circle2 is (X,T)
 STA K6+2               \ y2 lo = X + K4 lo
 LDA K4+1
 ADC T
 STA K6+3               \ y2 hi = T + K4 hi

 LDA FLAG               \ set to #&FF at beginning of CIRCLE2
 BEQ BL1                \ flag 0
 INC FLAG

.BL5                    \ counter LSP supplied and updated

 LDY LSP
 LDA #&FF
 CMP LSY2-1,Y
 BEQ BL7                \ end, move K6 to K5
 STA LSY2,Y
 INC LSP
 BNE BL7                \ end, move K6 to K5

.BL1                    \ flag 0 \ Prepare to clip

 LDA K5
 STA XX15               \ x1 lo
 LDA K5+1
 STA XX15+1             \ x1 hi

 LDA K5+2
 STA XX15+2             \ y1 lo
 LDA K5+3
 STA XX15+3             \ y1 hi

 LDA K6
 STA XX15+4             \ x2 lo
 LDA K6+1
 STA XX15+5             \ x2 hi

 LDA K6+2
 STA XX12               \ y2 lo
 LDA K6+3
 STA XX12+1             \ y2 hi

 JSR LL145              \ Clip XX15 XX12 vector
 BCS BL5                \ no line visible, loop LSP
 LDA SWAP
 BEQ BL9                \ skip swap
 LDA X1
 LDY X2
 STA X2
 STY X1
 LDA Y1
 LDY Y2
 STA Y2
 STY Y1

.BL9                    \ swap done

 LDY LSP
 LDA LSY2-1,Y
 CMP #&FF
 BNE BL8                \ skip stores to line buffers
 LDA X1
 STA LSX2,Y
 LDA Y1
 STA LSY2,Y
 INY                    \ LSP+1 other end of line segment

.BL8                    \ skipped stores

 LDA X2
 STA LSX2,Y
 LDA Y2
 STA LSY2,Y
 INY                    \ next LSP
 STY LSP
 JSR LOIN               \ draw line using (X1,Y1), (X2,Y2)

 LDA XX13               \ flag from clip
 BNE BL5                \ loop LSP as XX13 clip

.BL7                    \ end, move K6 to K5, cnt+=stp

 LDA K6
 STA K5
 LDA K6+1
 STA K5+1
 LDA K6+2
 STA K5+2
 LDA K6+3
 STA K5+3
 LDA CNT                \ count
 CLC                    \ cnt += step
 ADC STP                \ step for ring
 STA CNT
 RTS                    \ ball line done
}

\ ******************************************************************************
\
\ Subroutine: FLIP
\
\ Switch dusty and dustx
\
\ ******************************************************************************

.FLIP                   \ switch dusty and dustx
{
\LDA MJ
\BNE FLIP-1
 LDY NOSTM              \ number of dust particles

.FLL1                   \ counter Y

 LDX SY,Y               \ dusty
 LDA SX,Y               \ dustx
 STA Y1
 STA SY,Y               \ dusty
 TXA                    \ old dusty
 STA X1
 STA SX,Y
 LDA SZ,Y
 STA ZZ                 \ dust distance
 JSR PIXEL2             \ dust (X1,Y1) from middle
 DEY                    \ next buffer entry
 BNE FLL1               \ loop Y
 RTS
}

\ ******************************************************************************
\
\ Subroutine: STARS
\
\ Dust Field Enter
\
\ ******************************************************************************

.STARS                  \ Dust Field Enter
{
\LDA #&FF
\STA COL
 LDX VIEW               \ laser mount
 BEQ STARS1             \ Forward Dust
 DEX
 BNE ST11               \ Left or Right dust
 JMP STARS6             \ Rear dust

.ST11                   \ Left or Right dust

 JMP STARS2             \ Left or Right dust

.STARS1                 \ Forward Dust

 LDY NOSTM              \ number of dust particles
}

.STL1                   \ counter Y
{
 JSR DV42               \ P.R = speed/SZ(Y) \ travel step of dust particle front/rear
 LDA R                  \ remainder
 LSR P                  \ hi
 ROR A
 LSR P                  \ hi is now emptied out
 ROR A                  \ remainder
 ORA #1
 STA Q                  \ upper 2 bits above remainder

 LDA SZL,Y              \ dust zlo
 SBC DELT4              \ upper 2 bits are lowest 2 of speed
 STA SZL,Y              \ dust zlo
 LDA SZ,Y               \ dustz
 STA ZZ                 \ old distance
 SBC DELT4+1            \ hi, speed/4, 10 max
 STA SZ,Y               \ dustz

 JSR MLU1               \ Y1 = SY,Y and P.A = Y1 7bit * Q
 STA YY+1
 LDA P                  \ lo
 ADC SYL,Y              \ dust ylo
 STA YY
 STA R                  \ offsetY lo
 LDA Y1                 \ old SY,Y
 ADC YY+1
 STA YY+1
 STA S

 LDA SX,Y               \ dustx
 STA X1
 JSR MLU2               \ P.A = A7bit*Q
 STA XX+1
 LDA P
 ADC SXL,Y              \ dust xlo
 STA XX
 LDA X1
 ADC XX+1
 STA XX+1

 EOR ALP2+1             \ roll sign
 JSR MLS1               \ P.A = A*alp1 (alp1+<32)
 JSR ADD                \ (A X) = (A P) + (S R)
 STA YY+1
 STX YY

 EOR ALP2               \ roll sign
 JSR MLS2               \ R.S = XX(0to1) and P.A = A*alp1 (alp1+<32)
 JSR ADD                \ (A X) = (A P) + (S R)
 STA XX+1
 STX XX

 LDX BET1               \ pitch lower7 bits
 LDA YY+1
 EOR BET2+1             \ flipped pitch sign
 JSR MULTS-2            \ AP=A*bet1 (bet1+<32)
 STA Q
 JSR MUT2               \ S = XX+1, R = XX, A.P=Q*A
 ASL P
 ROL A
 STA T
 LDA #0
 ROR A
 ORA T
 JSR ADD                \ (A X) = (A P) + (S R)
 STA XX+1
 TXA
 STA SXL,Y              \ dust xlo

 LDA YY
 STA R
 LDA YY+1
\JSR MAD
\STA S
\STX R
 STA S                  \ offset for pix1
 LDA #0
 STA P
 LDA BETA
 EOR #128

 JSR PIX1               \ dust, X1 has xscreen. yscreen = R.S+P.A
 LDA XX+1
 STA X1
 STA SX,Y               \ dustx
 AND #127               \ drop sign
 CMP #120
 BCS KILL1              \ kill the forward dust
 LDA YY+1
 STA SY,Y               \ dusty
 STA Y1
 AND #127               \ drop sign
 CMP #120
 BCS KILL1              \ kill the forward dust

 LDA SZ,Y               \ dustz
 CMP #16
 BCC KILL1              \ kill the forward dust
 STA ZZ                 \ old distance
}

.STC1                   \ Re-enter after kill
{
 JSR PIXEL2             \ dust (X1,Y1) from middle
 DEY                    \ next dust particle
 BEQ P%+5               \ rts
 JMP STL1               \ loop Y forward dust
 RTS
}

\ ******************************************************************************
\
\ Subroutine: KILL1
\
\ Kill the forward dust
\
\ ******************************************************************************

.KILL1                  \ kill the forward dust
{
 JSR DORND              \ Set A and X to random numbers
 ORA #4                 \ flick up/down
 STA Y1                 \ ydistance from middle
 STA SY,Y               \ dusty
 JSR DORND              \ Set A and X to random numbers
 ORA #8                 \ flick left/right
 STA X1
 STA SX,Y               \ dustx
 JSR DORND              \ Set A and X to random numbers
 ORA #&90               \ flick distance
 STA SZ,Y               \ dustz
 STA ZZ                 \ old distance
 LDA Y1                 \ ydistance from middle
 JMP STC1               \ guaranteed, Re-enter forward dust loop
}

\ ******************************************************************************
\
\ Subroutine: STARS6
\
\ Rear dust
\
\ ******************************************************************************

.STARS6                 \ Rear dust
{
 LDY NOSTM              \ number of dust particles
}

.STL6                   \ counter Y
{
 JSR DV42               \ travel step of dust particle front/rear
 LDA R                  \ remainder
 LSR P                  \ hi
 ROR A
 LSR P                  \ hi is now emptied out
 ROR A
 ORA #1
 STA Q                  \ upper 2 bits above remainder

 LDA SX,Y               \ dustx
 STA X1
 JSR MLU2               \ P.A = A7bit*Q
 STA XX+1
 LDA SXL,Y              \ dust xlo
 SBC P
 STA XX
 LDA X1
 SBC XX+1
 STA XX+1

 JSR MLU1               \ Y1 = SY,Y and P.A = Y1 7bit * Q
 STA YY+1
 LDA SYL,Y              \ dust ylo
 SBC P
 STA YY
 STA R
 LDA Y1
 SBC YY+1
 STA YY+1
 STA S

 LDA SZL,Y              \ dust zlo
 ADC DELT4              \ upper 2 bits are lowest 2 of speed
 STA SZL,Y              \ dust zlo
 LDA SZ,Y               \ dustz
 STA ZZ                 \ old distance
 ADC DELT4+1            \ hi, speed/4, 10 max
 STA SZ,Y               \ dustz

 LDA XX+1
 EOR ALP2               \ roll sign
 JSR MLS1               \ P.A = A*alp1 (alp1+<32)
 JSR ADD                \ (A X) = (A P) + (S R)
 STA YY+1
 STX YY

 EOR ALP2+1             \ flipped roll sign
 JSR MLS2               \ R.S = XX(0to1) and P.A = A*alp1 (alp1+<32)
 JSR ADD                \ (A X) = (A P) + (S R)
 STA XX+1
 STX XX

 LDA YY+1
 EOR BET2+1             \ flipped pitch sign
 LDX BET1               \ pitch lower7 bits
 JSR MULTS-2            \ AP=A*bet1 (bet1+<32)
 STA Q
 LDA XX+1
 STA S
 EOR #128
 JSR MUT1               \ R = XX, A.P=Q*A
 ASL P
 ROL A
 STA T
 LDA #0
 ROR A
 ORA T
 JSR ADD                \ (A X) = (A P) + (S R)
 STA XX+1
 TXA
 STA SXL,Y              \ dust xlo

 LDA YY
 STA R
 LDA YY+1
 STA S                  \ offset for pix1
\EOR #128
\JSR MAD
\STA S
\STX R
 LDA #0
 STA P
 LDA BETA

 JSR PIX1               \ dust, X1 has xscreen. yscreen = R.S+P.A
 LDA XX+1
 STA X1
 STA SX,Y               \ dustx
 LDA YY+1
 STA SY,Y               \ dusty
 STA Y1
 AND #127               \ ignore sign
 CMP #110
 BCS KILL6              \ rear dust kill

 LDA SZ,Y               \ dustz
 CMP #160
 BCS KILL6              \ rear dust kill
 STA ZZ                 \ old distance
}

.STC6                   \ Re-enter after kill
{
 JSR PIXEL2             \ dust (X1,Y1) from middle
 DEY
 BEQ ST3                \ rts
 JMP STL6               \ loop Y rear dust

.ST3                    \ rts

 RTS
}

\ ******************************************************************************
\
\ Subroutine: KILL6
\
\ Rear dust kill
\
\ ******************************************************************************

.KILL6                  \ rear dust kill
{
 JSR DORND              \ Set A and X to random numbers
 AND #127
 ADC #10
 STA SZ,Y               \ dustz
 STA ZZ                 \ old distance
 LSR A                  \ get carry
 BCS ST4                \ half of the new dust
 LSR A
 LDA #&FC               \ new dustx at edges
 ROR A                  \ may get a carry
 STA X1
 STA SX,Y               \ dustx
 JSR DORND              \ Set A and X to random numbers
 STA Y1
 STA SY,Y               \ dusty
 JMP STC6               \ Re-enter rear dust loop

.ST4                    \ half of the new dust

 JSR DORND              \ Set A and X to random numbers
 STA X1
 STA SX,Y               \ dustx
 LSR A                  \ get carry
 LDA #230               \ new dusty at edges
 ROR A
 STA Y1
 STA SY,Y               \ dusty
 BNE STC6               \ guaranteed, Re-enter rear loop
}

\ ******************************************************************************
\
\ Variable: PRXS
\
\ Equipment prices.
\
\ ******************************************************************************

.PRXS
{
 EQUW 1                 \ 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
 EQUW 300               \ 1  Missile                     30.0 Cr
 EQUW 4000              \ 2  Large Cargo Bay            400.0 Cr
 EQUW 6000              \ 3  E.C.M. System              600.0 Cr
 EQUW 4000              \ 4  Extra Pulse Lasers         400.0 Cr
 EQUW 10000             \ 5  Extra Beam Lasers         1000.0 Cr
 EQUW 5250              \ 6  Fuel Scoops                525.0 Cr
 EQUW 10000             \ 7  Escape Pod                1000.0 Cr
 EQUW 9000              \ 8  Energy Bomb                900.0 Cr
 EQUW 15000             \ 9  Energy Unit               1500.0 Cr
 EQUW 10000             \ 10 Docking Computer          1000.0 Cr
 EQUW 50000             \ 11 Galactic Hyperspace       5000.0 Cr
}

\ ******************************************************************************
\
\ Subroutine: STATUS
\
\ Show the Status Mode screen (red key f8).
\
\ ******************************************************************************

{
.st4                    \ We call this from st5 below with the high byte of the
                        \ kill tally in A, which is non-zero, and want to return
                        \ with the following in X, depending on our rating:
                        \
                        \ Competent = 6
                        \ Dangerous = 7
                        \ Deadly    = 8
                        \ Elite     = 9
                        \
                        \ The high bytes of the top tier ratings are as follows,
                        \ so this a relatively simple calculation:
                        \
                        \ Competent       = 1 to 2
                        \ Dangerous       = 2 to 9
                        \ Deadly          = 10 to 24
                        \ Elite           = 25 and up

 LDX #9                 \ Set X to 9 for an Elite rating

 CMP #25                \ If A >= 25, jump to st3 to print out our rating, as we
 BCS st3                \ are Elite

 DEX                    \ Decrement X to 8 for a Deadly rating

 CMP #10                \ If A >= 10, jump to st3 to print out our rating, as we
 BCS st3                \ are Deadly

 DEX                    \ Decrement X to 7 for a Dangerous rating

 CMP #2                 \ If A >= 2, jump to st3 to print out our rating, as we
 BCS st3                \ are Dangerous

 DEX                    \ Decrement X to 6 for a Competant rating

 BNE st3                \ Jump to st3 to print out our rating, as we are
                        \ Competent (this BNE is effectively a JMP as A will
                        \ never be zero)

.^STATUS

 LDA #8                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 8 (Status
                        \ Mode screen)

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 LDA #126               \ Print recursive token 126, which prints the top
 JSR NLIN3              \ four lines of the Status Mode screen:
                        \
                        \         COMMANDER {commander name}
                        \
                        \
                        \   Present System      : {current system name}
                        \   Hyperspace System   : {selected system name}
                        \   Condition           :
                        \
                        \ and draw a horizontal line at pixel row 19 to box
                        \ in the title

 LDA #15                \ Set A to token 129 ("{switch to sentence case}
                        \ DOCKED")

 LDY QQ12               \ Fetch the docked status from QQ12, and if we are
 BNE st6                \ docked, jump to st6 to print "Docked" for our
                        \ ship's condition

 LDA #230               \ Otherwise we are in space, so start off by setting A
                        \ to token 70 ("GREEN")

 LDY MANY+AST           \ Set Y to the number of asteroids in our little bubble
                        \ of universe

 LDX FRIN+2,Y           \ The ship slots at FRIN are ordered with the first two
                        \ slots reserved for the planet and sun/space station,
                        \ and then any ships, so if the slot at FRIN+2+Y is not
                        \ empty (i.e is non-zero), then that means the number of
                        \ non-asteroids in the vicinity is at least 1

 BEQ st6                \ So if X = 0, there are no ships in the vicinity, so
                        \ jump to st6 to print "Green" for our ship's condition

 LDY ENERGY             \ Otherwise we have ships in the vicinity, so we load
                        \ our energy levels into Y

 CPY #128               \ Set the C flag if Y >= 128, so C is set if we have
                        \ more than half of our energy banks charged

 ADC #1                 \ Add 1 + C to A, so if C is not set (i.e. we have low
                        \ energy levels) then A is set to token 231 ("RED"),
                        \ and if C is set (i.e. we have healthy energy levels)
                        \ then A is set to token 232 ("YELLOW")

.st6

 JSR plf                \ Print the text token in A (which contains our ship's
                        \ condition) followed by a newline

 LDA #125               \ Print recursive token 125, which prints the next
 JSR spc                \ three lines of the Status Mode screen:
                        \
                        \   Fuel: {fuel level} Light Years
                        \   Cash: {cash right-aligned to width 9} Cr
                        \   Legal Status:
                        \
                        \ followed by a space

 LDA #19                \ Set A to token 133 ("CLEAN")

 LDY FIST               \ Fetch our legal status, and if it is 0, we are clean,
 BEQ st5                \ so jump to st5 to print "Clean"

 CPY #50                \ Set the C flag if Y >= 50, so C is set if we have
                        \ a legal status of 50+ (i.e. we are a fugitive)

 ADC #1                 \ Add 1 + C to A, so if C is not set (i.e. we have a
                        \ legal status between 1 and 49) then A is set to token
                        \ 134 ("OFFENDER"), and if C is set (i.e. we have a
                        \ legal status of 50+) then A is set to token 135
                        \ ("FUGITIVE")

.st5

 JSR plf                \ Print the text token in A (which contains our legal
                        \ status) followed by a newline

 LDA #16                \ Print recursive token 130 ("RATING:")
 JSR spc

 LDA TALLY+1            \ Fetch the high byte of the kill tally, and if it is
 BNE st4                \ not zero, then we have more than 256 kills, so jump
                        \ to st4 to work out whether we are Competent,
                        \ Dangerous, Deadly or Elite

                        \ Otherwise we have fewer than 256 kills, so we are one
                        \ of Harmless, Mostly Harmless, Poor, Average or Above
                        \ Average

 TAX                    \ Set X to 0 (as A is 0)

 LDA TALLY              \ Set A = lower byte of tally / 4
 LSR A
 LSR A

.st5L                   \ We now loop through bits 2 to 7, shifting each of them
                        \ off the end of A until there are no set bits left, and
                        \ incrementing X for each shift, so at the end of the
                        \ process, X contains the position of the leftmost 1 in
                        \ A. Looking at the rank values in TALLY:
                        \
                        \   Harmless        = %0000 0000 to %0000 0011
                        \   Mostly Harmless = %0000 0100 to %0000 0111
                        \   Poor            = %0000 1000 to %0000 1111
                        \   Average         = %0001 0000 to %0001 1111
                        \   Above Average   = %0010 0000 to %1111 1111
                        \
                        \ we can see that the values returned by this process
                        \ are:
                        \
                        \   Harmless        = 1
                        \   Mostly Harmless = 2
                        \   Poor            = 3
                        \   Average         = 4
                        \   Above Average   = 5

 INX                    \ Increment X for each shift

 LSR A                  \ Shift A to the right

 BNE st5L               \ Keep looping around until A = 0, which means there are
                        \ no set bits left in A
.st3

 TXA                    \ A now contains our rating as a value of 1 to 9, so
                        \ transfer X to A, so we can print it out

 CLC                    \ Print recursive token 135 + A, which will be in the
 ADC #21                \ range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
 JSR plf                \ followed by a newline

 LDA #18                \ Print recursive token 132, which prints the next bit
 JSR plf2               \ of the Status Mode screen:
                        \
                        \   EQUIPMENT:
                        \
                        \ followed by a newline and an indent of 6 characters

 LDA CRGO               \ If our ship's cargo capacity is < 26 (i.e. we do not
 CMP #26                \ have a cargo bay extension), skip the following two
 BCC P%+7               \ instructions

 LDA #107               \ We do have a cargo bay extension, so print recursive
 JSR plf2               \ token 107 ("LARGE CARGO{switch to sentence case}
                        \ BAY"), followed by a newline and an indent of 6
                        \ characters

 LDA BST                \ If we don't have fuel scoops fitted, skip the
 BEQ P%+7               \ following two instructions

 LDA #111               \ We do have a fuel scoops fitted, so print recursive
 JSR plf2               \ token 111 ("FUEL SCOOPS"), followed by a newline and
                        \ an indent of 6 characters

 LDA ECM                \ If we don't have an E.C.M. fitted, skip the following
 BEQ P%+7               \ two instructions

 LDA #108               \ We do have an E.C.M. fitted, so print recursive token
 JSR plf2               \ 108 ("E.C.M.SYSTEM"), followed by a newline and an
                        \ indent of 6 characters

 LDA #113               \ We now cover the four pieces of equipment whose flags
 STA XX4                \ are stored in BOMB through BOMB+3, and whose names
                        \ correspond with text tokens 113 through 116:
                        \
                        \   BOMB+0 = BOMB  = token 113 = Energy bomb
                        \   BOMB+1 = ENGY  = token 114 = Energy unit
                        \   BOMB+2 = DKCMP = token 115 = Docking computer
                        \   BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
                        \
                        \ We can print these out using a loop, so we set XX4 to
                        \ 113 as a counter (and we also set A as well, to pass
                        \ through to plf2)

.stqv

 TAY                    \ Fetch byte BOMB+0 through BOMB+4 for values of XX4
 LDX BOMB-113,Y         \ from 113 through 117

 BEQ P%+5               \ If it is zero then we do not own that piece of
                        \ equipment, so skip the next instruction

 JSR plf2               \ Print the recursive token in A from 113 ("ENERGY
                        \ BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
                        \ by a newline and an indent of 6 characters

 INC XX4                \ Increment the counter (and A as well)
 LDA XX4

 CMP #117               \ If A < 117, loop back up to stqv to print the next
 BCC stqv               \ piece of equipment

 LDX #0                 \ Now to print our ship's lasers, so set a counter in X
                        \ to count through the four laser mounts (0 = front,
                        \ 1 = rear, 2 = left, 3 = right)

.st

 STX CNT                \ Store the laser mount number in CNT

 LDY LASER,X            \ Fetch the laser power for laser mount X, and if we do
 BEQ st1                \ not have a laser fitted to that view, jump to st1 to
                        \ move on to the next one

 TXA                    \ Print recursive token 96 + X, which will print from 96
 CLC                    \ ("FRONT") through to 99 ("RIGHT"), follwed by a space
 ADC #96
 JSR spc

 LDA #103               \ Set A to token 103 ("PULSE LASER")

 LDX CNT                \ If the laser power for laser mount X has bit 7 clear,
 LDY LASER,X            \ it is a pulse laser, so skip the following instruction
 BPL P%+4

 LDA #104               \ Set A to token 104 ("BEAM LASER")

 JSR plf2               \ Print the text token in A (which contains our legal
                        \ status) followed by a newline and an indent of 6
                        \ characters

.st1

 LDX CNT                \ Increment the counter in X and CNT to point to the
 INX                    \ next laser mount

 CPX #4                 \ If this isn't the last of the four laser mounts, jump
 BCC st                 \ back up to st to print out the next one

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: plf2
\
\ Print a text token followed by a newline, and indent the next line to text
\ column 6.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.plf2
{

 JSR plf                \ Print the text token in A followed by a newline

 LDX #6                 \ Set the text cursor to column 6
 STX XC

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Variable: TENS
\
\ Contains the four low bytes of the value 100,000,000,000 (100 billion).
\
\ The maximum number of digits that we can print with the the BPRNT routine
\ below is 11, so the biggest number we can print is 99,999,999,999. This
\ maximum number plus 1 is 100,000,000,000, which in hexadecimal is:
\
\   & 17 48 76 E8 00
\
\ The TENS variable contains the lowest four bytes in this number, with the
\ least significant byte first, i.e. 00 E8 76 48. This value is used in the
\ BPRNT routine when working out which decimal digits to print when printing a
\ number.
\
\ ******************************************************************************

.TENS
{
 EQUD &00E87648
}

\ ******************************************************************************
\
\ Subroutine: pr2
\
\ Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
\ with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
\ include a decimal point.
\
\ Arguments:
\
\   X                   The number to print
\
\   C flag              If set, include a decimal point
\
\ ******************************************************************************

.pr2
{
 LDA #3                 \ Set A to the number of digits (3)

 LDY #0                 \ Zero the Y register, so we can fall through into TT11
                        \ to print the 16-bit number (Y X) to 3 digits, which
                        \ effectively prints X to 3 digits as the high byte is
                        \ zero
}

\ ******************************************************************************
\
\ Subroutine: TT11
\
\ Print the 16-bit number in (Y X) to a specific number of digits, left-padding
\ with spaces for numbers with fewer digits (so lower numbers will be right-
\ aligned). Optionally include a decimal point.
\
\ Arguments:
\
\   X                   The low byte of the number to print
\
\   Y                   The high byte of the number to print
\
\   A                   The number of digits
\
\   C flag              If set, include a decimal point
\
\ ******************************************************************************

.TT11
{
 STA U                  \ We are going to use the BPRNT routine (below) to
                        \ print this number, so we store the number of digits
                        \ in U, as that's what BPRNT takes as an argument

 LDA #0                 \ BPRNT takes a 32-bit number in K to K+3, with the
 STA K                  \ most significant byte first (big-endian), so we set
 STA K+1                \ the two most significant bytes to zero (K and K+1)
 STY K+2                \ and store (Y X) in the least two significant bytes
 STX K+3                \ (K+2 and K+3), so we are going to print the 32-bit
                        \ number (0 0 Y X)

                        \ Finally we fall through into BPRNT to print out the
                        \ number in K to K+3, which now contains (Y X), to 3
                        \ digits (as U = 3), using the same carry flag as when
                        \ pr2 was called to control the decimal point
}

\ ******************************************************************************
\
\ Subroutine: BPRNT
\
\ Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
\ left-padding with spaces for numbers with fewer digits (so lower numbers are
\ right-aligned). Optionally include a decimal point.
\
\ Arguments:
\
\   K(0 1 2 3)          The number to print, stored with the most significant
\                       byte in K and the least significant in K+3 (big-endian,
\                       which is not the same way that 6502 assembler stores
\                       addresses)
\
\   U                   The maximum number of digits to print, including the
\                       decimal point (spaces will be used on the left to pad
\                       out the result to this width, so the number is right-
\                       aligned to this width). The maximum number of characters
\                       including any decimal point must be 11 or less
\
\   C flag              If set, include a decimal point followed by one
\                       fractional digit (i.e. show the number to 1 decimal
\                       place). In this case, the number in K to K+3 contains
\                       10 * the number we end up printing, so to print 123.4,
\                       we would pass 1234 in K to K+3 and would set the C flag
\
\ ******************************************************************************
\
\ Deep dive: Printing huge numbers
\ --------------------------------
\ The algorithm is relatively simple, but it looks fairly complicated because
\ we're dealing with 32-bit numbers.
\
\ To see how it works, let's first consider a simple example with fewer digits.
\ Let's say we want to print out the following number to three digits:
\
\   567
\
\ First we subtract 100 repeatedly until we can't do it any more, counting how
\ many times we can do this:
\
\   567 - 100 - 100 - 100 - 100 - 100 = 67
\
\ Not surprisingly, we can subtract it 5 times, so our first digit is 5. Now we
\ multiply the remaining number by 10 to get 670, and repeat the process:
\
\   670 - 100 - 100 - 100 - 100 - 100 - 100 = 70
\
\ We subtracted 100 6 times, so the second digit is 6. Now to multiply by 10
\ again to get 700 and repeat the process:
\
\   700 - 100 - 100 - 100 - 100 - 100 - 100 - 100 = 0
\
\ So the third digit is 7 and we are done.
\
\ The BPRNT subroutine code does exactly this in its main loop at TT36, except
\ instead of having a three-digit number and subtracting 100, we have up to an
\ 11-digit number and subtract 10 billion each time (as 10 billion has 11
\ digits), using 32-bit arithmetic and an overflow byte, and that's where
\ the complexity comes in.
\
\ Let's look at the above algorithm in more detail. We need to implement it with
\ multi-byte subtraction, which we can do byte-by-byte using the carry flag,
\ but we also need to be able to multiply a multi-byte number by 10, which is
\ slightly trickier. Multiplying by 10 isn't directly supported the 6502, but
\ multiplying by 2 is, in the guise of shifting and rotating left, so we can do
\ this to multiply K by 10:
\
\   K * 10 = K * (2 + 8)
\          = (K * 2) + (K * 8)
\          = (K * 2) + (K * 2 * 2 * 2)
\
\ And that's what we do in the TT35 subroutine below, just with 32-bit
\ numbers with an 8-bit overflow. This doubling process is used quite a few
\ times in the following, so let's look an an example, in which we double the
\ number in K(S 0 1 2 3):
\
\   ASL K+3
\   ROL K+2
\   ROL K+1
\   ROL K
\   ROL S
\
\ First we use ASL K+3 to shift the least significant byte left (so bit 7 goes
\ to the carry flag). Then we rotate the next most significant byte with ROL
\ K+2 (so the carry flag goes into bit 0 and bit 7 goes into the carry), and we
\ repeat this with each byte in turn, until we get to the overflow byte S. This
\ has the effect of shifting the entire five-byte number one place to the left,
\ which doubles it in-place.
\
\ Finally, there are three variables that are used as counters in the above
\ loop, each of which gets decremented as we go work our way through the
\ digits. Their starting values are:
\
\   XX17   The maximum number of characters to print in total (this is
\          hard-coded to 11)
\
\   T      The maximum number of digits that we might end up printing (11 if
\          there's no decimal point, 10 otherwise)
\
\   U      The loop number at which we should start printing digits or spaces
\          (calculated from the U argument to BPRNT)
\
\ We do the loop XX11 times, once for each character that we might print. We
\ start printing characters once we reach loop number U (at which point we
\ print a space if there isn't a digit at that point, otherwise we print the
\ calculated digit). As soon as we have printed our first digit we set T to 0
\ to indicate that we should print characters for all subsequent loops, so T is
\ effectively a flag for denoting that we're switching from spaces to zeroes
\ for zero values, and decrementing T ensures that we always have at least one
\ digit in the number, even if it's a zero.
\
\ ******************************************************************************

.BPRNT
{
 LDX #11                \ Set T to the maximum number of digits allowed (11
 STX T                  \ characters, which is the number of digits in 10
                        \ billion); we will use this as a flag when printing
                        \ characters in TT37 below

 PHP                    \ Make a copy of the status register (in particular
                        \ the carry flag) so we can retrieve it later

 BCC TT30               \ If the carry flag is clear, we do not want to print a
                        \ decimal point, so skip the next two instructions

 DEC T                  \ As we are going to show a decimal point, decrement
 DEC U                  \ both the number of characters and the number of
                        \ digits (as one of them is now a decimal point)

.TT30

 LDA #11                \ Set A to 11, the maximum number of digits allowed

 SEC                    \ Set the carry flag so we can do subtraction without
                        \ the carry flag affecting the result

 STA XX17               \ Store the maximum number of digits allowed (11) in
                        \ XX17

 SBC U                  \ Set U = 11 - U + 1, so U now contains the maximum
 STA U                  \ number of digits minus the number of digits we want
 INC U                  \ to display, plus 1 (so this is the number of digits
                        \ we should skip before starting to print the number
                        \ itself, and the plus 1 is there to ensure we at least
                        \ print one digit)

 LDY #0                 \ In the main loop below, we use Y to count the number
                        \ of times we subtract 10 billion to get the left-most
                        \ digit, so set this to zero (see below TT36 for an
                        \ of how this algorithm works)

 STY S                  \ In the main loop below, we use location S as an
                        \ 8-bit overflow for the 32-bit calculations, so
                        \ we need to set this to 0 before joining the loop

 JMP TT36               \ Jump to TT36 to start the process of printing this
                        \ number's digits

.TT35                   \ This subroutine multiplies K(S 0 1 2 3) by 10 and
                        \ stores the result back in K(S 0 1 2 3), using the
                        \ (K * 2) + (K * 2 * 2 * 2) approach described above

 ASL K+3                \ Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
 ROL K+2
 ROL K+1
 ROL K
 ROL S

 LDX #3                 \ Now we want to make a copy of the newly doubled K in
                        \ XX15, so we can use it for the first (K * 2) in the
                        \ equation above, so set up a counter in X for copying
                        \ four bytes, starting with the last byte in memory
                        \ (i.e. the least significant)

.tt35

 LDA K,X                \ Copy the X-th byte of K(0 1 2 3) to the X-th byte of
 STA XX15,X             \ XX15(0 1 2 3), so that XX15 will contain a copy of
                        \ K(0 1 2 3) once we've copied all four bytes

 DEX                    \ Decrement the loop counter so we move to the next
                        \ byte, going from least significant (3) to most
                        \ significant (0)

 BPL tt35               \ Loop back to copy the next byte

 LDA S                  \ Store the value of location S, our overflow byte, in
 STA XX15+4             \ XX15+4, so now XX15(4 0 1 2 3) contains a copy of
                        \ K(S 0 1 2 3), which is the value of (K * 2) that we
                        \ want

 ASL K+3                \ Now to calculate the (K * 2 * 2 * 2) part. We still
 ROL K+2                \ have (K * 2) in K(S 0 1 2 3), so we just need to
 ROL K+1                \ it twice. This is the first one, so we do
 ROL K                  \ K(S 0 1 2 3) = K(S 0 1 2 3) * 2 (i.e. K * 4)
 ROL S

 ASL K+3                \ And then we do it again, so that means
 ROL K+2                \ K(S 0 1 2 3) = K(S 0 1 2 3) * 2 (i.e. K * 8)
 ROL K+1
 ROL K
 ROL S

 CLC                    \ Clear the carry flag so we can do addition without
                        \ the carry flag affecting the result

 LDX #3                 \ By now we've got (K * 2) in XX15(4 0 1 2 3) and
                        \ (K * 8) in K(S 0 1 2 3), so the final step is to add
                        \ these two 32-bit numbers together to get K * 10.
                        \ So we set a counter in X for four bytes, starting
                        \ with the last byte in memory (i.e. the least
                        \ significant)

.tt36

 LDA K,X                \ Fetch the X-th byte of K into A

 ADC XX15,X             \ Add the X-th byte of XX15 to A, with carry

 STA K,X                \ Store the result in the X-th byte of K

 DEX                    \ Decrement the loop counter so we move to the next
                        \ byte, going from least significant (3) to most
                        \ significant (0)

 BPL tt36               \ Loop back to add the next byte

 LDA XX15+4             \ Finally, fetch the overflow byte from XX15(4 0 1 2 3)

 ADC S                  \ And add it to the overflow byte from K(S 0 1 2 3),
                        \ with carry

 STA S                  \ And store the result in the overflow byte from
                        \ K(S 0 1 2 3), so now we have our desired result that
                        \ K(S 0 1 2 3) is now K(S 0 1 2 3) * 10

 LDY #0                 \ In the main loop below, we use Y to count the number
                        \ of times we subtract 10 billion to get the left-most
                        \ digit, so set this to zero

.TT36                   \ This is the main loop of our digit-printing routine.
                        \ In the following loop, we are going to count the
                        \ number of times that we can subtract 10 million in Y,
                        \ which we have already set to 0

 LDX #3                 \ Our first calculation concerns 32-bit numbers, so
                        \ set up a counter for a four-byte loop

 SEC                    \ Set the carry flag so we can do subtraction without
                        \ the carry flag affecting the result

.tt37                   \ Now we loop thorough each byte in turn to do this:

                        \
                        \ XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000

 LDA K,X                \ Subtract the X-th byte of TENS (i.e. 10 billion) from
 SBC TENS,X             \ the X-th byte of K

 STA XX15,X             \ Store the result in the X-th byte of XX15

 DEX                    \ Decrement the loop counter so we move to the next
                        \ byte, going from least significant (3) to most
                        \ significant (0)

 BPL tt37               \ Loop back to subtract from the next byte

 LDA S                  \ Subtract the fifth byte of 10 billion (i.e. &17) from
 SBC #&17               \ the fifth (overflow) byte of K, which is S

 STA XX15+4             \ Store the result in the overflow byte of XX15

 BCC TT37               \ If subtracting 10 billion took us below zero, jump to
                        \ TT37 to print out this digit, which is now in Y

 LDX #3                 \ We now want to copy XX15(4 0 1 2 3) back to
                        \ K(S 0 1 2 3), so we can loop back up to do the next
                        \ subtraction, so set up a counter for a four-byte loop

.tt38

 LDA XX15,X             \ Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
 STA K,X                \ of K(0 1 2 3), so that K will contain a copy of
                        \ XX15(0 1 2 3) once we've copied all four bytes

 DEX                    \ Decrement the loop counter so we move to the next
                        \ byte, going from least significant (3) to most
                        \ significant (0)

 BPL tt38               \ Loop back to copy the next byte

 LDA XX15+4             \ Store the value of location XX15+4, our overflow
 STA S                  \ byte in S, so now K(S 0 1 2 3) contains a copy of
                        \ XX15(4 0 1 2 3)

 INY                    \ We have now managed to subtract 10 billion from our
                        \ number, so increment Y, which is where we are keeping
                        \ count of the number of subtractions so far

 JMP TT36               \ Jump back to TT36 to subtract the next 10 billion

.TT37

 TYA                    \ If we get here then Y contains the digit that we want
                        \ to print (as Y has now counted the total number of
                        \ subtractions of 10 billion), so transfer Y into A

 BNE TT32               \ If the digit is non-zero, jump to TT32 to print it

 LDA T                  \ Otherwise the digit is zero. If we are already
                        \ printing the number then we will want to print a 0,
                        \ but if we haven't started printing the number yet,
                        \ then we probbaly don't, as we don't want to print
                        \ leading zeroes unless this is the only digit before
                        \ the decimal point
                        \
                        \ To help with this, we are going to use T as a flag
                        \ that tells us whether we have already started
                        \ printing digits:
                        \
                        \   If T <> 0 we haven't printed anything yet
                        \   If T = 0 then we have started printing digits
                        \
                        \ We initially set T to the maximum number of
                        \ characters allowed at, less 1 if we are printing a
                        \ decimal point, so the first time we enter the digit
                        \ printing routine at TT37, it is definitely non-zero

 BEQ TT32               \ If T = 0, jump straight to the print routine at TT32,
                        \ as we have already started printing the number, so we
                        \ definitely want to print this digit too

 DEC U                  \ We initially set U to the number of digits we want to
 BPL TT34               \ skip before starting to print the number. If we get
                        \ here then we haven't printed any digits yet, so
                        \ decrement U to see if we have reached the point where
                        \ we should start printing the number, and if not, jump
                        \ to TT34 to set up things for the next digit

 LDA #' '               \ We haven't started printing any digits yet, but we
 BNE tt34               \ have reached the point where we should start printing
                        \ our number, so call TT26 (via tt34) to print a space
                        \ so that the number is left-padded with spaces (this
                        \ BNE is effectively a JMP as A will never be zero)

.TT32

 LDY #0                 \ We are printing an actual digit, so first set T to 0,
 STY T                  \ to denote that we have now started printing digits as
                        \ opposed to spaces

 CLC                    \ The digit value is in A, so add ASCII "0" to get the
 ADC #'0'               \ ASCII character number to print

.tt34

 JSR TT26               \ Print the character in A and fall through into TT34
                        \ to get things ready for the next digit

.TT34

 DEC T                  \ Decrement T but keep T >= 0 (by incrementing it
 BPL P%+4               \ again if the above decrement made T negative)
 INC T

 DEC XX17               \ Decrement the total number of characters to print in
                        \ XX17

 BMI RR3+1              \ If it is negative, we have printed all the characters
                        \ so return from the subroutine (as RR3 contains an
                        \ ORA #&60 instruction, so RR3+1 is &60, which is the
                        \ opcode for an RTS)

 BNE P%+10              \ If it is positive (> 0) loop back to TT35 (via the
                        \ last instruction in this subroutine) to print the
                        \ next digit

 PLP                    \ If we get here then we have printed the exact number
                        \ of digits that we wanted to, so restore the carry
                        \ flag that we stored at the start of BPRNT

 BCC P%+7               \ If carry is clear, we don't want a decimal point, so
                        \ look back to TT35 (via the last instruction in this
                        \ subroutine) to print the next digit

 LDA #'.'               \ Print the decimal point
 JSR TT26

 JMP TT35               \ Loop back to TT35 to print the next digit
}

\ ******************************************************************************
\
\ Subroutine: BELL
\
\ Make a beep sound.
\
\ ******************************************************************************

.BELL
{
 LDA #7                 \ Control code 7 makes a beep, so load this into A so
                        \ we can fall through into the TT27 print routine to
                        \ actually make the sound
}

\ ******************************************************************************
\
\ Subroutine: TT26
\
\ Print a character at the text cursor (XC, YC), do a beep, print a newline,
\ or delete left (backspace).
\
\ WRCHV is set to point here by elite-loader.asm.
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\                         * 127 (delete the character to the left of the text
\                           cursor and move the cursor to the left)
\
\   XC                  Contains the text column to print at (the x-coordinate)
\
\   YC                  Contains the line number to print on (the y-coordinate)
\
\ Returns:
\
\   A                   A is preserved
\
\   X                   X is preserved
\
\   Y                   Y is preserved
\
\   C flag              Carry is cleared
\
\ Other entry points:
\
\   RR3+1               Contains an RTS
\
\   RREN                Prints the character definition pointed to by P(2 1) at
\                       the screen address pointed to by (A SC). Used by the
\                       BULB routine
\
\   rT9                 Contains an RTS
\
\ ******************************************************************************

.TT26
{
 STA K3                 \ Store the A, X and Y registers, so we can restore
 STY YSAV2              \ them at the end (so they don't get changed by this
 STX XSAV2              \ routine)

 LDY QQ17               \ Load the QQ17 flag, which contains the text printing
                        \ flags

 CPY #&FF               \ If QQ17 = #&FF, then jump to RR4, which doesn't print
 BEQ RR4                \ anything, it just restore of the registers and
                        \ returns from the subroutine

 CMP #7                 \ If this is a beep character (A = 7), jump to R5,
 BEQ R5                 \ which will emit the beep, restore the registers and
                        \ return from the subroutine

 CMP #32                \ If this is an ASCII character (A >= 32), jump to RR1
 BCS RR1                \ below, which will print the character, restore the
                        \ registers and return from the subroutine

 CMP #10                \ If this is control code 10 (line feed) then jump to
 BEQ RRX1               \ RRX1, which will move down a line, restore the
                        \ registers and return from the subroutine

 LDX #1                 \ If we get here, then this is control code 11-13, of
 STX XC                 \ which only 13 is used. This code prints a newline,
                        \ which we can achieve by moving the text cursor
                        \ to the start of the line (carriage return) and down
                        \ one line (line feed). These two lines do the first
                        \ bit by setting XC = 1, and we then fall through into
                        \ the line feed routine that's used by control code 10

.RRX1

 INC YC                 \ Print a line feed, simply by incrementing the row
                        \ number (y-coordinate) of the text cursor, which is
                        \ stored in YC

 BNE RR4                \ Jump to RR4 to restore the registers and return from
                        \ the subroutine (this BNE is effectively a JMP as Y
                        \ will never be zero)

.RR1                    \ If we get here, then the character to print is an
                        \ ASCII character in the range 32-95. The quickest way
                        \ to display text on screen is to poke the character
                        \ pixel by pixel, directly into screen memory, so
                        \ that's what the rest of this routine does
                        \
                        \ The first step, then, is to get hold of the bitmap
                        \ definition for the character we want to draw on the
                        \ screen (i.e. we need the pixel shape of this
                        \ character). The OS ROM contains bitmap definitions
                        \ of the BBC's ASCII characters, starting from &C000
                        \ for space (ASCII 32) and ending with the  symbol
                        \ (ASCII 126)
                        \
                        \ There are 32 characters' definitions in each page of
                        \ memory, as each definition takes up 8 bytes (8 rows
                        \ of 8 pixels) and 32 * 8 = 256 bytes = 1 page. So:
                        \
                        \   ASCII 32-63  are defined in &C000-&C0FF (page &C0)
                        \   ASCII 64-95  are defined in &C100-&C1FF (page &C1)
                        \   ASCII 96-126 are defined in &C200-&C2F0 (page &C2)
                        \
                        \ The following code reads the relevant character
                        \ bitmap from the above locations in ROM and pokes
                        \ those values into the correct position in screen
                        \ memory, thus printing the character on screen
                        \
                        \ It's a long way from 10 PRINT "Hello world!":GOTO 10

\LDX #LO(K3)            \ These instructions are commented out in the original
\INX                    \ source, but they call OSWORD &A, which reads the
\STX P+1                \ character bitmap for the character number in K3 and
\DEX                    \ stores it in the block at K3+1, while also setting
\LDY #HI(K3)            \ P+1 to point to the character definition. This is
\STY P+2                \ exactly what the following uncommented code does,
\LDA #10                \ just without calling OSWORD. Presumably the code
\JSR OSWORD             \ below is faster than using the system call, as this
                        \ version takes up 15 bytes, while the version below
                        \ (which ends with STA P+1 and SYX P+2) is 17 bytes.
                        \ Every efficiency saving helps, especially as this
                        \ routine is run each time the game prints a character
                        \
                        \ If you want to switch this code back on, uncomment
                        \ the above block, and comment out the code below from
                        \ TAY to STX P+2. You will also need to uncomment the
                        \ LDA YC instruction a few lines down (in RR2), just to
                        \ make sure the rest of the code doesn't shift in
                        \ memory. To be honest I can't see a massive difference
                        \ in speed, but there you go

 TAY                    \ Copy the character number from A to Y, as we are
                        \ about to pull A apart to work out where this
                        \ character definition lives in the ROM

                        \ Now we want to set X to point to the revevant page
                        \ number for this character - i.e. &C0, &C1 or &C2.
                        \ The following logic is easier to follow if we look
                        \ at the three character number ranges in binary:
                        \
                        \   Bit # 7654 3210
                        \
                        \   32  = 0010 0000     Page &C0
                        \   63  = 0011 1111
                        \
                        \   64  = 0100 0000     Page &C1
                        \   95  = 0101 1111
                        \
                        \   96  = 0110 0000     Page &C2
                        \   125 = 0111 1101
                        \
                        \ We'll refer to this below

 LDX #&BF               \ Set X to point to the first font page in ROM minus 1,
                        \ which is &C0 - 1, or &BF

 ASL A                  \ If bit 6 of the character is clear (A is 32-63)
 ASL A                  \ then skip the following instruction
 BCC P%+4

 LDX #&C1               \ A is 64-126, so set X to point to page &C1

 ASL A                  \ If bit 5 of the character is clear (A is 64-95)
 BCC P%+3               \ then skip the following instruction

 INX                    \ Increment X
                        \
                        \ By this point, we started with X = &BF, and then
                        \ we did the following:
                        \
                        \   If A = 32-63:   skip    then INX  so X = &C0
                        \   If A = 64-95:   X = &C1 then skip so X = &C1
                        \   If A = 96-126:  X = &C1 then INX  so X = &C2
                        \
                        \ In other words, X points to the relevant page. But
                        \ what about the value of A? That gets shifted to the
                        \ left three times during the above code, which
                        \ multiplies the number by 8 but also drops bits 7, 6
                        \ and 5 in the process. Look at the above binary
                        \ figures and you can see that if we cleared bits 5-7,
                        \ then that would change 32-53 to 0-31... but it would
                        \ do exactly the same to 64-95 and 96-125. And because
                        \ we also multiply this figure by 8, A now points to
                        \ the start of the character's definition within its
                        \ page (because there are 8 bytes per character
                        \ definition)
                        \
                        \ Or, to put it another way, X contains the high byte
                        \ (the page) of the address of the definition that we
                        \ want, while A contains the low byte (the offset into
                        \ the page) of the address

 STA P+1                \ Store the address of this character's definition in
 STX P+2                \ P+1 (low byte) and P+2 (high byte)

 LDA XC                 \ Fetch XC, the x-coordinate (column) of the text
 ASL A                  \ cursor, multiply by 8, and store in SC. As each
 ASL A                  \ character is 8 bits wide, and the special screen mode
 ASL A                  \ Elite uses for the top part of the screen is 256
 STA SC                 \ bits across with one bit per pixel, this value is
                        \ not only the screen address offest of the text cursor
                        \ from the left side of the screen, it's also the least
                        \ significant byte of the screen address where we want
                        \ to print this character, as each row of on-screen
                        \ pixels corresponds to one page. To put this more
                        \ explicitly, the screen starts at &6000, so the
                        \ text rows are stored in screen memory like this:
                        \
                        \   Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
                        \   Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
                        \   Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
                        \
                        \ and so on

 LDA YC                 \ Fetch YC, the y-coordinate (row) of the text cursor

 CPY #127               \ If the character number (which is in Y) <> 127, then
 BNE RR2                \ skip to RR2 to print that character, otherwise this is
                        \ the delete character, so continue on

 DEC XC                 \ We want to delete the character to the left of the
                        \ text cursor and move the cursor back one, so let's
                        \ do that by decrementing YC. Note that this doesn't
                        \ have anything to do with the actual deletion below,
                        \ we're just updating the cursor so it's in the right
                        \ position following the deletion

 ADC #&5E               \ A contains YC (from above) and the carry flag is set
 TAX                    \ (from the CPY #127 above), so these instructions do
                        \ this: X = YC + &5E + 1 = YC + &5F
                        \
                        \ Because YC starts at 1 for the first text row, this
                        \ means that X will be &60 for row 1, &61 for row 2
                        \ and so on. In other words, X is now set to the page
                        \ number for the relevant row in screen memory (see
                        \ the comment above)

 LDY #&F8               \ Set Y = -8

 JSR ZES2               \ Call ZES2, which zero-fills the page pointed to by X,
                        \ from position SC + Y to SC - so that's the 8 bytes
                        \ before SC. We set SC above to point to the current
                        \ character, so this zero-fills the character before
                        \ that, effectively deleting the character to the left

 BEQ RR4                \ We are done deleting, so restore the registers and
                        \ return from the subroutine (this BNE is effectively
                        \ a JMP as ZES2 always returns with the zero flag set)

.RR2                    \ Now to actually print the character

 INC XC                 \ Once we print the character, we want to move the text
                        \ cursor to the right, so we do this by incrementing
                        \ XC. Note that this doesn't have anything to do
                        \ with the actual printing below, we're just updating
                        \ the cursor so it's in the right position following
                        \ the print

\LDA YC                 \ This instruction is commented out in the original
                        \ source. It isn't required because we only just did a
                        \ LDA YC before jumping to RR2, so this is presumably
                        \ an example of the authors squeezing the code to save
                        \ 2 bytes and 3 cycles
                        \
                        \ If you want to re-enable the commented block near the
                        \ start of this routine, you should uncomment this
                        \ instruction as well

 CMP #24                \ If the text cursor is on the screen (i.e. YC < 24, so
 BCC RR3                \ we are on rows 1-23), then jump to RR3 to print the
                        \ character

 JSR TTX66              \ Otherwise we are off the bottom of the screen, so
                        \ clear the screen and draw a white border

 JMP RR4                \ And restore the registers and return from the
                        \ subroutine

.^RR3

 ORA #&60               \ A contains the value of YC - the screen row where we
                        \ want to print this character - so now we need to
                        \ convert this into a screen address, so we can poke
                        \ the character data to the right place in screen
                        \ memory. We already stored the least significant byte
                        \ of this screen address in SC above (see the STA SC
                        \ instruction above), so all we need is the most
                        \ significant byte. As mentioned above, in Elite's
                        \ square mode 4 screen, each row of text on screen
                        \ takes up exactly one page, so the first row is page
                        \ &60xx, the second row is page &61xx, so we can get
                        \ the page for character (XC, YC) by OR-ing with &60.
                        \ To see this in action, consider that our two values
                        \ are, in binary:
                        \
                        \   YC is between:  %0000 0000
                        \             and:  %0001 0111
                        \          &60 is:  %0110 0000
                        \
                        \ so YC OR &60 effectively adds &60 to YV, giving us
                        \ the page number that we want

.^RREN

 STA SC+1               \ Store the page number of the destination screen
                        \ location in SC+1, so SC now points to the full screen
                        \ location where this character should go

 LDY #7                 \ We want to print the 8 bytes of character data to the
                        \ screen (one byte per row), so set up a counter in Y
                        \ to count these bytes

.RRL1

 LDA (P+1),Y            \ The character definition is at P+1 (low byte) and P+2
                        \ (high byte) - we set this up above -  so load the
                        \ Y-th byte from P+1

 EOR (SC),Y             \ If we EOR this value with the existing screen
                        \ contents, then it's reversible (so reprinting the
                        \ same character in the same place will revert the
                        \ screen to what it looked like before we printed
                        \ anything); this means that printing a white pixel on
                        \ onto a white background results in a black pixel, but
                        \ that's a small price to pay for easily erasable text

 STA (SC),Y             \ Store the Y-th byte at the screen address for this
                        \ character location

 DEY                    \ Decrement the loop counter

 BPL RRL1               \ Loop back for the next byte to print to the screen=

.RR4

 LDY YSAV2              \ We're done printing, so restore the values of the
 LDX XSAV2              \ A, X and Y registers that we saved above and clear
 LDA K3                 \ the carry flag, so everything is back to how it was
 CLC

.^rT9

 RTS                    \ Return from the subroutine

.R5

 JSR BEEP               \ Call the BEEP subroutine to make a short, high beep

 JMP RR4                \ Jump to RR4 to restore the registers and return from
                        \ the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DIALS (Part 1 of 4)
\
\ Update the dashboard. This section draws the speed indicator.
\
\ First we draw all the indicators in the right part of the dashboard, from top
\ (speed) to bottom (energy banks), and then we move on to the left part, again
\ drawing from top (forward shield) to bottom (altitude). This first section
\ us off with the speedometer in the top right.
\
\ ******************************************************************************

.DIALS
{
 LDA #&D0               \ Set SC(1 0) = &78D0, which is the screen address for
 STA SC                 \ the character block containing the left end of the
 LDA #&78               \ top indicator in the right part of the dashboard, the
 STA SC+1               \ one showing our speed

 JSR PZW                \ Call PZW to set A to the colour for dangerous values
                        \ and and X to the colour for safe values

 STX K+1                \ Set K+1 (the colour we should show for low values) to
                        \ X (the colour to use for safe values)

 STA K                  \ Set K (the colour we should show for high values) to
                        \ A (the colour to use for dangerous values)

                        \ The above sets the following indicators to show red
                        \ for high values and yellow/white for low values

 LDA #14                \ Set T1 to 14, the threshold at which we change the
 STA T1                 \ indicator's colour

 LDA DELTA              \ Fetch our ship's speed into A, in the range 0-40

\LSR A                  \ Draw the speed indicator using a range of 0-31, and
 JSR DIL-1              \ increment SC to point to the next indicator (the roll
                        \ indicator). The LSR is commented out as it isn't
                        \ required with a call to DIL-1, so perhaps this was
                        \ originally a call to DIL that got optimised

\ ******************************************************************************
\
\ Subroutine: DIALS (Part 2 of 4)
\
\ Update the dashboard. This section draws the roll and pitch indicators.
\
\ ******************************************************************************

 LDA #0                 \ Set R = P = 0 for the low bytes in the call to the ADD
 STA R                  \ routine below
 STA P

 LDA #8                 \ Set S = 8, which is the value of the centre of the
 STA S                  \ roll indicator

 LDA ALP1               \ Fetch the roll rate as a value between 0 and 31, and
 LSR A                  \ divide by 4 to get a value of 0 to 7
 LSR A

 ORA ALP2               \ Apply the roll sign to the value, and flip the sign,
 EOR #%10000000         \ so it's now in the range -7 to +7, with a positive
                        \ roll rate giving a negative value in A

 JSR ADD                \ We now add A to S to give us a value in the range 1 to
                        \ 15, which we can pass to DIL2 to draw the vertical
                        \ bar on the indicator at this position. We use the ADD
                        \ routine like this:
                        \
                        \ (A X) = (A 0) + (S 0)
                        \
                        \ and just take the high byte of the result. We use ADD
                        \ rather than a normal ADC because ADD separates out the
                        \ sign bit and does the arithmetic using absolute values
                        \ and separate sign bits, which we want here rather than
                        \ the two's complement that ADC uses

 JSR DIL2               \ Draw a vertical bar on the roll indicator at offset A
                        \ and increment SC to point to the next indicator (the
                        \ pitch indicator)

 LDA BETA               \ Fetch the pitch rate as a value between -8 and +8

 LDX BET1               \ Fetch the magnitude of the pitch rate, and if it is 0
 BEQ P%+4               \ (i.e. we are not pitching), skip the next instruction

 SBC #1                 \ The pitch angle is non-zero, so set A = A - 1 (the C
                        \ flag is set by the call to DIL2 above, so we don't
                        \ need to do a SEC). This gives us a value of A from
                        \ -7 to +7 because these are magnitude-based numbers
                        \ with sign bits, rather than two's complement numbers

 JSR ADD                \ We now add A to S to give us a value in the range 1 to
                        \ 15, which we can pass to DIL2 to draw the vertical
                        \ bar on the indicator at this position (see the JSR ADD
                        \ above for more on this)

 JSR DIL2               \ Draw a vertical bar on the pitch indicator at offset A
                        \ and increment SC to point to the next indicator (the
                        \ four energy banks)

\ ******************************************************************************
\
\ Subroutine: DIALS (Part 3 of 4)
\
\ Update the dashboard. This section draws the four energy banks.
\
\ This and the next section only run once every four iterations of the main
\ loop, so while the speed, roll and pitch indicators update every iteration,
\ the other indicators update less often.
\
\ ******************************************************************************

 LDA MCNT               \ If the main loop counter has either of bits 0 and 1
 AND #%00000011         \ set, return from the subroutine (as rT9 contains an
 BNE rT9                \ RTS), so we fall through to the following in one of
                        \ every four main loop iterations

 LDY #0                 \ Set Y = 0, for use in various places below

 JSR PZW                \ Call PZW to set A to the colour for dangerous values
                        \ and and X to the colour for safe values

 STX K                  \ Set K (the colour we should show for high values) to X
                        \ (the colour to use for safe values)

 STA K+1                \ Set K+1 (the colour we should show for low values) to
                        \ A (the colour to use for dangerous values)

                        \ The above sets the following indicators to show red
                        \ for low values and yellow/white for high values, which
                        \ we use not only for the energy banks, but also for the
                        \ shield levels and current fuel

 LDX #3                 \ Set up a counter in X so we can zero the four bytes at
                        \ XX12, so we can then calculate each of the four energy
                        \ banks' values before drawing them later

 STX T1                 \ Set T1 to 3, the threshold at which we change the
                        \ indicator's colour

.DLL23

 STY XX12,X             \ Set the X-th byte of XX12 to 0

 DEX                    \ Decrement the counter

 BPL DLL23              \ Loop back for the next byte until the four bytes at
                        \ XX12 are all zeroed

 LDX #3                 \ Set up a counter in X to loop through the 4 energy
                        \ bank indicators, so we can calculate each of the four
                        \ energy banks' values and store them in XX12

 LDA ENERGY             \ Set A = Q = ENERGY / 4, so they are both now in the
 LSR A                  \ range 0-63 (so that's a maximum of 16 in each of the
 LSR A                  \ banks, and a maximum of 15 in the top bank)

 STA Q                  \ Set Q to A, so we can use Q to hold the remaining
                        \ energy as we work our way through each bank, from the
                        \ full ones at the bottom to the empty ones at the top

.DLL24

 SEC                    \ Set A = A - 16 to reduce the energy count by a full
 SBC #16                \ bank

 BCC DLL26              \ If the C flag is clear then A < 16, so this bank is
                        \ not full to the brim, and is therefore the last one
                        \ with any energy in it, so jump to DLL26

 STA Q                  \ This bank is full, so update Q with the energy of the
                        \ remaining banks

 LDA #16                \ Store this bank's level in XX12 as 16, as it is full,
 STA XX12,X             \ with XX12+3 for the bottom bank and XX12+0 for the top

 LDA Q                  \ Set A to the remaining energy level again

 DEX                    \ Decrement X to point to the next bank, i.e. the one
                        \ above the bank we just processed

 BPL DLL24              \ Loop back to DLL24 until we have either processed all
                        \ four banks, or jumped out early to DLL26 if the top
                        \ banks have no charge

 BMI DLL9               \ Jump to DLL9 as we have processed all four banks (this
                        \ BMI is effectively a JMP as A will never be positive)

.DLL26

 LDA Q                  \ If we get here then the bank we just checked is not
 STA XX12,X             \ fully charged, so store its value in XX12 (using Q,
                        \ which contains the energy of the remaining banks -
                        \ i.e. this one)

                        \ Now that we have the four energy bank values in XX12,
                        \ we can draw them, starting with the top bank in XX12
                        \ and looping down to the bottom bank in XX12+3, using Y
                        \ as a loop counter, which was set to 0 above

.DLL9

 LDA XX12,Y             \ Fetch the value of the Y-th indicator, starting from
                        \ the top

 STY P                  \ Store the indicator number in P for retrieval later

 JSR DIL                \ Draw the energy bank using a range of 0-15, and
                        \ increment SC to point to the next indicator (the
                        \ next energy bank down)

 LDY P                  \ Restore the indicator number into Y

 INY                    \ Increment the indicator number

 CPY #4                 \ Check to see if we have drawn the last energy bank

 BNE DLL9               \ Loop back to DLL9 if we have more banks to draw,
                        \ otherwise we are done

\ ******************************************************************************
\
\ Subroutine: DIALS (Part 4 of 4)
\
\ Update the dashboard. This section draws the indicators in the left part of
\ the dashboard.
\
\ ******************************************************************************

 LDA #&78               \ Set SC(1 0) = &7816, which is the screen address for
 STA SC+1               \ the character block containing the left end of the
 LDA #16                \ top indicator in the left part of the dashboard, the
 STA SC                 \ one showing the forward shield

 LDA FSH                \ Draw the forward shield indicator using a range of
 JSR DILX               \ 0-255, and increment SC to point to the next indicator
                        \ (the aft shield)

 LDA ASH                \ Draw the aft shield indicator using a range of 0-255,
 JSR DILX               \ and increment SC to point to the next indicator (the
                        \ fuel level)

 LDA QQ14               \ Draw the fuel level indicator using a range of 0-63,
 JSR DILX+2             \ and increment SC to point to the next indicator (the
                        \ cabin temperature)

 JSR PZW                \ Call PZW to set A to the colour for dangerous values
                        \ and and X to the colour for safe values

 STX K+1                \ Set K+1 (the colour we should show for low values) to
                        \ X (the colour to use for safe values)

 STA K                  \ Set K+1 (the colour we should show for high values) to
                        \ A (the colour to use for dangerous values)

                        \ The above sets the following indicators to show red
                        \ for high values and yellow/white for low values, which
                        \ we use for the cabin and laser temperature bars

 LDX #11                \ Set T1 to 11, the threshold at which we change the
 STX T1                 \ cabin and laser temperature indicators' colours

 LDA CABTMP             \ Draw the cabin temperature indicator using a range of
 JSR DILX               \ 0-255, and increment SC to point to the next indicator
                        \ (the laser temperature)

 LDA GNTMP              \ Draw the laser temperature indicator using a range of
 JSR DILX               \ 0-255, and increment SC to point to the next indicator
                        \ (the altitude)

 LDA #240               \ Set T1 to 240, the threshold at which we change the
 STA T1                 \ altitude indicator's colour. As the altitude has a
                        \ range of 0-255, pixel 16 will not be filled in, and
                        \ 240 would change the colour when moving between pixels
                        \ 15 and 16, so this effectively switches off the colour
                        \ change for the altitude indicator

 STA K+1                \ Set K+1 (the colour we should show for low values) to
                        \ 240, or &F0 (dashboard colour 2, yellow/white), so the
                        \ altitude indicator always shows in this colour

 LDA ALTIT              \ Draw the altitude indicator using a range of 0-255
 JSR DILX

 JMP COMPAS             \ We have now drawn all the indicators, so jump to
                        \ COMPAS to draw the compass, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\ Subroutine: PZW
\
\ Set A and X to the colours we should use for indicators showing dangerous and
\ safe values respectively. This enables us to implement flashing indicators,
\ which is one of the game's configurable options. If flashing is enabled, the
\ colour returned in A (dangerous values) will be red for 8 iterations of the
\ main loop, and yellow/white for the next 8, before going back to red. If we
\ always use PZW to decide which colours we should use when updating indicators,
\ flashing colours will be automatically taken care of for us.
\
\ The values returned are &F0 for yellow/white and &0F for red. These are mode 5
\ bytes that contain 4 pixels, with the colour of each pixel given in two bits,
\ the high bit from the first nibble (bits 4-7) and the low bit from the second
\ nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
\ depending on the dashboard palette), while in &0F each pixel is %01, or colour
\ 1 (red).
\
\ Returns:
\
\   A                   The colour to use for indicators with dangerous values
\
\   X                   The colour to use for indicators with safe values
\
\ ******************************************************************************

.PZW

 LDX #&F0               \ Set X to dashboard colour 2 (yellow/white)

 LDA MCNT               \ A will be non-zero for 8 out of every 16 main loop
 AND #%00001000         \ counts, when bit 4 is set, so this is what we use to
                        \ flash the "danger" colour

 AND FLH                \ A will be zeroed if flashing colours are disabled

 BEQ P%+4               \ If A is zero, skip to the LDA instruction below

 TXA                    \ Otherwise flashing colours are enabled and it's the
                        \ main loop iteration where we flash them, so set A to
                        \ colour 2 (yellow/white) and use the BIT trick below to
                        \ return from the subroutine

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &0F, or BIT &0FA9, which does nothing bar
                        \ affecting the flags

 LDA #&0F               \ Set A to dashboard colour 1 (red)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DILX
\
\ Update a bar-based indicator on the dashboard. The range of values shown on
\ the indicator depends on which entry point is called. For the default entry
\ point of DILX, the range is 0-255 (as the value passed in A is one byte).
\ The other entry points are shown below.
\
\ Arguments:
\
\   A                   The value to be shown on the indicator (so the larger
\                       the value, the longer the bar)
\
\   T1                  The threshold at which we change the indicator's colour
\                       from the low value colour to the high value colour. The
\                       threshold is in pixels, so it should have a value from
\                       0-16, as each bar indicator is 16 pixels wide
\
\   K                   The colour to use when A is a high value, as a 4-pixel
\                       mode 5 character row byte
\
\   K+1                 The colour to use when A is a low value, as a 4-pixel
\                       mode 5 character row byte
\
\   SC(1 0)             The screen address of the first character block in the
\                       indicator
\
\ Other entry points:
\
\   DILX+2              The range of the indicator is 0-64 (for the fuel
\                       indicator)
\
\   DIL-1               The range of the indicator is 0-32 (for the speed
\                       indicator)
\
\   DIL                 The range of the indicator is 0-16 (for the energy
\                       banks)
\
\ ******************************************************************************
\
\ Deep dive: The dashboard indicators
\ -----------------------------------
\ Using one routine to display all the different bar indicators in the dashboard
\ leads to some interesting behaviour. Each bar indicator is 16 pixels long, and
\ the default entry point at DILX can show values from 0-255, with each pixel in
\ the bar representing 16 units (so in the default mode, the last pixel, the
\ 16th, is not used). For comparison, if the routine is called via the entry
\ point at DIL, then the bar's range is 0-16, with each pixel representing 1
\ unit (and in this case, the 16th pixel can be used).
\
\ The dashboard's bar-based indicators are as follows, along with the range of
\ values shown by the bar, plus the range of that particular measurement in the
\ game in brackets:
\
\   * Forward and aft shields   0-255
\   * Fuel                      0-64    (fuel is actually 0-70)
\   * Cabin temperature         0-255
\   * Laser temperature         0-255
\   * Altitude                  0-255
\   * Speed                     0-32    (speed is actually 0-40)
\   * Energy banks              0-16    (the first bank is actually 0-15)
\
\ Most of the indicators have internal values of 0-255 and use the standard DILX
\ bar (so, as noted above, they only use pixels 0-15 in the bar, and don't use
\ the last one).
\
\ The energy banks are the same, as the maximum value for the ship's energy
\ levels is 255, which is divided into four banks to give a range of 0-15 for
\ the first bank, and a range of 0-16 for the other banks. This means that when
\ the energy banks are fully charged, the top indicator doesn't use the last
\ pixel, while the other energy banks do.
\
\ As a result of the above, most of the indicators have a comfortable fit within
\ the dashboard, with an empty pixel at the end of the bar that gives a nice,
\ black gap between the left-hand indicators and the left edge of the scanner.
\ However, the maximum values for fuel and speed don't fit nicely into the space
\ available in their bar-based indicators. Here's why:
\
\   * The maximum value for fuel is 70 (for 7.0 light years), so when this
\     this routine is called via DILX+2 to show the fuel reserves, the fuel
\     level in A is reduced down to a maximum of 17 (70 >> 2), which is one
\     bigger than the maximum of 16 that each bar can show. You never really
\     notice this as it's only the first 0.6 light years that fall off the end
\     of the bar, and jumps that small aren't that common, but the fuel level
\     does start off using all 16 pixels in its bar, which is one greater than
\     the other indicators in that column (all of which slot into the 0-15
\     pixel range), so it's clear that this indicator is slightly different.
\
\   * The speed indicator is at another level, though. The maximum speed of our
\     ship in Elite is a DELTA value of 40, which reduces down to an indicator
\     value of 20, four greater than the maximum value shown on the bar. The bar
\     simply cuts off any values greater than 16 and doesn't display the four
\     pixels that fall off the end. You can test this in-flight by tapping Space
\     until the speed indicator is just full, and then tapping it again four
\     times (during which your speed will still increase). If you then tap the
\     "?" key to slow down, you have to tap it five times before the speed
\     indicator starts to drop again. I guess there just wasn't room to let this
\     particular control knob go up to 11...
\
\ The only other dashboard indicators are missiles, pitch and roll, the compass
\ and the scanner, all of which have their own routines.
\
\ ******************************************************************************

.DILX
{
 LSR A                  \ If we call DILX, we set A = A / 16, so A is 0-15
 LSR A

 LSR A                  \ If we call DILX+2, we set A = A / 4, so A is 0-15

 LSR A                  \ If we call DIL-1, we set A = A / 2, so A is 0-15

.^DIL                   \ If we call DIL-1, we leave A alone, so A is 0-15

 STA Q                  \ Store the indicator value in Q, now reduced to 0-15,
                        \ which is the length of the indicator to draw in pixels

 LDX #&FF               \ Set R = &FF, to use as a mask for drawing each row of
 STX R                  \ each character block of the bar, starting with a full
                        \ character's width of 4 pixels

 CMP T1                 \ If A >= T1 then we have passed the threshold where we
 BCS DL30               \ change bar colour, so jump to DL30 to set A to the
                        \ "high value" colour

 LDA K+1                \ Set A to K+1, the "low value" colour to use

 BNE DL31               \ Jump down to DL31 (this BNE is effectively a JMP as A
                        \ will never be zero)

.DL30

 LDA K                  \ Set A to K, the "high value" colour to use

.DL31

 STA COL                \ Store the colour of the indicator in COL

 LDY #2                 \ We want to start drawing the indicator on the third
                        \ line in this character row, so set Y to point to that
                        \ row's offset

 LDX #3                 \ Set up a counter in X for the width of the indicator,
                        \ which is 4 characters (each of which is 4 pixel wide,
                        \ to give a total width of 16 pixels)

.DL1

 LDA Q                  \ Fetch the indicator value (0-15) from Q into A

 CMP #4                 \ If Q < 4, then we need to draw the end cap of the
 BCC DL2                \ indicator, which is less than a full character's
                        \ width, so jump down to DL2 to do this

 SBC #4                 \ Otherwise we can draw a 4-pixel wide block, so
 STA Q                  \ subtract 4 from Q so it contains the amount of the
                        \ indicator that's left to draw after this character

 LDA R                  \ Fetch the shape of the indicator row that we need to
                        \ display from R, so we can use it as a mask when
                        \ painting the indicator. It will be &FF at this point
                        \ (i.e. a full 4-pixel row)

.DL5

 AND COL                \ Fetch the 4-pixel mode 5 colour byte from COL, and
                        \ only keep pixels that have their equivalent bits set
                        \ in the mask byte in A

 STA (SC),Y             \ Draw the shape of the mask on pixel row Y of the
                        \ character block we are processing

 INY                    \ Draw the next pixel row, incrementing Y
 STA (SC),Y

 INY                    \ And draw the third pixel row, incrementing Y
 STA (SC),Y

 TYA                    \ Add 6 to Y, so Y is now 8 more than when we started
 CLC                    \ this loop iteration, so Y now points to the address
 ADC #6                 \ of the first line of the indicator bar in the next
 TAY                    \ character block (as each character is 8 bytes of
                        \ screen memory)

 DEX                    \ Decrement the loop counter for the next character
                        \ block along in the indicator

 BMI DL6                \ If we just drew the last character block then we are
                        \ done drawing, so jump down to DL6 to finish off

 BPL DL1                \ Loop back to DL1 to draw the next character block of
                        \ the indicator (this BPL is effectively a JMP as A will
                        \ never be negative following the previous BMI)

.DL2

 EOR #3                 \ If we get here then we are drawing the indicator's
 STA Q                  \ end cap, so Q is < 4, and this EOR flips the bits, so
                        \ instead of containing the number of indicator columns
                        \ we need to fill in on the left side of the cap's
                        \ character block, Q now contains the number of blank
                        \ columns there should be on the right side of the cap's
                        \ character block

 LDA R                  \ Fetch the current mask from R, which will be &FF at
                        \ this point, so we need to turn Q of the columns on the
                        \ right side of the mask to black to get the correct end
                        \ cap shape for the indicator

.DL3

 ASL A                  \ Shift the mask left and clear bits 0 and 4, which has
 AND #%11101111         \ the effect of shifting zeroes from the left into each
                        \ nibble (i.e. xxxx xxxx becomes xxx0 xxx0, which blanks
                        \ out the last column in the 4-pixel mode 5 character
                        \ block)

 DEC Q                  \ Decrement the counter for the number of columns to
                        \ blank out

 BPL DL3                \ If we still have columns to blank out in the mask,
                        \ loop back to DL3 until the mask is correct for the
                        \ end cap

 PHA                    \ Store the mask byte on the stack while we use the
                        \ accumulator for a bit

 LDA #0                 \ Change the mask so no bits are set, so the characters
 STA R                  \ after the one we're about to draw will be all blank

 LDA #99                \ Set Q to a high number (99, why not) so we will keep
 STA Q                  \ drawing blank characters until we reach the end of
                        \ the indicator row

 PLA                    \ Restore the mask byte from the stack so we can use it
                        \ to draw the end cap of the indicator

 JMP DL5                \ Jump back up to DL5 to draw the mask byte on screen

.DL6

 INC SC+1               \ Increment the high byte of SC to point to the next
                        \ character row on screen (as each row takes up exactly
                        \ one page of 256 bytes) - so this sets up SC to point
                        \ to the next indicator, i.e. the one below the one we
                        \ just drew

.DL9                    \ This label is never called and has no effect

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DIL2
\
\ Update the roll or pitch indicator on the dashboard. The indicator can show a
\ vertical bar in 16 positions, with a value of 8 showing the bar in the middle
\ of the indicator.
\
\ In practice this routine is only ever called with A in the range 1 to 15, so
\ the vertical bar never appears in the leftmost position (though it does appear
\ in the rightmost).
\
\ Arguments:
\
\   A                   The offset of the vertical bar to show in the indicator,
\                       from 0 at the far left, to 8 in the middle, and 15 at
\                       the far right
\
\ Returns:
\
\   C flag              C flag is set
\
\ ******************************************************************************

.DIL2
{
 LDY #1                 \ We want to start drawing the vertical indicator bar on
                        \ the second line in the indicator's character block, so
                        \ set Y to point to that row's offset

 STA Q                  \ Store the offset of the vertical bar to draw in Q

                        \ We are now going to work our way along the indicator
                        \ on the dashboard, from left to right, working our way
                        \ along one character block at a time. Y will be used as
                        \ a pixel row counter to work our way through the
                        \ character blocks, so each time we draw a character
                        \ block, we will increment Y by 8 to move on to the next
                        \ block

.DLL10

 SEC                    \ Set A = Q - 4, so that A contains the offset of the
 LDA Q                  \ vertical bar from the start of this character block
 SBC #4

 BCS DLL11              \ If Q >= 4 then the character block we are drawing does
                        \ not contain the vertical indicator bar, so jump to
                        \ DLL11 to draw a blank character block

 LDA #&FF               \ Set A to a high number (and &FF is as high as they go)

 LDX Q                  \ Set X to the offset of the vertical bar, which is
                        \ within this character block as Q < 4

 STA Q                  \ Set Q to a high number (&FF, why not) so we will keep
                        \ drawing blank characters after this one until we reach
                        \ the end of the indicator row

 LDA CTWOS,X            \ CTWOS is a table of ready-made 1-pixel mode 5 bytes,
                        \ just like the TWOS and TWOS2 tables for mode 4 (see
                        \ the PIXEL routine for details of how they work). This
                        \ fetches a mode 5 1-pixel byte with the pixel position
                        \ at X, so the pixel is at the offset that we want for
                        \ our vertical bar

 AND #&F0               \ The 4-pixel mode 5 colour byte &F0 represents four
                        \ pixels of colour %10 (3), which is yellow in the
                        \ normal dashboard palette and white if we have an
                        \ escape pod fitted. We AND this with A so that we only
                        \ keep the pixel that matches the position of the
                        \ vertical bar (i.e. A is acting as a mask on the
                        \ 4-pixel colour byte)

 BNE DLL12              \ If A is non-zero then we have something to draw, so
                        \ jump to DLL12 to skip the following and move on to the
                        \ drawing

.DLL11

                        \ If we get here then we want to draw a blank for this
                        \ character block

 STA Q                  \ Update Q with the new offset of the vertical bar, so
                        \ it becomes the offset after the character block we
                        \ are about to draw

 LDA #0                 \ Change the mask so no bits are set, so all of the
                        \ character blocks we display from now on will be blank
.DLL12

 STA (SC),Y             \ Draw the shape of the mask on pixel row Y of the
                        \ character block we are processing

 INY                    \ Draw the next pixel row, incrementing Y
 STA (SC),Y

 INY                    \ And draw the third pixel row, incrementing Y
 STA (SC),Y

 INY                    \ And draw the fourth pixel row, incrementing Y
 STA (SC),Y

 TYA                    \ Add 5 to Y, so Y is now 8 more than when we started
 CLC                    \ this loop iteration, so Y now points to the address
 ADC #5                 \ of the first line of the indicator bar in the next
 TAY                    \ character block (as each character is 8 bytes of
                        \ screen memory)

 CPY #30                \ If Y < 30 then we still have some more character
 BCC DLL10              \ blocks to draw, so loop back to DLL10 to display the
                        \ next one along

 INC SC+1               \ Increment the high byte of SC to point to the next
                        \ character row on screen (as each row takes up exactly
                        \ one page of 256 bytes) - so this sets up SC to point
                        \ to the next indicator, i.e. the one below the one we
                        \ just drew

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Variable: TVT1
\
\ Palette bytes for use with the split screen mode (see IRQ1 below for more
\ details).
\
\ Palette data is given as a set of bytes, with each byte mapping a logical
\ colour to a physical one. In each byte, the logical colour is given in bits
\ 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
\ for details of how palette mapping works, as in modes 4 and 5 we have to do
\ multiple palette commands to change the colours correctly, and the physical
\ colour value is EOR'd with 7, just to make things even more confusing.
\
\ Similarly, the palette at TVT1+16 is for the monochrome space view, where
\ logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
\ logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
\ these mappings requires six calls to SHEILA+&21 - see p.379 of the Advanced
\ User Guide for an explanation.
\
\ The mode 5 palette table has two blocks which overlap. The block used depends
\ on whether or not we have an escape pod fitted. The block at TVT1 is used for
\ the standard dashboard colours, while TVT1+8 is used for the dashboard when an
\ escape pod is fitted. The colours are as follows:
\
\                 Normal (TVT1)     Escape pod (TVT1+8)
\
\   Colour 0      Black             Black
\   Colour 1      Red               Red
\   Colour 2      Yellow            White
\   Colour 3      Green             Cyan
\
\ ******************************************************************************

.TVT1

 EQUB &D4, &C4          \ This block of palette data is used to create two
 EQUB &94, &84          \ palettes used in three different places, all of them
 EQUB &F5, &E5          \ redefining four colours in mode 5:
 EQUB &B5, &A5          \
                        \ 12 bytes from TVT1 (i.e. the first 6 rows): applied
 EQUB &76, &66          \ when the T1 timer runs down at the switch from the
 EQUB &36, &26          \ space view to the dashboard, so this is the standard
                        \ dashboard palette
 EQUB &E1, &F1          \
 EQUB &B1, &A1          \ 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
                        \ when the T1 timer runs down at the switch from the
                        \ space view to the dashboard, and we have an escape
                        \ pod fitted, so this is the escape pod dashboard
                        \ palette
                        \
                        \ 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
                        \ at vertical sync in LINSCN when HFX is non-zero, to
                        \ create the hyperspace effect in LINSCN (where the
                        \ whole screen is switched to mode 5 at vertical sync)

 EQUB &F0, &E0          \ 12 bytes of palette data at TVT1+16, used to set the
 EQUB &B0, &A0          \ mode 4 palette in LINSCN when we hit vertical sync,
 EQUB &D0, &C0          \ so the palette is set to monochrome when we start to
 EQUB &90, &80          \ draw the first row of the screen
 EQUB &77, &67
 EQUB &37, &27

\ ******************************************************************************
\
\ Subroutine: IRQ1
\
\ The main interrupt handler, which implements Elite's split screen mode.
\
\ IRQ1V is set to point to IRQ1 by elite-loader.asm.
\
\ ******************************************************************************
\
\ Deep dive: The split-screen mode
\ --------------------------------
\ Elite uses a unique split-screen mode that enables a high-resolution
\ black-and-white space view to coexist with a lower resolution, colour ship
\ dashboard. There are two parts to this screen mode: the custom mode, and the
\ split-screen aspect.
\
\ Elite's screen mode is a custom mode, based on mode 4 but with fewer pixels.
\ This mode is set up in elite-loader.asm by reprogramming the registers of the
\ 6845 CRTC - see the section on VDU command data in that file for more
\ details, but the salient part is the screen size, which is 32 columns by 31
\ rows rather than the 40 x 32 of standard mode 4. Screen sizes are given in
\ terms of characters, which are 8 x 8 pixels, so this means Elite's custom
\ screen mode is 256 x 248 pixels, in monochrome.
\
\ The split-screen aspect is implemented using a timer. The timer is set when
\ the vertical sync occurs, which happens once every screen refresh. While the
\ screen is redrawn, the timer runs down, and it is set up to run out just as
\ the computer starts to redraw the dashboard section. When the timer hits zero
\ it generates an interrupt, which runs the code below to reprogram the Video
\ ULA to switch the number of colours per pixel from 2 (black and white) to 4,
\ so the dashboard can be shown in colour. The trick is setting up the timer so
\ that the interrupt happens at the right place during the screen refresh.
\
\ Looking at the code, you can see the SHEILA+&44 and &45 commands in LINSCN
\ start the 6522 System VIA T1 timer counting down from 14622 (the high byte is
\ 57, the low byte is 30). The authors almost certainly arrived at this exact
\ figure by getting close and then tweaking the result, as the vertical sync
\ doesn't quite happen when you would expect, but here's how they would have
\ got an initial figure to start working from.
\
\ First, we need to know more about the screen structure and exactly where the
\ vertical sync occurs. Looking at the 6845 registers for screen mode 4, we get
\ the following:
\
\   * The horizontal total register (R0) is set to 63, which means the total
\     number of character columns is 64, the same as the default for mode 4
\     (the number stored in R0 is the number of columns minus 1)
\
\   * The vertical total register (R4) is set to 38, which means the total
\     number of character rows is 39, the same as the default for mode 4 (the
\     number stored in R4 is the number of rows minus 1)
\
\   * The vertical displayed register (R6), which gives us the number of
\     character rows, is set to 31 in elite-loader.asm, a change from the
\     default value of 32 for mode 4
\
\   * The vertical sync position register (R7) is 34, which again is the
\     default for mode 4
\
\ For the countdown itself, we use the 6522 System VIA T1 timer, which ticks
\ away at 1 MHz, or 1 million times a second. Each screen row contains 64
\ characters, or 64 * 8 = 512 pixels, and in mode 4 pixels are written to the
\ screen at a rate of 1MHz, so that's 512 ticks of the timer per character row.
\
\ This means for every screen refresh, all 39 lines of it, the timer will tick
\ down from 39 * 512 = 19968 ticks. If we can work out how many ticks there are
\ between the vertical sync firing and the screen redraw reaching the
\ dashboard, we can use the T1 timer to switch the colour depth at the right
\ moment.
\
\ Register R7 determines the position of the vertical sync, and it's set to 34
\ for mode 4. In theory, this means that the vertical sync is fired when the
\ screen redraw hits row 34, though in practice the sync actually fires quite a
\ bit later, at around line 34.5.
\
\ Tt's probably easiest to visualise the screen layout in terms of rows, with
\ row 1 being the top of the screen:
\
\   1     First row of space view
\   .
\   .     ... 24 rows of space view = 192 pixel rows ...
\   .
\   24    Last row of space view
\   24    First row of dashboard
\   .
\   .     ... 7 rows of dashboard = 56 pixel rows ...
\   .
\   31    Last row of dashboard
\   .
\   .     ... vertical retrace period ...
\   .
\   34.5  Vertical sync fires
\   .
\   .     ... 4.5 rows between vertical sync and end of screen ...
\   .
\   39    Last row of screen
\
\ So starting at the vertical sync, we have 4.5 rows before the end of the
\ screen, and then 24 rows from the top of the screen down to the start of the
\ dashboard, so that's a total of 28.5 rows. So given that we have 512 ticks
\ per row, we get:
\
\   28.5 * 512 = 14592
\
\ So if we started our timer from 14592 at the vertical sync and let it tick
\ down to zero, then it should get there just as we reach the dashboard.
\
\ However, because of the way the interrupt system works, this needs a little
\ tweaking, which is where the low byte of the timer comes in. In the code
\ below, the low byte is set to 30, to give a total timer count of 14622.
\
\ (Interestingly, in the loading screen in elite-loader.asm, the T1 timer for
\ the split screen has 57 in the high byte, but 0 in the low byte, and as a
\ result the screen does flicker quite a bit more at the top of the dashboard.
\ Perhaps the authors didn't think it worth spending time perfecting the
\ loader's split screen? Who knows...)
\
\ ******************************************************************************

{
.LINSCN                 \ This is called from the interrupt handler below, at
                        \ the start of each vertical sync (i.e. when the screen
                        \ refresh starts)

 LDA #30                \ Set the line scan counter to a non-zero value, so
 STA DL                 \ routines like WSCAN can set DL to 0 and then wait for
                        \ it to change to non-zero to catch the vertical sync

 STA SHEILA+&44         \ Set 6522 System VIA T1C-L timer 1 low-order counter
                        \ (SHEILA &44) to 30

 LDA #VSCAN             \ Set 6522 System VIA T1C-L timer 1 high-order counter
 STA SHEILA+&45         \ (SHEILA &45) to VSCAN (57) to start the T1 counter
                        \ counting down from 14622 at a rate of 1 MHz

 LDA HFX                \ If HFX is non-zero, jump to VNT1 to set the mode 5
 BNE VNT1               \ palette instead of switching to mode 4, which will
                        \ have the effect of blurring and colouring the top
                        \ screen. This is how the white hyperspace rings turn
                        \ to colour when we do a hyperspace jump, and is
                        \ triggered by setting HFX to 1 in routine LL164

 LDA #%00001000         \ Set Video ULA control register (SHEILA+&20) to
 STA SHEILA+&20         \ %00001000, which is the same as switching to mode 4
                        \ (i.e. the top part of the screen) but with no cursor

.VNT3

 LDA TVT1+16,Y          \ Copy the Y-th palette byte from TVT1+16 to SHEILA+&21
 STA SHEILA+&21         \ to map logical to actual colours for the bottom part
                        \ of the screen (i.e. the dashboard)

 DEY                    \ Decrement the palette byte counter

 BPL VNT3               \ Loop back to VNT3 until we have copied all the
                        \ palette bytes

 LDA LASCT              \ Decrement the value of LASCT, but if we go too far
 BEQ P%+5               \ and it becomes negative, bump it back up again (this
 DEC LASCT              \ controls the pulsing of pulse lasers)

 LDA SVN                \ If SVN is non-zero, we are in the process of saving
 BNE jvec               \ the commander file, so jump to jvec to pass control
                        \ to the next interrupt handler, so we don't break file
                        \ saving by blocking the interrupt chain

 PLA                    \ Otherwise restore Y from the stack
 TAY

 LDA SHEILA+&41         \ Read 6522 System VIA input register IRA (SHEILA &41)

 LDA &FC                \ Set A to the interrupt accumulator save register,
                        \ which restores A to the value it had on enterting the
                        \ interrupt

 RTI                    \ Return from interrupts, so this interrupt is not
                        \ passed on to the next interrupt handler, but instead
                        \ the interrupt terminates here

.^IRQ1

 TYA                    \ Store Y on the stack
 PHA

 LDY #11                \ Set Y as a counter for 12 bytes, to use when setting
                        \ the dashboard palette below

 LDA #%00000010         \ Read the 6522 System VIA status byte bit 1, which is
 BIT SHEILA+&4D         \ set if vertical sync has occurred on the video system

 BNE LINSCN             \ If we are on the vertical sync pulse, jump to LINSCN
                        \ to set up the timers to enable us to switch the
                        \ screen mode between the space view and dashboard

 BVC jvec               \ Read the 6522 System VIA status byte bit 6, which is
                        \ set if timer 1 has timed out. We set the timer in
                        \ LINSCN above, so this means we only run the next bit
                        \ if the screen redraw has reached the boundary between
                        \ the mode 4 and mode 5 screens (i.e. the top of the
                        \ dashboard). Otherwise bit 6 is clear and we aren't at
                        \ the boundary, so we jump to jvec to pass control to
                        \ the next interrupt handler

 ASL A                  \ Double the value in A to 4

 STA SHEILA+&20         \ Set Video ULA control register (SHEILA+&20) to
                        \ %00000100, which is the same as switching to mode 5,
                        \ (i.e. the bottom part of the screen) but with no
                        \ cursor

 LDA ESCP               \ If escape pod fitted, jump to VNT1 to set the mode 5
 BNE VNT1               \ palette differently (so the dashboard is a different
                        \ colour if we have an escape pod)

 LDA TVT1,Y             \ Copy the Y-th palette byte from TVT1 to SHEILA+&21
 STA SHEILA+&21         \ to map logical to actual colours for the bottom part
                        \ of the screen (i.e. the dashboard)

 DEY                    \ Decrement the palette byte counter

 BPL P%-7               \ Loop back to the LDA TVT1,Y instruction until we have
                        \ copied all the palette bytes

.jvec

 PLA                    \ Restore Y from the stack
 TAY

 JMP (VEC)              \ Jump to the address in VEC, which was set to the
                        \ original IRQ1 vector by elite-loader.asm, so this
                        \ instruction passes control to the next interrupt
                        \ handler

.VNT1

 LDY #7                 \ Set Y as a counter for 8 bytes

 LDA TVT1+8,Y           \ Copy the Y-th palette byte from TVT1+8 to SHEILA+&21
 STA SHEILA+&21         \ to map logical to actual colours for the bottom part
                        \ of the screen (i.e. the dashboard)

 DEY                    \ Decrement the palette byte counter

 BPL VNT1+2             \ Loop back to the LDA TVT1+8,Y instruction until we
                        \ have copied all the palette bytes

 BMI jvec               \ Jump up to jvec to pass control to the next interrupt
                        \ handler (this BMI is effectively a JMP as we didn't
                        \ loop back with the BPL above, so BMI is always true)

}

\ ******************************************************************************
\
\ Subroutine: ESCAPE
\
\ Launch our escape pod, displaying our Cobra disappearing off into the ether
\ before arranging our replacement ship. Called when we press Escape during
\ flight and have an escape pod fitted.
\
\ ******************************************************************************

.ESCAPE
{
 LDA MJ                 \ Store the value of MJ on the stack (the "are we in
 PHA                    \ witchspace?" flag)

 JSR RES2               \ Reset a number of flight variables and workspaces

 LDX #CYL               \ Set the current ship type to a Cobra Mk III, so we
 STX TYPE               \ can show our ship disappear into the distance when we
                        \ eject in our pod

 JSR FRS1               \ Call FRS1 to launch the Cobra Mk III straight ahead,
                        \ like a missile launch, but with our ship instead

 LDA #8                 \ Set the Cobra's INWK+27 (speed) to 8
 STA INWK+27

 LDA #194               \ Set the Cobra's INWK+30 (pitch counter) to 194, so it
 STA INWK+30            \ pitches as we pull away

 LSR A                  \ Set the Cobra's INWK+32 (AI flag) to %01100001, so it
 STA INWK+32            \ has no AI, and we can use this value as a counter to
                        \ do the following loop 97 times

.ESL1

 JSR MVEIT              \ Call MVEIT to move the Cobra in space

 JSR LL9                \ Call LL9 to draw the  Cobra on screen

 DEC INWK+32            \ Decrement the counter in INWK+32

 BNE ESL1               \ Loop back to keep moving the Cobra until the AI flag
                        \ is 0, which gives it time to drift away from our pod

 JSR SCAN               \ Call SCAN to remove all ships from the scanner

 JSR RESET              \ Call RESET to reset our ship and various controls

 PLA                    \ Restore the witchspace flag from before the escape pod
 BEQ P%+5               \ launch, and if we were in normal space, skip the
                        \ following instruction

 JMP DEATH              \ Launching an escape pod in witchspace is fatal, so
                        \ jump to DEATH to begin the funeral and return from the
                        \ subroutine using a tail call

 LDX #16                \ We lose all our cargo when using our escape pod, so
                        \ up a counter in X so we can zero the 17 cargo slots
                        \ in QQ20

.ESL2

 STA QQ20,X             \ Set the X-th byte of QQ20 to zero (as we know A = 0
                        \ from the BEQ above), so we no longer have any of item
                        \ type X in the cargo hold

 DEX                    \ Decrement the counter

 BPL ESL2               \ Loop back to ESL2 until we have emptied the entire
                        \ cargo hold

 STA FIST               \ Launching an escape pod also clears our criminal
                        \ record, so set our legal status in FIST to 0 ("clean")

 STA ESCP               \ The escape pod is a one-use item, so set ESCP to 0 so
                        \ we no longer have one fitted

 LDA #70                \ Our replacement ship is delivered with a full tank of
 STA QQ14               \ fuel, so set the current fuel level in QQ14 to 70, or
                        \ 7.0 light years

 JMP BAY                \ Go to the docking bay (i.e. show the Status Mode
                        \ screen) and return from the subroutine with a tail
                        \ call
}

\ ******************************************************************************
\
\ Save output/ELTB.bin
\
\ ******************************************************************************

PRINT "ELITE B"
PRINT "Assembled at ", ~CODE_B%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_B%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_B%

PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
SAVE "output/ELTB.bin", CODE_B%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE C
\
\ Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_C% = P%
LOAD_C% = LOAD% +P% - CODE%

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 1 of 7)
\
\ Apply tactics to the current ship. This section implements missile tactics
\ and is entered at TA18 from the main entry point below, of the current ship is
\ a missile. Specifically:
\
\   * If E.C.M. is active, destroy the missile
\
\   * If the missile is hostile towards us, then check how close it is. If it
\     hasn't reached us, jump to part 3 so it can streak towards us, otherwise
\     we've been hit, so process a large amount of damage to our ship
\
\   * Otherwise see how close the missile is to its target. If it has not yet
\     reached its target, give the target a chance to activate its E.C.M. if it
\     has one, otherwise jump to TA19 with K3 set to the vector from the target
\     to the missile
\
\   * If it has reached its target and the target is the space station, destroy
\     the missile, potentially damaging us if we are nearby
\
\   * If it has reached its target and the target is a ship, destroy the missile
\     and the ship, potentially damaging us if we are nearby
\
\ ******************************************************************************

{
.TA34                   \ If we get here, the missile is hostile

 LDA #0                 \ Set A to x_hi OR y_hi OR z_hi
 JSR MAS4

 BEQ P%+5               \ If A = 0 then the missile is very close to our ship,
                        \ so skip the following instruction

 JMP TA21               \ Jump down to part 3 to set up the vectors and skip
                        \ straight to aggressive manoeuvring

 JSR TA87+3             \ The missile has hit our ship, so call TA87+3 to set
                        \ bit 7 of the missile's INWK+31 byte, which marks the
                        \ missile as being killed

 JSR EXNO3              \ Make the sound of the missile exploding

 LDA #250               \ Call OOPS to damage the ship by 250, which is a pretty
 JMP OOPS               \ big hit, and return from the subroutine using a tail
                        \ call

.TA18                   \ This is the entry point for missile tactics and is
                        \ called from the main TACTICS routine below

 LDA ECMA               \ If an E.C.M. is currently active (either our's or an
 BNE TA35               \ opponent's), jump to TA35 to destroy this missile

 LDA INWK+32            \ Fetch the AI flag from INWK+32 and if bit 6 is set
 ASL A                  \ (i.e. missile is hostile), jump up to TA34 to check
 BMI TA34               \ whether the missile has hit us

 LSR A                  \ Otherwise shift A right again. We know bits 6 and 7
                        \ are now clear, so this leaves bits 0-5. Bits 1-5
                        \ contain the target's slot number, and bit 0 is cleared
                        \ in FRMIS when a missile is launched, so A contains
                        \ the slot number shifted left by 1 (i.e. doubled) so we
                        \ can use it as an index for the two-byte address table
                        \ at UNIV

 TAX                    \ Copy the address of the target ship's data block from
 LDA UNIV,X             \ UNIV(X+1 X) to V(1 0)
 STA V
 LDA UNIV+1,X
 STA V+1

 LDY #2                 \ K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
 JSR TAS1               \ target ship

 LDY #5                 \ K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
 JSR TAS1               \ target ship

 LDY #8                 \ K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
 JSR TAS1               \ target ship

                        \ So K3 now contains the vector from the target ship to
                        \ the missile

 LDA K3+2               \ Set A = OR of all the sign and high bytes of the
 ORA K3+5               \ above, clearing bit 7 (i.e. ignore the signs)
 ORA K3+8
 AND #%01111111
 ORA K3+1
 ORA K3+4
 ORA K3+7

 BNE TA64               \ If the result is non-zero, then the missile is some
                        \ distance from the target, so jump down to TA64 see if
                        \ the target activates its E.C.M.

 LDA INWK+32            \ Fetch the AI flag from INWK+32 and if only bits 7 and
 CMP #%10000010         \ 1 are set (AI is enabled and the target is slot 1, the
 BEQ TA35               \ space station), jump to TA35 to destroy this missile,
                        \ as the space station ain't kidding around
 
 LDY #31                \ Fetch byte #31 (the exploding flag) of the target ship
 LDA (V),Y              \ into A

 BIT M32+1              \ M32 contains an LDY #32 instruction, so M32+1 contains
                        \ 32, so this instruction tests A with %00100000, which
                        \ checks bit 5 of A (the "already exploding?" bit)

 BNE TA35               \ If the target ship is already exploding, jump to TA35
                        \ to destroy this missile

 ORA #%10000000         \ Otherwise set bit 7 of the target's byte #31 to mark
 STA (V),Y              \ the ship as having been killed, so it explodes

.TA35

 LDA INWK               \ Set A = x_lo OR y_lo OR z_lo of the missile
 ORA INWK+3
 ORA INWK+6

 BNE TA87               \ If A is non-zero then the missile is not near our
                        \ ship, so jump to TA87 to skip damaging our ship

 LDA #80                \ Otherwise the missile just got desttoyed near us, so
 JSR OOPS               \ call OOPS to damage the ship by 80, which is nowhere
                        \ near as bad as the 250 damage from a missile slamming
                        \ straight into us, but it's still pretty nasty

.TA87

 JSR EXNO2              \ Call EXNO2 to process the fact that we have killed a
                        \ missile (so increase the kill tally, make an explosion
                        \ sound and so on)

 ASL INWK+31            \ Set bit 7 of the missile's INWK+31 flag to mark it as
 SEC                    \ having been killed, so it explodes
 ROR INWK+31

.TA1

 RTS                    \ Return from the subroutine

.TA64                   \ If we get here then the missile has not reached the
                        \ target

 JSR DORND              \ Set A and X to random numbers

 CMP #16                \ If A >= 16 (94% chance), jump down to TA19 with the
 BCS TA19               \ vector from the target to the missile in K3

.M32

 LDY #32                \ Fetch byte 32 for the target and shift bit 0 (E.C.M.)
 LDA (V),Y              \ into the C flag
 LSR A

 BCC TA19               \ If the C flag is clear then the target does not have
                        \ E.C.M. fitted, so jump down to TA19 with the vector
                        \ from the target to the missile in K3

 JMP ECBLB2             \ The target has E.C.M., so jump to ECBLB2 to set it
                        \ off, returning from the subroutine using a tail call

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 2 of 7)
\
\ Apply tactics to the current ship. This section contains the main entry point
\ at TACTICS, which is called from MVEIT (part 2) for ships that have the AI
\ flag set (i.e. bit 7 of INWK+32). This part does the following:
\
\   * If this is a missile, jump up to the missile code in part 1
\
\   * If this is an escape pod, point it at the planet and jump to the
\     manoeuvring code in part 7
\
\   * If this is the space station and it is hostile, spawn a cop and we're done
\
\   * If this is a lone Thargon without a mothership, set it adrift aimlessly
\     and we're done
\
\   * If this is a pirate and we are within the space staion safe zone, stop
\     the pirate from attacking
\
\   * Recharge the ship's energy banks by 1
\
\ Arguments:
\
\   X                   The ship type
\
\ ******************************************************************************

.^TACTICS

 CPX #MSL               \ If this is a missile, jump up to TA18 to implement
 BEQ TA18               \ missile tactics

 CPX #ESC               \ If this is not an escape pod, skip the following two
 BNE P%+8               \ instructions

 JSR SPS1               \ This is an escape pod, so call SPS1 to calculate the
                        \ vector to the planet and store it in XX15

 JMP TA15               \ Jump down to TA15

 CPX #SST               \ If this is not the space station, jump down to TA13
 BNE TA13

 JSR DORND              \ This is the space station, so set A and X to random
 CMP #140               \ numbers and if A < 140 (55% chance) return from the
 BCC TA14-1             \ subroutine (as TA14-1 contains an RTS)

 LDA MANY+COPS          \ We only call the tactics routine for the space station
 CMP #4                 \ when it is hostile, so first check the number of cops
 BCS TA14-1             \ in the vicinity, and if we already have 4 or more, we
                        \ don't need to spawn any more, so return from the
                        \ subroutine (as TA14-1 contains an RTS)

 LDX #COPS              \ Call SFS1 to spawn a cop from the space station that
 LDA #%11110001         \ is hostile, has AI and has E.C.M., and return from the
 JMP SFS1               \ subroutine using a tail call

.TA13

 CPX #TGL               \ If this is not a Thargon, jump down to TA14
 BNE TA14

 LDA MANY+THG           \ If there is at least one Thargoid in the vicinity,
 BNE TA14               \ jump down to TA14

 LSR INWK+32            \ This is a Thargon but there is no Thargoid mothership,
 ASL INWK+32            \ so clear bit 0 of the AI flag to disable its E.C.M.

 LSR INWK+27            \ And halve the Thargon's speed

 RTS                    \ Return from the subroutine

.TA14

 CPX #CYL               \ If A >= #CYL, i.e. this is a Cobra Mk III trader (as
 BCS TA62               \ asteroids and cargo canisters never have AI), jump
                        \ down to TA62

 CPX #COPS              \ If this is a cop, jump down to TA62
 BEQ TA62

 LDA SSPR               \ If we aren't within range of the space station, jump 
 BEQ TA62               \ down to TA62

 LDA INWK+32            \ This is a pirate or bounty hunter, but we are inside
 AND #%10000001         \ the space station's safe zone, so clear bits 1-6 of
 STA INWK+32            \ the AI flag to stop it being hostile, because even
                        \ pirates aren't crazy enough to breach the station's
                        \ no-fire zone

.TA62

 LDY #14                \ If the ship's energy is greater or equal to the
 LDA INWK+35            \ maximum value from the ship's blueprint pointed to by
 CMP (XX0),Y            \ XX0, then skip the next instruction
 BCS TA21

 INC INWK+35            \ The ship's energy is not at maximum, so recharge the
                        \ energy banks by 1

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 3 of 7)
\
\ Apply tactics to the current ship. This section sets up some vectors and
\ calculates dot products. Specifically:
\
\   * Calculate the dot product of the ship's nose vector (i.e. the direction it
\     is pointing) with the vector between us and the ship. This value will help
\     us work out later on whether the enemy ship is pointing towards us, and
\     therefore whether it can hit us with it lasers.
\
\ ******************************************************************************

.TA21

 LDX #8                 \ We now want to copy the ship's x, y and z coordinates
                        \ from INWK to K3, so set up a counter for 9 bytes

.TAL1

 LDA INWK,X             \ Copy the X-th byte from INWK to the X-th byte of K3
 STA K3,X

 DEX                    \ Decrement the counter

 BPL TAL1               \ Loop back until we have copied all 9 bytes

.TA19                   \ If this is a missile that's heading for its target
                        \ (not us, one of the other ships), then the missile
                        \ routine at TA18 above jumps here after setting K3 to
                        \ the vector from the target to the missile

 JSR TAS2               \ Normalise the vector in K3 and store the normalised
                        \ version in XX15, so XX15 contains the normalised
                        \ vector from our ship to the ship we are applying AI
                        \ tactics to (or the normalised vector from the target
                        \ to the missile - in both cases it's the vector from
                        \ the potential victim to the attacker). Let's call this
                        \ vector shipv

 LDY #10                \ Set (A X) = nosev . XX15
 JSR TAS3               \           = nosev . shipv

 STA CNT                \ Store the high byte of the dot product in CNT. The
                        \ bigger the value, the more aligned the two ships are,
                        \ with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
                        \ is positive, the ships are facing in a similar
                        \ direction, if it's negative they are facing in
                        \ opposite directions

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 4 of 7)
\
\ Apply tactics to the current ship. This section works out what kind of
\ condition the ship is in. Specifically:
\
\   * Rarely (2.5% chance) roll the ship by a noticeable amount
\
\   * If the ship has at least half its energy banks full, jump to part 6 to
\     consider firing the lasers
\
\   * If the ship isn't really low on energy, jump to part 5 to consider firing
\     a missile
\
\   * Rarely (10% chance) the ship runs out of both energy and luck, and bails,
\     launching an escape pod and drifting in space
\
\ ******************************************************************************

 LDA TYPE               \ If this is not a missile, skip the following
 CMP #MSL               \ instruction
 BNE P%+5

 JMP TA20               \ This is a missile, so jump down to TA20 to get
                        \ straight into some aggressive manoeuvring

 JSR DORND              \ Set A and X to random numbers

 CMP #250               \ If A < 250 (97.5% chance), jump down to TA7 to skip
 BCC TA7                \ the following

 JSR DORND              \ Set A and X to random numbers
 
 ORA #104               \ Bump A up to at least 104 and store in the roll
 STA INWK+29            \ counter, to gives the ship a noticeable roll

.TA7

 LDY #14                \ Set A = the ship's maximum energy / 2
 LDA (XX0),Y
 LSR A

 CMP INWK+35            \ If the ship's current energy in INWK+35 > A, i.e. the
 BCC TA3                \ ship has at least half of its energy banks charged,
                        \ jump down to TA3

 LSR A                  \ If the ship's current energy in INWK+35 > A / 4, i.e.
 LSR A                  \ the ship is not into the last 1/8th of its energy,
 CMP INWK+35            \ jump down to ta3 to consider firing a missile
 BCC ta3

 JSR DORND              \ Set A and X to random numbers

 CMP #230               \ If A < 230 (90% chance), jump down to ta3 to consider
 BCC ta3                \ firing a missile

 LDA TYPE               \ If this is a Thargoid, jump down to ta3 to consider
 CMP #THG               \ launching a Thargon
 BEQ ta3

                        \ By this point, the ship has run out of both energy and
                        \ luck, so it's time to bail

 LDA #0                 \ Set the AI flag to 0 to disable AI, hostility and
 STA INWK+32            \ E.C.M., so the ship's a sitting duck

 JMP SESCP              \ Jump to SESCP to spawn an escape pod from the ship,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 5 of 7)
\
\ Apply tactics to the current ship. This section considers whether to launch a
\ missile. Specifically:
\
\   * If the ship doesn't have any missiles, skip to the next part
\
\   * If an E.C.M. is firing, skip to the next part
\
\   * Randomly decide whether to fire a missile (or, in the case of Thargoids,
\     release a Thargon), and if we do, we're done
\
\ ******************************************************************************

.ta3                    \ If we get here then the ship has less than half energy
                        \ so there may not be enough juice for lasers, but let's
                        \ see if we can fire a missile

 LDA INWK+31            \ Set A = bits 0-2 of INWK+31, the number of missiles
 AND #%111              \ the ship has left

 BEQ TA3                \ If it doesn't have any missiles, jump to TA3

 STA T                  \ Store the number of missiles in T

 JSR DORND              \ Set A and X to random numbers

 AND #31                \ Restrict A to a random number in the range 0-31
 
 CMP T                  \ If A >= T, which is quite likely, though less likely
 BCS TA3                \ with higher numbers of missiles, jump to TA3

 LDA ECMA               \ If an E.C.M. is currently active (either our's or an
 BNE TA3                \ opponent's), jump to TA3

 DEC INWK+31            \ We're done with the checks, so it's time to fire off
                        \ a missile, so reduce the missile count in INWK+31 by 1

 LDA TYPE               \ If this is not a Thargoid, jump down to TA16 to launch
 CMP #THG               \ a missile
 BNE TA16

 LDX #TGL               \ This is a Thargoid, so instead of launching a missile,
 LDA INWK+32            \ the mothership launches a Thargon, so call SFS1 to
 JMP SFS1               \ spawn a Thargon from the parent ship, and return from
                        \ the subroutine using a tail call

.TA16

 JMP SFRMIS             \ Jump to SFRMIS to spawn a missile as a child of the
                        \ current ship, make a noise and print a message warning
                        \ of incoming missiles, and return from the subroutine
                        \ using a tail call

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 6 of 7)
\
\ Apply tactics to the current ship. This section looks at potentialy firing
\ the ship's laser at us. Specifically:
\
\   * If the ship is not pointing at us, skip to the next part
\
\   * If the ship is pointing at us but not accurately, fire its laser at us and
\     skip to the next part
\
\   * If we are in the ship's crosshairs, register some damage to our ship, slow
\     down the attacking ship, make the noise of us being hit by laser fire, and
\     we're done
\
\ ******************************************************************************

.TA3                    \ If we get here then the ship either has plenty of
                        \ energy, or levels are low but it couldn't manage to
                        \ launch a missile, so maybe we can fire the laser?

 LDA #0                 \ Set A to x_hi OR y_hi OR z_hi
 JSR MAS4

 AND #%11100000         \ If any of the hi bytes have any of bits 5-7 set, then
 BNE TA4                \ jump to TA4 to skip the laser, as the ship is too far
                        \ away from us to hit us with a laser

 LDX CNT                \ Set X = the dot product set above in CNT. If this is
                        \ positive, this ship and our ship are facing in similar
                        \ directions, but if it's negative then we are facing
                        \ each other, so for us to be in the enemy ship's line
                        \ of fire, X needs to be negative. The value in X can
                        \ have a maximum magnitude of 36, which would mean we
                        \ were facing each other square on, so in the following
                        \ code we check X like this:
                        \
                        \   X = 0 to -31, we are not in the enemy ship's line
                        \       of fire, so they can't shoot at us
                        \
                        \   X = -32 to -34, we are in the enemy ship's line
                        \       of fire, so they can shoot at us, but they can't
                        \       hit us as we're not dead in their crosshairs
                        \
                        \   X = -35 to -36, we are bang in the middle of the
                        \       enemy ship's crosshairs, so they can not only
                        \       shoot us, they can hit us

 CPX #160               \ If X < 160, i.e. X > -32, then we are not in the enemy
 BCC TA4                \ ship's line of fire, so jump to TA4

 LDA INWK+31            \ Set bit 6 on INWK+31 to denote that the ship is firing
 ORA #64                \ its laser at us
 STA INWK+31

 CPX #163               \ If X < 163, i.e. X > -35, then we are not in the enemy
 BCC TA4                \ ship's crosshairs, so jump to TA4

.HIT

 LDY #19                \ We are being hit by enemy laser fire, so fetch the
 LDA (XX0),Y            \ enemy ship's laser power from their ship's blueprint
                        \ into A

 LSR A                  \ Halve their laser power to get the amount of damage we
                        \ should take

 JSR OOPS               \ Call OOPS to take some damage, which could do anything
                        \ from reducing the shields and energy, all the way to
                        \ losing cargo or dying (if the latter, we don't come
                        \ back from this subroutine)

 DEC INWK+28            \ Halve the attacking ship's acceleration in INWK+28,

 LDA ECMA               \ If an E.C.M. is currently active (either our's or an
 BNE TA10               \ opponent's), return from the subroutine without making
                        \ the laser-strike sound (as TA10 contains an RTS)

 LDA #8                 \ Call the NOISE routine with A = 8 to make the sound
 JMP NOISE              \ of us being hit by lasers, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\ Subroutine: TACTICS (Part 7 of 7)
\
\ Apply tactics to the current ship. This section looks at manoeuvring the
\ ship. Specifically:
\
\   * Work out which direction the ship should be moving, depending on whether
\     it's an escape pod, where it is, which direction it is pointing, and how
\     aggressive it is
\
\   * Set the roll and pitch counters to head in that direction
\
\   * Speed up or slow down, depending on where the ship is in relation to us
\
\ ******************************************************************************

.TA4

 LDA INWK+7             \ If z_hi >= 3 then the ship is quite far away, so jump
 CMP #3                 \ down to TA5
 BCS TA5
 
 LDA INWK+1             \ Otherwise set A = x_hi OR y_hi and extract bits 1-7
 ORA INWK+4
 AND #%11111110

 BEQ TA15               \ If A = 0 then the ship is pretty close to us, so jump
                        \ to TA15 so it heads away from us

.TA5

                        \ If we get here then the ship is quite far away

 JSR DORND              \ Set A and X to random numbers

 ORA #%10000000         \ Set bit 7 of A

 CMP INWK+32            \ If A >= INWK+32 (the ship's AI flag) then jump down
 BCS TA15               \ to TA15 so it heads away from us
 
                        \ We get here if A < INWK+32, and the chances of this
                        \ being true are greater with high values of INWK+32. In
                        \ other words, higher INWK+32 values increase the
                        \ chances of a ship changing direction to head towards
                        \ us - or, to put it another way, ships with higher
                        \ INWK+32 values are spoiling for a fight. Thargoids
                        \ have INWK+32 set to 255, which explains an awful lot

.TA20

                        \ If this is a missile we will have jumped straight
                        \ here, but we also get here if the ship is either far
                        \ away and aggressive, or not too close

 LDA XX15               \ Reverse the signs of XX15 and the dot product in CNT,
 EOR #%10000000         \ starting with the x-coordinate
 STA XX15

 LDA XX15+1             \ Then reverse the sign of the y-coordinate
 EOR #%10000000
 STA XX15+1

 LDA XX15+2             \ And then the z-coordinate, so now the XX15 vector goes
 EOR #%10000000         \ from the enemy ship to our ship (it was previously the
 STA XX15+2             \ other way round)

 LDA CNT                \ And finally change the sign of the dot product in CNT,
 EOR #%10000000         \ so now it's positive if the ships are facing each
 STA CNT                \ other, and negative if they are facing the same way

.TA15

                        \ If we get here, then one of the following is true:
                        \
                        \   * This is an escape pod and XX15 is pointing towards
                        \     the planet
                        \
                        \   * The ship is pretty close to us, or it's just not
                        \     very aggressive (though there is a random factor
                        \     at play here too). XX15 is still pointing from our
                        \     ship towards the enemy ship
                        \
                        \   * The ship is aggressive (though again, there's an
                        \     element of randomness here). XX15 is pointing from
                        \     the enemy ship towards our ship
                        \
                        \   * This is a missile heading for a target. XX15 is
                        \     pointing from the missile towards the target
                        \
                        \ We now want to move the ship in the direction of XX15,
                        \ which will make aggressive ships head towards us, and
                        \ ships that are too close turn away. Escape pods,
                        \ meanwhile, head off towards the planet in search of a
                        \ space station, and missiles home in on their targets

 LDY #16                \ Set (A X) = roofv . XX15
 JSR TAS3               \
                        \ This will be positive if XX15 is pointing in the same
                        \ direction as an arrow out of the top of the ship, in
                        \ other words if the ship should pull up to head in the
                        \ direction of XX15

 EOR #%10000000         \ Set the ship's pitch counter to 3, with the opposite
 AND #%10000000         \ sign to the dot product result, which gently pitches
 ORA #%00000011         \ the ship towards the direction of the XX15 vector
 STA INWK+30

 LDA INWK+29            \ Fetch the roll counter from INWK+29 into A and clear
 AND #%01111111         \ the sign bit

 CMP #16                \ If A >= 16 then jump to TA6, as the ship is already
 BCS TA6                \ in the process of rolling

 LDY #22                \ Set (A X) = sidev . XX15
 JSR TAS3               \
                        \ This will be positive if XX15 is pointing in the same
                        \ direction as an arrow out of the right side of the
                        \ ship, in other words if the ship should roll right to
                        \ head in the direction of XX15

 EOR INWK+30            \ Set the ship's roll counter to 5, with the sign set to
 AND #%10000000         \ positive if the pitch counter and dot product have
 EOR #%10000101         \ different signs, negative if they have the same sign
 STA INWK+29

.TA6

 LDA CNT                \ Fetch the dot product, and if it's negative jump to
 BMI TA9                \ TA9, as the ships are facing away from each other and
                        \ the ship might want to slow down to take another shot

 CMP #22                \ The dot product is positive, so the ships are facing
 BCC TA9                \ each other. If A < 22 then the ships are not heading
                        \ directly towards each other, so jump to TA9 to slow
                        \ down

 LDA #3                 \ Otherwise set the acceleration in INWK+28 to 3
 STA INWK+28

 RTS                    \ Return from the subroutine

.TA9

 AND #%01111111         \ Clear the sign bit of the dot product in A

 CMP #18                \ If A < 18 then the ship is way off the XX15 vector, so
 BCC TA10               \ return from the subroutine (TA10 contains an RTS)
                        \ without slowing down, as it still has quite a bit of
                        \ turning to do to get on course

 LDA #&FF               \ Otherwise set A = -1

 LDX TYPE               \ If this is not a missile then skip the ASL instruction
 CPX #MSL
 BNE P%+3

 ASL A                  \ This is a missile, so set A = -2, as missiles are more
                        \ nimble and can brake more quickly

 STA INWK+28            \ Ser the ship's acceleration to A

.TA10

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TAS1
\
\ Calculate one of the following, depending on the value in Y:
\
\   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
\
\   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
\
\   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
\
\ where the first coordinate is from the ship data block in INWK, and the second
\ coordinate is from the ship data block pointed to by V(1 0).
\
\ Arguments:
\
\   V(1 0)              The address of the ship data block to subtract
\
\   Y                   The coordinate in the V(1 0) block to subtract:
\
\                         * If Y = 2, subtract the x-coordinate and store the
\                           result in K3(2 1 0)
\
\                         * If Y = 5, subtract the y-coordinate and store the
\                           result in K3(5 4 3)
\
\                         * If Y = 8, subtract the z-coordinate and store the
\                           result in K3(8 7 6)
\
\ ******************************************************************************

.TAS1
{
 LDA (V),Y              \ Copy the sign byte of the V(1 0) coordinate into K+3,
 EOR #%10000000         \ flipping it in the process
 STA K+3

 DEY                    \ Copy the high byte of the V(1 0) coordinate into K+2
 LDA (V),Y
 STA K+2

 DEY                    \ Copy the high byte of the V(1 0) coordinate into K+1,
 LDA (V),Y              \ so now:
 STA K+1                \
                        \   K(3 2 1) = - coordinate in V(1 0)

 STY U                  \ Copy the index (now 0, 3 or 6) into U and X
 LDX U

 JSR MVT3               \ Call MVT3 to add the same coordinates, but this time
                        \ from INWK, so this would look like this for the
                        \ x-axis:
                        \
                        \   K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
                        \            = (x_sign x_hi x_lo) - coordinate in V(1 0)

 LDY U                  \ Restore the index into Y, though this instruction has
                        \ no effect, as Y is not used again, either here or
                        \ following calls to this routine

 STA K3+2,X             \ Store K(3 2 1) in K3+X(2 1 0), starting with the sign
                        \ byte
 
 LDA K+2                \ And then doing the high byte
 STA K3+1,X
 
 LDA K+1                \ And finally the low byte
 STA K3,X

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: HITCH
\
\ Work out if the ship in INWK is in our crosshairs.
\
\ Returns:
\
\   C flag              Set if the ship is in our crosshairs, clear if it isn't
\
\ Other entry points:
\
\   HI1                 Contains an RTS
\
\ ******************************************************************************
\
\ Deep dive: In the crosshairs
\ ----------------------------
\ There are a number of steps we have to take to work out whether a ship is in
\ our crosshairs. They are as follows.
\ 
\   * Make sure the ship is in front of us (z_sign is positive)
\ 
\   * Make sure this isn't the planet or sun (bit 7 of the ship type is clear)
\ 
\   * Make sure the ship isn't exploding (bit 5 of INWK+31 is clear)
\ 
\   * Make sure the ship is close enough to be targeted or hit (both x_hi and
\     y_hi are 0)
\ 
\   * Test whether our crosshairs are within the "hit area" for this ship 
\ 
\ This last one needs further explanation. Each ship type has, as part of its
\ blueprint, a 16-bit value that defines the area of the ship that can be locked
\ onto by a missle or hit by laser fire. The bigger this value, the easier the
\ ship is to hit.
\ 
\ The key to the calculation is the observation that the ship's x- and
\ y-coordinates give the horizontal and vertical distances between our line of
\ fire and the ship. This is because the z-axis points out of the nose of our
\ ship, and is therefore the same as our line of fire, so the other two axes
\ give the deviation of the other ship's position from this line.
\ 
\ We've already confirmed in the checks above that x_hi and y_hi are both zero,
\ so we calculate this:
\ 
\   (S R) = x_lo^2 + y_lo^2
\ 
\ which, using Pythagoras, is the same as the square of the distance from our
\ crosshairs to the ship.
\ 
\ If this calculation doesn't fit into the 16 bits of (S R) then we know we
\ can't be aiming at the ship, but if it does, we compare (S R) with the 16-bit
\ "hit area" byte from the ship's blueprint, and if (S R) is less than the "hit
\ area" value, the ship is determined to be in our crosshairs and can be hit or
\ targeted.
\ 
\ So the "hit area" byte is the square of the distance that the ship can be from
\ the centre of our crosshairs but still be locked onto by our missiles or hit
\ by our lasers.
\
\ ******************************************************************************

.HITCH
{
 CLC                    \ Clear the C flag so we can return with it cleared if
                        \ our checks fail

 LDA INWK+8             \ Set A = z_sign

 BNE HI1                \ If A is non-zero then the ship is behind us and can't
                        \ be in our crosshairs, so return from the subroutine
                        \ with the C flag clear (as HI1 contains an RTS)

 LDA TYPE               \ If the ship type has bit 7 set then it is the planet
 BMI HI1                \ or sun, which we can't target or hit with lasers, so
                        \ return from the subroutine with the C flag clear (as
                        \ HI1 contains an RTS)

 LDA INWK+31            \ Fetch bit 5 of INWK+31 (the exploding flag) and OR
 AND #%00100000         \ with x_hi and y_hi
 ORA INWK+1
 ORA INWK+4

 BNE HI1                \ If this value is non-zero then either the ship is
                        \ exploding (so we can't target it), or the ship is too
                        \ far away from our line of fire to be targeted, so
                        \ return from the subroutine with the C flag clear (as
                        \ HI1 contains an RTS)

 LDA INWK               \ Set A = x_lo

 JSR SQUA2              \ Set (A P) = A * A = x_lo^2

 STA S                  \ Set (S R) = (A P) = x_lo^2
 LDA P
 STA R

 LDA INWK+3             \ Set A = y_lo

 JSR SQUA2              \ Set (A P) = A * A = y_lo^2

 TAX                    \ Store the high byte in X

 LDA P                  \ Add the two low bytes, so:
 ADC R                  \
 STA R                  \   R = P + R

 TXA                    \ Restore the high byte into A and add S to give the
 ADC S                  \ following:
                        \
                        \   (A R) = (S R) + (A P) = x_lo^2 + y_lo^2

 BCS FR1-2              \ If the addition just overflowed then there is no way
                        \ our crosshairs are within the ship's "hit area", so
                        \ return from the subroutine with the C flag clear (as
                        \ FR1-2 contains a CLC then an RTS)

 STA S                  \ Set (S R) = (A P) = x_lo^2 + y_lo^2

 LDY #2                 \ Fetch the ship's blueprint and set A to the high byte
 LDA (XX0),Y            \ of the "hit area" of the ship

 CMP S                  \ We now compare the high bytes of the "hit area" and
                        \ the calculation in (S R):
                        \
                        \   * If A >= S then then the C flag will be set
                        \
                        \   * If A < S then the C flag will be C clear

 BNE HI1                \ If A <> S we have just set the C flag correctly, so
                        \ return from the subroutine (as HI1 contains an RTS)

 DEY                    \ The high bytes were identical, so now we fetch the
 LDA (XX0),Y            \ low byte of the "hit area" into A

 CMP R                  \ We now compare the low bytes of the "hit area" and
                        \ the calculation in (S R):
                        \
                        \   * If A >= R then the C flag will be set
                        \
                        \   * If A < R then the C flag will be C clear

.^HI1

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: FRS1
\
\ Launch a ship straight ahead of us, just below our line of sight.
\
\ This is used in two places:
\
\   * When we launch a missile, in which case the missile is the ship that is
\     launched ahead of us
\
\   * When we launch our escape pod, in which case it's our abandoned Cobra Mk
\     III that is launched ahead of us
\
\   * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
\     us as part of the death screen
\
\ Arguments:
\
\   X                   The type of ship to launch ahead of us
\
\ Returns:
\
\   C flag              Set if the ship was successfully launched, clear if it
\                       wasn't (as there wasn't enough free memory)
\
\ Other entry points:
\
\   fq1                 Used to add a cargo canister to the universe
\
\ ******************************************************************************

.FRS1
{
 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 LDA #28                \ Set y_lo = 28
 STA INWK+3

 LSR A                  \ Set z_lo = 14, so the launched ship starts out
 STA INWK+6             \ ahead of us

 LDA #%10000000         \ Set y_sign to be negative, so the launched ship is
 STA INWK+5             \ launched just below our line of sight

 LDA MSTG               \ Set A to the missile lock target, shifted left so the
 ASL A                  \ slot number is in bits 1-4

 ORA #%10000000         \ Set bit 7 and store the result in INWK+32, the AI
 STA INWK+32            \ flag launched ship for the launched ship. For missiles
                        \ this enables AI (bit 7), makes it friendly towards us
                        \ (bit 6), sets the target to the value of MSTG (bits
                        \ 1-4), and sets its lock status as launched (bit 0).
                        \ It doesn't matter what it does for our abandoned
                        \ Cobra, as the AI flag gets overwritten once we return
                        \ from the subroutine back to the ESCAPE routine that
                        \ called FRS1 in the first place

.^fq1

 LDA #&60               \ Set INWK+14 (nosev_z_hi) to 1 (&60), so the launched
 STA INWK+14            \ ship is pointing away from us

 ORA #128               \ Set INWK+22 (sidev_x_hi) to -1 (&D0), so the launched
 STA INWK+22            \ ship has the same orientation as spawned ships, just
                        \ pointing away from us (if we set side_v to +1 instead,
                        \ this ship would be a mirror image of all the other
                        \ ships, which are spawned with -1 in nosev and +1 in
                        \ sidev)

 LDA DELTA              \ Set INWK+27 (speed) to 2 * DELTA, so the launched ship
 ROL A                  \ flies off at twice our speed
 STA INWK+27

 TXA                    \ Add a new ship of type X to our local bubble of
 JMP NWSHP              \ universe and return from the subroutine using a tail
                        \ call
}

\ ******************************************************************************
\
\ Subroutine: FRMIS
\
\ We fired a missile, so send it streaking away from us to unleash mayhem and
\ destruction on our sworn enemies.
\
\ ******************************************************************************

.FRMIS
{
 LDX #MSL               \ Call FRS1 to launch a missile straight ahead of us
 JSR FRS1

 BCC FR1                \ If FRS1 returns with the C flag clear, then there
                        \ isn't room in the universe for our missile, so jump
                        \ down to FR1 to display a "missile jammed" message

 LDX MSTG               \ Fetch the slot number of the missile's target

 JSR GINF               \ Get the address of the data block for the target ship
                        \ and store it in INF

 LDA FRIN,X             \ Fetch the ship type of the missile's target into A

 JSR ANGRY              \ Call ANGRY to make the target ship hostile

 LDY #0                 \ We have just launched a missile, so we need to remove
 JSR ABORT              \ missile lock and hide the leftmost indicator on the
                        \ dashboard by setting it to black (Y = 0)

 DEC NOMSL              \ Reduce the number of missiles we have by 1

 LDA #48                \ Call the NOISE routine with A = 48 to make the sound
 JMP NOISE              \ of a missile launch, returning from the subroutine
                        \ using a tail call
}

\ ******************************************************************************
\
\ Subroutine: ANGRY
\
\ Make a ship hostile. All this actually does is set the ship's hostile flag,
\ start it turning and give it a kick of acceleration - later calls to TACTICS
\ will make the ship attack.
\
\ Arguments:
\
\   A                   The type of ship to irritate
\
\   INF                 The address of the data block for the ship to infuriate
\
\ ******************************************************************************

.ANGRY
{
 CMP #SST               \ If this is the space station, jump to AN2 to make the
 BEQ AN2                \ space station hostile

 BCS HI1                \ If A >= #SST then this is a missile, asteroid, cargo
                        \ canister, Thargon or escape pod, and they can't get
                        \ hostile, so return from the subroutine (as HI1
                        \ contains an RTS)

 CMP #CYL               \ If this is not a Cobra Mk III trader, skip the
 BNE P%+5               \ following instruction

 JSR AN2                \ Call AN2 to make the space station hostile

 LDY #32                \ Fetch the ship's byte 32 (AI flag)
 LDA (INF),Y

 BEQ HI1                \ If the AI flag is zero then this ship has no AI and
                        \ it can't get hostile, so return from the subroutine
                        \ (as HI1 contains an RTS)

 ORA #%10000000         \ Otherwise set bit 7 to ensure AI is definitely enabled
 STA (INF),Y

 LDY #28                \ Set the ship's byte 28 (acceleration) to 2, so it
 LDA #2                 \ speeds up
 STA (INF),Y

 ASL A                  \ Set the ship's byte 30 (pitch counter) to 4, so it
 LDY #30                \ starts pitching
 STA (INF),Y

 RTS                    \ Return from the subroutine

.AN2

 ASL K%+NI%+32          \ Fetch the AI counter (byte 32) of the second ship
 SEC                    \ in the ship data workspace at K%, which is reserved
 ROR K%+NI%+32          \ for the sun or the space station (in this case it's
                        \ the latter), and set bit 7 to make it hostile

 CLC                    \ Clear the C flag, which isn't used by calls to this
                        \ routine, but it does set up the entry point FR1-2
                        \ so that it clears the C flag and does an RTS

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: FR1
\
\ Display the "missile jammed" message.
\
\ Other entry points:
\
\   FR1-2               Clear the C flag and RTS
\
\ ******************************************************************************

.FR1
{
 LDA #201               \ Print recursive token 41 ("MISSILE JAMMED") as an
 JMP MESS               \ in-flight message and return from the subroutine using
                        \ a tail call
}

\ ******************************************************************************
\
\ Subroutine: SESCP
\
\ Spawn an escape pod from the current (parent) ship.
\
\ ******************************************************************************

.SESCP
{
 LDX #ESC               \ Set X to the ship type for an escape pod

 LDA #%11111110         \ Set A to an AI flag that has AI enabled, is hostile,
                        \ but has no E.C.M.

                        \ Fall through into SFS1 to spawn the escape pod
}

\ ******************************************************************************
\
\ Subroutine: SFS1
\
\ Spawn a child ship from the current (parent) ship. If the parent is a space
\ station then the child ship is spawned coming out of the slot, and if the
\ child is a cargo canister, it is sent tumbling through space. Otherwise the
\ child ship is spawned with the same ship data as the parent, just with damping
\ disabled and the ship type and AI flag that are passed in A and X.
\
\ Arguments:
\
\   A                   AI flag for the new ship (see the documentation on
\                       INWK+32 for details)
\
\   X                   The ship type of the child to spawn
\
\   INF                 Address of the parent's ship data block
\
\   TYPE                The type of the parent ship
\
\ Returns:
\
\   C flag              Set if ship successfully added, clear if it failed
\
\   INF                 INF is preserved
\
\   XX0                 XX0 is preserved
\
\   INWK                The whole INWK workspace is preserved
\
\ ******************************************************************************

.SFS1
{
 STA T1                 \ Store the child ship's AI flag in T1

                        \ Before spawning our child ship, we need to save the
                        \ INF and XX00 variables and the whole INWK workspace,
                        \ so we can restore them later when returning from the
                        \ subroutine

 LDA XX0                \ Store XX0(1 0) on the stack, so we can restore it
 PHA                    \ later when returning from the subroutine
 LDA XX0+1
 PHA

 LDA INF                \ Store INF(1 0) on the stack, so we can restore it
 PHA                    \ later when returning from the subroutine
 LDA INF+1
 PHA

 LDY #NI%-1             \ Now we want to store the current INWK data block in
                        \ temporary memory so we can restore it when we are
                        \ done, and we also want to copy the parent's ship data
                        \ into INWK, which we can do at the same time, so set up
                        \ a counter in Y for NI% bytes

.FRL2

 LDA INWK,Y             \ Copy the Y-th byte of INWK to the Y-th byte of
 STA XX3,Y              \ temporary memory in XX3, so we can restore it later
                        \ when returning from the subroutine

 LDA (INF),Y            \ Copy the Y-th byte of the parent ship's data block to
 STA INWK,Y             \ the Y-th byte of INWK

 DEY                    \ Decrement the loop counter

 BPL FRL2               \ Loop back to copy the next byte until we have done
                        \ them all

                        \ INWK now contains the ship data for the parent ship,
                        \ so now we need to tweak the data before creating the
                        \ new child ship (in this way, the child inherits things
                        \ like location from the parent)

 LDA TYPE               \ Fetch the ship type of the parent into A

 CMP #SST               \ If the parent is not a space station, jump to rx to
 BNE rx                 \ skip the following

                        \ The parent is a space station, so the child needs to
                        \ launch out of the space station's slot. The space
                        \ station's nosev vector points out of the station's
                        \ slot, so we want to move the ship along this vector.
                        \ We do this by taking the unit vector in nosev and
                        \ doubling it, so we spawn our ship 2 units along the
                        \ vector from the space station's centre

 TXA                    \ Store the child's ship type in X on the stack
 PHA

 LDA #32                \ Set the child's INWK+27 (speed) to 32
 STA INWK+27

 LDX #0                 \ Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
 LDA INWK+10            \ child's x-coordinate
 JSR SFS2

 LDX #3                 \ Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
 LDA INWK+12            \ child's y-coordinate
 JSR SFS2

 LDX #6                 \ Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
 LDA INWK+14            \ child's z-coordinate
 JSR SFS2

 PLA                    \ Restore the child's ship type from the stack into X
 TAX

.rx

 LDA T1                 \ Restore the child ship's AI flag from T1 and store it
 STA INWK+32            \ in the child's INWK+32 (AI)

 LSR INWK+29            \ Clear bit 0 of the child's INWK+29 (roll counter) so
 ASL INWK+29            \ that its roll dampens (so if we are spawning from a
                        \ space station, for example, the spawned ship won't
                        \ keep rolling forever)

 TXA                    \ If the child we are spawning is not a cargo canister,
 CMP #OIL               \ jump to NOIL to skip us setting up the pitch and roll
 BNE NOIL               \ for the canister

 JSR DORND              \ Set A and X to random numbers

 ASL A                  \ Set the child's INWK+30 (pitch counter) to a random
 STA INWK+30            \ value, and at the same time set the C flag randomly

 TXA                    \ Set the child's INWK+27 (speed) to a random value
 AND #%00001111         \ between 0 and 15
 STA INWK+27

 LDA #&FF               \ Set the child's INWK+29 (roll counter) to a full roll,
 ROR A                  \ so the canister tumbles through space, with damping
 STA INWK+29            \ randomly enabled or disabled, depending on the C flag
                        \ from above

 LDA #OIL               \ Set A to the ship type of a cargo canister

.NOIL

 JSR NWSHP              \ Add a new ship of type A to the local bubble

                        \ We have now created our child ship, so we need to
                        \ restore all the variables we saved at the start of
                        \ the routine, so they are preserved when we return
                        \ from the subroutine

 PLA                    \ Restore INF(1 0) from the stack
 STA INF+1
 PLA
 STA INF

 LDX #NI%-1             \ Now to restore the INWK workspace that we saved into
                        \ XX3 above, so set a counter in X for NI% bytes

.FRL3

 LDA XX3,X              \ Copy the Y-th byte of XX3 to the Y-th byte of INWK
 STA INWK,X

 DEX                    \ Decrement the loop counter

 BPL FRL3               \ Loop back to copy the next byte until we have done
                        \ them all

 PLA                    \ Restore XX0(1 0) from the stack
 STA XX0+1
 PLA
 STA XX0

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: SFS2
\
\ Move a ship's coordinates by a certain amount in the direction of one of the
\ axes, where X determines the axis. Mathematically speaking, this routine
\ translates the ship along a single axis by a signed delta.
\
\ Arguments:
\
\   A                   The amount of movement, i.e. the signed delta
\
\   X                   Determines which coordinate axis of INWK to move:
\
\                         * X = 0 moves the ship along the x-axis
\
\                         * X = 3 moves the ship along the y-axis
\
\                         * X = 6 moves the ship along the z-axis
\
\ ******************************************************************************

.SFS2
{
 ASL A                  \ Set R = |A * 2|, with the C flag set to bit 7 of A
 STA R

 LDA #0                 \ Set bit 7 of A to the C flag, i.e. the sign bit from
 ROR A                  \ the original argument in A

 JMP MVT1               \ Add the delta R with sign A to (x_lo, x_hi, x_sign)
                        \ (or y or z, depending on the value in X) and return
                        \ from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: LL164
\
\ Make the hyperspace sound and draw the hyperspace tunnel.
\
\ ******************************************************************************

.LL164
{
 LDA #56                \ Call the NOISE routine with A = 56 to make the sound
 JSR NOISE              \ of the hyperspace drive being engaged

 LDA #1                 \ Set HFX to 1, which switches the screen mode to a full
 STA HFX                \ mode 5 screen, therefore making the hyperspace rings
                        \ multi-coloured and all zig-zaggy (see the IRQ1 routine
                        \ for details)

 LDA #4                 \ Set the step size for the hyperspace rings to 4, so
                        \ there are more sections in the rings and thay are
                        \ quite round (compared to the step size of 8 used in
                        \ the much more polygonal launch rings)

 JSR HFS2               \ Call HFS2 to draw the hyperspace tunnel rings

 DEC HFX                \ Set HFX back to 0, so we switch back to the normal
                        \ split-screen mode

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: LAUN
\
\ Make the launch sound and draw the launch tunnel.
\
\ ******************************************************************************

.LAUN
{
 LDA #48                \ Call the NOISE routine with A = 48 to make the sound
 JSR NOISE              \ of the ship launching from the station

 LDA #8                 \ Set the step size for the hyperspace rings to 8, so
                        \ there are fewer sections in the rings and thay are
                        \ quite ploygonal (compared to the step size of 4 used
                        \ in the much rounder launch rings)
                    
                        \ Fall through into HFS2 to draw the launch tunnel rings
}

\ ******************************************************************************
\
\ Subroutine: HFS2
\
\ Draw the launch or hyperspace tunnel.
\
\ The animation gets drawn like this. First, we draw a circle of radius 8 at the
\ centre, and then double the radius, draw another circle, double the radius
\ again and draw a circle, and we keep doing this until the radius is bigger
\ than160 (which goes beyond the edge of the screen, which is 256 pixels wide,
\ equivalent to a radius of 128). We then repeat this whole process for an
\ initial circle of radius 9, then radius 10, all the way up to radius 15.
\
\ This has the effect of making the tunnel appear to be racing towards us as we
\ hurtle out into hyperspace or through the space station's docking tunnel.
\
\ The hyperspace effect is done in a full mode 5 screen, which makes the rings
\ all coloured and zig-zaggy, while the launch screen is in the normal
\ monochrome mode 4 screen.
\
\ Arguments:
\
\   A                   The step size of the straight lines making up the rings
\                       (4 for launch, 8 for hyperspace)
\
\ ******************************************************************************

.HFS2
{
 STA STP                \ Store the step size in A

 JSR TTX66              \ Clear the screen and draw a white border

 JSR HFS1               \ Call HFS1 below and then fall through into the same
                        \ routine, so this effectively runs HFS1 twice, and as
                        \ HFS1 draws 8 concentric rings, this means we draw 16
                        \ of them in all

.HFS1

 LDA #128               \ Set K3 = 128 (the x-coordinate pf the centre of the
 STA K3                 \ screen)

 LDX #Y                 \ Set K4 = #Y (the y-coordinate of the centre of the
                        \ screen)
 STX K4

 ASL A                  \ Set A = 0

 STA XX4                \ Set XX4 = 0, which we will use as a counter for
                        \ drawing 8 concentric rings

 STA K3+1               \ Set the high bytes of K3(1 0) and K4(1 0) to 0
 STA K4+1

.HFL5

 JSR HFL1               \ Call HFL1 below to draw a set of rings, with each one
                        \ twice the radius of the previous one, until they won't
                        \ fit on screen

 INC XX4                \ Increment the counter and fetch it into X
 LDX XX4

 CPX #8                 \ If we haven't drawn 8 sets of rings yet, loop back to
 BNE HFL5               \ HFL5 to draw the next ring

 RTS                    \ Return from the subroutine

.HFL1

 LDA XX4                \ Set K to the ring number in XX4 (0-7) + 8, so K has
 AND #7                 \ a value of 8 to 15, which we will use as the starting
 CLC                    \ radius for our next set of rings
 ADC #8
 STA K

.HFL2

 LDA #1                 \ Set LSP = 1 (the arc step for the circle)
 STA LSP

 JSR CIRCLE2            \ Call CIRCLE2 to draw a circle with the centre at
                        \ (K3(1 0), K4(1 0)) and radius K

 ASL K                  \ Double the radius in K

 BCS HF8                \ If the radius had a 1 in bit 7 before the above shift,
                        \ then doubling K will means the circle will no longer
                        \ fit on the screen (which is width 256), so jump to
                        \ HF8 to stop drawing circles

 LDA K                  \ If the radius in K <= 160, loop back to HFL2 to draw
 CMP #160               \ another one
 BCC HFL2

.HF8

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: STARS2
\
\ Left view has Xreg=1, Right has Xreg=2.
\
\ ******************************************************************************

.STARS2                 \ Left view has Xreg=1, Right has Xreg=2
{
 LDA #0
 CPX #2                 \ if X >=2 then C is set
 ROR A                  \ if left view, RAT=0, if right view, RAT=128
 STA RAT
 EOR #128               \ flip other rat sign
 STA RAT2               \ if left view, RAT2=128, if right view, RAT2=0
 JSR ST2                \ flip alpha, bet2

 LDY NOSTM              \ number of stars
}

.STL2                   \ counter Y
{
 LDA SZ,Y               \ dustz
 STA ZZ                 \ distance away of dust particles
 LSR A
 LSR A
 LSR A                  \ /=8
 JSR DV41               \ P.R = speed/ (ZZ/8)
 LDA P
 EOR RAT2               \ view sign
 STA S                  \ delta hi
 LDA SXL,Y              \ dust xlo
 STA P
 LDA SX,Y               \ dustx
 STA X1                 \ x middle
 JSR ADD                \ (A X) = (A P) + (S R) = dustx+delta/z_sign

 STA S                  \ new x hi
 STX R                  \ new x lo
 LDA SY,Y               \ dusty
 STA Y1                 \ yhi old
 EOR BET2               \ pitch sign
 LDX BET1               \ lower7 bits
 JSR MULTS-2            \ AP=A*bet1 (bet1+<32)
 JSR ADD                \ (A X) = (A P) + (S R)
 STX XX
 STA XX+1

 LDX SYL,Y              \ dust ylo
 STX R
 LDX Y1                 \ yhi old
 STX S
 LDX BET1               \ lower7 bits
 EOR BET2+1             \ flipped pitch sign
 JSR MULTS-2            \ AP=A*~bet1 (~bet1+<32)
 JSR ADD                \ (A X) = (A P) + (S R)
 STX YY                 \ ylo
 STA YY+1               \ yhi

 LDX ALP1               \ lower7 bits of roll
 EOR ALP2               \ roll sign
 JSR MULTS-2            \ AP=A*~alp1(~alp1+<32)
 STA Q                  \ roll step
 LDA XX
 STA R
 LDA XX+1
 STA S
 EOR #128               \ flip sign
 JSR MAD                \ X.A = Q*A -XX
 STA XX+1
 TXA                    \ dust xlo
 STA SXL,Y

 LDA YY                 \ ylo
 STA R
 LDA YY+1               \ yhi
 STA S
 JSR MAD                \ offset for pix1
 STA S                  \ yhi a
 STX R                  \ ylo a
 LDA #0                 \ add yinc due to roll
 STA P                  \ ylo b
 LDA ALPHA              \ yhi b

 JSR PIX1               \ dust, X1 has xscreen. yscreen = R.S+P.A
 LDA XX+1
 STA SX,Y               \ dustx
 STA X1                 \ X from middle

 AND #127               \ Acc left with bottom 7 bits of X hi
 CMP #116               \ approaching left or right edge of screen.  deltatX=11
 BCS KILL2              \ left or right edge
 LDA YY+1
 STA SY,Y               \ dusty
 STA Y1                 \ Y from middle
 AND #127               \ Acc left with bottom 7 bits of Y hi
 CMP #116               \ approaching top or bottom of screen
 BCS ST5                \ ydust kill
}

.STC2                   \ Back in
{
 JSR PIXEL2             \ dust (X1,Y1) from middle
 DEY                    \ next dust
 BEQ ST2                \ all dust done, exit loop
 JMP STL2               \ loop Y
}

.ST2                    \ exited dust loop, flip alpha, bet2
{
 LDA ALPHA
 EOR RAT                \ view sign
 STA ALPHA
 LDA ALP2               \ roll sign
 EOR RAT
 STA ALP2               \ roll sign
 EOR #128               \ flip
 STA ALP2+1             \ flipped roll sign
 LDA BET2               \ pitch sign2
 EOR RAT                \ view sign
 STA BET2               \ pitch sign
 EOR #128               \ flip
 STA BET2+1             \ flipped pitch sign
 RTS
}

\ ******************************************************************************
\
\ Subroutine: KILL2
\
\ Kill dust, left or right edge.
\
\ ******************************************************************************

.KILL2                  \ kill dust, left or right edge
{
 JSR DORND              \ Set A and X to random numbers
 STA Y1
 STA SY,Y               \ dusty rnd
 LDA #115               \ new xstart
 ORA RAT                \ view sign
 STA X1
 STA SX,Y               \ dustx
 BNE STF1               \ guaranteed, Set new distance
}

.ST5                    \ ydust kill
{
 JSR DORND              \ Set A and X to random numbers
 STA X1
 STA SX,Y               \ dustx rnd
 LDA #110               \ new ystart
 ORA ALP2+1             \ flipped roll sign
 STA Y1
 STA SY,Y               \ dusty
}

.STF1                   \ Set new distance
{
 JSR DORND              \ Set A and X to random numbers
 ORA #8                 \ not too close
 STA ZZ
 STA SZ,Y               \ dustz
 BNE STC2               \ guaranteed Back in for left/right dust
}

\ ******************************************************************************
\
\ Variable: SNE
\
\ Sine table. To calculate the following:
\
\   sin(theta) * 256
\
\ where theta is in radians, look up the value in:
\
\   SNE + (theta * 10)
\
\ Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
\
\ ******************************************************************************
\
\ Deep dive: Sine table
\ ---------------------
\ Here's how this works. The value at byte number (theta * 10) is:
\
\   256 * ABS(SIN((theta * 10 / 64) * 2 * PI))
\
\ rounded to the nearest integer. If we expand the part that we pass to SIN():
\
\   (theta * 10 / 64) * 2 * PI =  (theta / 6.4) * 2 * PI
\                              =~ (theta / 6.4) * 6.28
\                              =~ theta
\
\ then substitutig this into the above, we can see that the value at byte
\ (theta * 10) is approximately:
\
\   256 * ABS(SIN(theta))
\
\ It's not 100% accurate, but it's easily good enough for our needs.
\
\ ******************************************************************************

.SNE
{
FOR I%, 0, 31
  N = ABS(SIN((I% / 64) * 2 * PI))
  IF N >= 1
    EQUB &FF
  ELSE
    EQUB INT(256 * N + 0.5)
  ENDIF
NEXT
}

\ ******************************************************************************
\
\ Subroutine: MU5
\
\ Set all four bytes in K(3 2 1 0) to A and clear the C flag.
\
\ ******************************************************************************

.MU5
{
 STA K                  \ Set K(3 2 1 0) to (A A A A)
 STA K+1
 STA K+2
 STA K+3

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MULT3
\
\ Calculate the following multiplication between a signed 24-bit number and a
\ signed 8-bit number, returning the result as a signed 32-bit number:
\
\   K(3 2 1 0) = (A P+1 P) * Q
\
\ The algorithm is the same "shift and add" algorithm as in routine MU11, but
\ extended to cope with more bits.
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.MULT3
{
 STA R                  \ Store the high byte of (A P+1 P) in R

 AND #%01111111         \ Set K+2 to |A|, the high byte of K(2 1 0)
 STA K+2

 LDA Q                  \ Set A to bits 0-6 of Q, so A = |Q|
 AND #%01111111

 BEQ MU5                \ If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
                        \ returning from the subroutine with a tail call

 SEC                    \ Set T = |Q| - 1
 SBC #1
 STA T

                        \ We now use the same "shift and add" algorithm as MU11
                        \ to calculate the following:
                        \
                        \ K(2 1 0) = K(2 1 0) * |Q|
                        \
                        \ so we start with the first shift right, in which we
                        \ take (K+2 P+1 P) and shift it right, storing the
                        \ result in K(2 1 0), ready for the multiplication loop
                        \ (so the multiplication loop actually calculates
                        \ (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
                        \ (|A| P+1 P) shifted right)

 LDA P+1                \ Set A = P+1

 LSR K+2                \ Shift the high byte in K+2 to the right

 ROR A                  \ Shift the middle byte in A to the right and store in
 STA K+1                \ K+1 (so K+1 contains P+1 shifted right)

 LDA P                  \ Shift the middle byte in P to the right and store in
 ROR A                  \ K, so K(2 1 0) now contains (|A| P+1 P) shifted right
 STA K

                        \ We now use the same "shift and add" algorithm as MU11
                        \ to calculate the following:
                        \
                        \ K(2 1 0) = K(2 1 0) * |Q|

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #24                \ Set up a counter in X to count the 24 bits in K(2 1 0)

.MUL2

 BCC P%+4               \ If C (i.e. the next bit from K) is set, do the
 ADC T                  \ addition for this bit of K:
                        \
                        \   A = A + T + C
                        \     = A + |Q| - 1 + 1
                        \     = A + |Q|

 ROR A                  \ Shift A right by one place to catch the next digit
 ROR K+2                \ next digit of our result in the left end of K(2 1 0),
 ROR K+1                \ while also shifting K(2 1 0) right to fetch the next
 ROR K                  \ bit for the calculation into the C flag
                        \
                        \ On the last iteration of this loop, the bit falling
                        \ off the end of K will be bit 0 of the original A, as
                        \ we did one shift before the loop and we are doing 24
                        \ iterations. We set A to 0 before looping, so this
                        \ means the loop exits with the C flag clear

 DEX                    \ Decrement the loop counter

 BNE MUL2               \ Loop back for the next bit until K(2 1 0) has been
                        \ rotated all the way

                        \ The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
                        \ but it is positive and doesn't have the correct sign
                        \ of the final result yet

 STA T                  \ Save the high byte of the result into T

 LDA R                  \ Fetch the sign byte from the original (A P+1 P)
                        \ argument that we stored in R

 EOR Q                  \ EOR with Q so the sign bit is the same as that of
                        \ (A P+1 P) * Q

 AND #%10000000         \ Extract the sign bit

 ORA T                  \ Apply this to the high byte of the result in T, so
                        \ that A now has the correct sign for the result, and
                        \ (A K+2 K+1 K) therfore contains the correctly signed
                        \ result

 STA K+3                \ Store A in K+3, so K(3 2 1 0) now contains the result

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MLS2
\
\ Assign from stars R.S = XX(0to1), and P.A = A*alp1 (alp1+<32)
\
\ ******************************************************************************

.MLS2                   \ assign from stars R.S = XX(0to1), and P.A = A*alp1 (alp1+<32)
{
 LDX XX
 STX R                  \ lo
 LDX XX+1
 STX S                  \ hi
}

\ ******************************************************************************
\
\ Subroutine: MLS1
\
\ P.A = A*alp1 (alp1+<32)
\
\ ******************************************************************************

.MLS1                   \ P.A = A*alp1 (alp1+<32)
{
 LDX ALP1               \ roll magnitude
 STX P
}

.MULTS                  \ P.A =A*P(P+<32)
{
 TAX                    \ Acc in
 AND #128
 STA T                  \ sign
 TXA
 AND #127
 BEQ MU6                \ set Plo.Phi = Acc = 0
 TAX                    \ Acc in
 DEX
 STX T1                 \ A7-1 as carry will be set
 LDA #0

 LSR P
 BCC P%+4
 ADC T1
 ROR A
 ROR P
 BCC P%+4
 ADC T1
 ROR A
 ROR P
 BCC P%+4
 ADC T1
 ROR A
 ROR P
 BCC P%+4
 ADC T1
 ROR A
 ROR P
 BCC P%+4
 ADC T1
 ROR A
 ROR P

 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 ORA T
 RTS
}

\ ******************************************************************************
\
\ Subroutine: SQUA
\
\ Do the following multiplication of unsigned 8-bit numbers, after first
\ clearing bit 7 of A:
\
\   (A P) = A * A
\
\ ******************************************************************************

.SQUA
{
 AND #%01111111         \ Clear bit 7 of A and fall through into SQUA2 to set
                        \ (A P) = A * A
}

\ ******************************************************************************
\
\ Subroutine: SQUA2
\
\ Do the following multiplication of unsigned 8-bit numbers:
\
\   (A P) = A * A
\
\ ******************************************************************************

.SQUA2
{
 STA P                  \ Copy A into P and X
 TAX

 BNE MU11               \ If X = 0 fall through into MU1 to return a 0,
                        \ otherwise jump to MU11 to return P * X
}

\ ******************************************************************************
\
\ Subroutine: MU1
\
\ Copy X into P and A, and clear the C flag.
\
\ ******************************************************************************

.MU1
{
 CLC                    \ Clear the C flag

 STX P                  \ Copy X into P and A
 TXA

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MLU1
\
\ Do the following multiplication of a sign-magnitude 8-bit number P with an
\ unsigned number Q:
\
\   (A P) = |P| * Q
\
\ and set Y1 to the Y-th byte of SY.
\
\ ******************************************************************************

.MLU1
{
 LDA SY,Y               \ Set Y1 the Y-th byte of SY
 STA Y1

                        \ Fall through into MLU2 to calculate:
                        \
                        \   (A P) = |P| * Q
}

\ ******************************************************************************
\
\ Subroutine: MLU2
\
\ Do the following multiplication of a sign-magnitude 8-bit number P with an
\ unsigned number Q:
\
\   (A P) = |P| * Q
\
\ ******************************************************************************

.MLU2
{
 AND #%01111111         \ Clear the sign bit in P, so P = |P|
 STA P

                        \ Fall through into MULTU to calculate:
                        \
                        \   (A P) = P * Q
                        \         = |P| * Q
}

\ ******************************************************************************
\
\ Subroutine: MULTU
\
\ Do the following multiplication of unsigned 8-bit numbers:
\
\   (A P) = P * Q
\
\ ******************************************************************************

.MULTU
{
 LDX Q                  \ Set X = Q

 BEQ MU1                \ If X = Q = 0, jump to MU1 to copy X into P and A,
                        \ clear the C flag and return from the subroutine using
                        \ a tail call

                        \ Otherwise fall through into MU11 to set (A P) = P * X
}

\ ******************************************************************************
\
\ Subroutine: MU11
\
\ Do the following multiplication of two unsigned 8-bit numbers:
\
\   (A P) = P * X
\
\ This uses the same "shift and add" approach as MULT1, but it's simpler as we
\ are dealing with unsigned numbers in P and X. See the MULT1 routine for a
\ discussion of how this algorithm works.
\
\ ******************************************************************************

.MU11
{
 DEX                    \ Set T = X - 1
 STX T                  \
                        \ We subtract 1 as carry will be set when we want to do
                        \ an addition in the loop below

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #8                 \ Set up a counter in X to count the 8 bits in P

 LSR P                  \ Set P = P >> 1
                        \ and carry = bit 0 of P

                        \ We are now going to work our way through the bits of
                        \ P, and do a shift-add for any bits that are set,
                        \ keeping the running total in A. We just did the first
                        \ shift right, so we now need to do the first add and
                        \ loop through the other bits in P

.MUL6

 BCC P%+4               \ If C (i.e. the next bit from P) is set, do the
 ADC T                  \ addition for this bit of P:
                        \
                        \   A = A + T + C
                        \     = A + X - 1 + 1
                        \     = A + X

 ROR A                  \ Shift A right to catch the next digit of our result,
                        \ which the next ROR sticks into the left end of P while
                        \ also extracting the next bit of P

 ROR P                  \ Add the overspill from shifting A to the right onto
                        \ the start of P, and shift P right to fetch the next
                        \ bit for the calculation into the C flag

 DEX                    \ Decrement the loop counter

 BNE MUL6               \ Loop back for the next bit until P has been rotated
                        \ all the way

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MU6
\
\ Set P(1 0) = (A A). In practice this is only called via a BEQ following an AND
\ instruction, in which case A = 0, so this routine effectively does this:
\
\   P(1 0) = 0
\
\ ******************************************************************************

.MU6
{
 STA P+1                \ Set P(1 0) = (A A)
 STA P

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: FMLTU2
\
\ Calculate the following:
\
\   (A ?) = K * sin(A) * 256
\
\ ******************************************************************************

.FMLTU2
{
 AND #%00011111         \ Restrict A to bits 0-5 (so it's in the range 0-31)

 TAX                    \ Set Q = sin(A) * 256
 LDA SNE,X
 STA Q

 LDA K                  \ Set A to the radius in K

                        \ Fall through into FMLTU to do the following:
                        \
                        \   (A ?) = A * Q
                        \         = K * sin(A) * 256
}

\ ******************************************************************************
\
\ Subroutine: FMLTU
\
\ Do the following multiplication of two unsigned 8-bit numbers, returning only
\ the high byte of the result:
\
\   (A ?) = A * Q
\
\ or, to put it another way:
\
\   A = A * Q / 256
\
\ ******************************************************************************
\
\ Deep dive: Optimised multiplication
\ -----------------------------------
\ This routine uses the same basic algorithm as MU11, but because we are only
\ interested in the high byte of the result, we can optimise away a few
\ instructions. Instead of having a loop counter to count the 8 bits in the
\ multiplication, we can instead invert one of the arguments (A in this case,
\ which we then store in P to pull bits off), and then reverse the logic so that
\ ones get skipped and zeroes cause an addition. Also, when we do the first
\ shift right, we can stick a one into bit 7, so we can keep looping and
\ shifting right until we run out of ones, which is an easy BNE test. This works
\ because we don't have to store the low byte of the result anywhere, so we can
\ just shift P to the right, rather than ROR'ing it as we did in MULT1 - and
\ that lets us do the BNE test, saving few precious instructions in the process.
\
\ The result is a really slick, optimised multiplication routine that does a
\ specialised job, at the expense of clarity. To understand this routine, first
\ try to understand MULT1, then look at MU11, and finally try this one (I have
\ kept the comments similar so they are easier to compare). And if your eyes
\ aren't crossed by that point, then hats off to you, because this is properly
\ gnarly stuff.
\
\ ******************************************************************************

.FMLTU
{
 EOR #%11111111         \ Flip the bits in A, set the C flag and rotate right,
 SEC                    \ so the C flag now contains bit 0 of A inverted, and P
 ROR A                  \ contains A inverted and shifted right by one, with bit
 STA P                  \ 7 set to a 1. We can now use P as our source of bits
                        \ to shift right, just as in MU11, just with the logic
                        \ reversed

 LDA #0                 \ Set A = 0 so we can start building the answer in A

.MUL3

 BCS MU7                \ If C (i.e. the next bit from P) is set, do not do the
                        \ addition for this bit of P, and instead skip to MU7
                        \ to just do the shifts

 ADC Q                  \ Do the addition for this bit of P:
                        \
                        \   A = A + Q + C
                        \     = A + Q

 ROR A                  \ Shift A right to catch the next digit of our result.
                        \ If we were interested in the low byte of the result we
                        \ would want to save the bit that falls off the end, but
                        \ we aren't, so we can ignore it

 LSR P                  \ Shift P right to fetch the next bit for the
                        \ calculation into the C flag

 BNE MUL3               \ Loop back to MUL3 if P still contains some set bits
                        \ (so we loop through the bits of P until we get to the
                        \ 1 we inserted before the loop, and then we stop)

 RTS                    \ Return from the subroutine

.MU7

 LSR A                  \ Shift A right to catch the next digit of our result,
                        \ pushing a 0 into bit 7 as we aren't adding anything
                        \ here (we can't use a ROR here as the C flag is set, so
                        \ a ROR would push a 1 into bit 7)

 LSR P                  \ Fetch the next bit from P into the C flag

 BNE MUL3               \ Loop back to MUL3 if P still contains some set bits
                        \ (so we loop through the bits of P until we get to the
                        \ 1 we inserted before the loop, and then we stop)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: Unused duplicate of MULTU
\
\ This is a duplicate of the MULTU routine, but with no entry label, so it can't
\ be called by name. It is unused, and could have been culled to save a few
\ bytes (24 to be precise), but it's still here.
\
\ In the disc version it has the label MULTU6, but here in the tape version it's
\ unnamed, unloved and unvisited, through no fault of its own.
\
\ ******************************************************************************

{
 LDX Q
 BEQ MU1
 DEX
 STX T
 LDA #0
 LDX #8
 LSR P

.MUL6

 BCC P%+4
 ADC T
 ROR A
 ROR P
 DEX
 BNE MUL6
 RTS
}

\ ******************************************************************************
\
\ Subroutine: MLTU2
\
\ Do the following multiplication of an unsigned 16-bit number and an unsigned
\ 8-bit number:
\
\   (A P+1 P) = (A ~P) * Q
\
\ where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
\ words, if you wanted to calculate &1234 * &56, you would:
\
\   * Set A to &12
\   * Set P to &34 EOR %11111111 = &CB
\   * Set Q to &56
\
\ before calling MLTU2.
\
\ This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
\ inverted argument trick to work out whether or not to do an addition, and like
\ MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
\ extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
\ the algorithm is still the "shift and add" approach explained in MULT1, just
\ with more bits.
\
\ Returns:
\
\   Q                   Q is preserved
\
\ Other entry points:
\
\   MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
\
\ ******************************************************************************

{
 STX Q                  \ Store X in Q

.^MLTU2

 EOR #%11111111         \ Flip the bits in A and rotate right, storing the
 LSR A                  \ result in P+1, so we now calculate (P+1 P) * Q
 STA P+1

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #16                \ Set up a counter in X to count the 16 bits in (P+1 P)

 ROR P                  \ Set P = P >> 1 with bit 7 = bit 0 of A
                        \ and carry = bit 0 of P

.MUL7

 BCS MU21               \ If C (i.e. the next bit from P) is set, do not do the
                        \ addition for this bit of P, and instead skip to MU21
                        \ to just do the shifts

 ADC Q                  \ Do the addition for this bit of P:
                        \
                        \   A = A + Q + C
                        \     = A + Q

 ROR A                  \ Rotate (A P+1 P) to the right, so we capture the next
 ROR P+1                \ digit of the result in P+1, and extract the next digit
 ROR P                  \ of (P+1 P) in the C flag

 DEX                    \ Decrement the loop counter

 BNE MUL7               \ Loop back for the next bit until P has been rotated
                        \ all the way

 RTS                    \ Return from the subroutine

.MU21

 LSR A                  \ Shift (A P+1 P) to the right, so we capture the next
 ROR P+1                \ digit of the result in P+1, and extract the next digit
 ROR P                  \ of (P+1 P) in the C flag

 DEX                    \ Decrement the loop counter

 BNE MUL7               \ Loop back for the next bit until P has been rotated
                        \ all the way

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MUT3
\
\ This routine is never actually called, but it is identical to MUT2, as the
\ extra instructions have no effect.
\
\ ******************************************************************************

.MUT3
{
 LDX ALP1               \ Set P = ALP1, though this gets overwritten by the
 STX P                  \ following, so this has no effect

                        \ Fall through into MUT2 to do the following:
                        \
                        \   (S R) = XX(1 0)
                        \   (A P) = Q * A
}

\ ******************************************************************************
\
\ Subroutine: MUT2
\
\ Do the following assignment, and multiplication of two signed 8-bit numbers:
\
\   (S R) = XX(1 0)
\   (A P) = Q * A
\
\ ******************************************************************************

.MUT2
{
 LDX XX+1               \ Set S = XX+1
 STX S

                        \ Fall through into MUT1 to do the following:
                        \
                        \   R = XX
                        \   (A P) = Q * A
}

\ ******************************************************************************
\
\ Subroutine: MUT1
\
\ Do the following assignment, and multiplication of two signed 8-bit numbers:
\
\   R = XX
\   (A P) = Q * A
\
\ ******************************************************************************

.MUT1
{
 LDX XX                 \ Set R = XX
 STX R

                        \ Fall through into MULT1 to do the following:
                        \
                        \   (A P) = Q * A
}

\ ******************************************************************************
\
\ Subroutine: MULT1
\
\ Do the following multiplication of two signed 8-bit numbers:
\
\   (A P) = Q * A
\
\ ******************************************************************************
\
\ Deep dive: "Shift-and-add" multiplication
\ -----------------------------------------
\ This routine implements simple multiplication of two 8-bit numbers into a
\ 16-bit result using the "shift and add" algorithm. Consider multiplying two
\ example numbers, which we'll call p and a (as this makes it easier to map the
\ following to the code below):
\
\   p * a = %00101001 * a
\
\ This is the same as:
\
\   p * a = (%00100000 + %00001000 + %00000001) * a
\
\ or:
\
\   p * a = %00100000 * a + %00001000 * a + %00000001 * a
\
\ or:
\
\   p * a = a << 5 + a << 3 + a << 0
\
\ or, to lay this out in the way we're used to seeing it in school books on
\ long multiplication, if a is made up of binary digits aaaaaaaa, it's the same
\ as:
\
\          00101001         p
\          aaaaaaaa x       * a
\   ---------------
\          aaaaaaaa
\         00000000
\        00000000
\       aaaaaaaa
\      00000000
\     aaaaaaaa
\    00000000
\   00000000        +
\   ---------------
\   xxxxxxxxxxxxxxx         -> the result of p * a
\
\ In other words, we can work our way through the digits in the first number p
\ and every time there's a 1, we add an a to the result, shifted to the left by
\ the position of that digit.
\
\ We could code this into assembly relatively easily, but Elite takes a rather
\ more optimised route. Instead of shifting the number aaaaaaaa to the left for
\ each addition, we can instead shift the entire result to the right, saving
\ the bit that falls off the right end, and add an unshifted value of a. If you
\ think of one of the sums in our longhand version like this:
\
\     a7a6a5a4a3a2a1a0
\   a7a6a5a4a3a2a1a0   +
\
\ then instead of shifting the second number to the left, we can shift the
\ first number to the right and save the rightmost bit, like this:
\
\     a7a6a5a4a3a2a1        -> result bit 0 is a0
\   a7a6a5a4a3a2a1a0 +
\
\ So the routine's approach is to work our way through the digits in the first
\ number p, shifting the result right every time and saving the rightmost bit
\ in the final result, and every time there's a 1 in p, we add another a to the
\ sum.
\
\ This is essentially what Elite does in this routine, but there is one more
\ tweak that makes the process even more efficient (and even more confusing,
\ especially when you first read through the code). Instead of saving the
\ result bits out into a separate location, we can stick them onto the left end
\ of p, because every time we shift p to the right, we gain a spare bit on the
\ left end of p that we no longer use.
\
\ ******************************************************************************

.MULT1
{
 TAX                    \ Store A in X

 AND #%01111111         \ Set P = |A| >> 1
 LSR A                  \ and carry = bit 0 of A
 STA P

 TXA                    \ Restore argument A

 EOR Q                  \ Set bit 7 of A and T if Q and A have different signs,
 AND #%10000000         \ clear bit 7 if they have the same signs, 0 all other
 STA T                  \ bits, i.e. T contains the sign bit of Q * A

 LDA Q                  \ Set A = |Q|
 AND #%01111111

 BEQ mu10               \ If |Q| = 0 jump to mu10 (with A set to 0)

 TAX                    \ Set T1 = |Q| - 1
 DEX                    \
 STX T1                 \ We subtract 1 as carry will be set when we want to do
                        \ an addition in the loop below

                        \ We are now going to work our way through the bits of
                        \ P, and do a shift-add for any bits that are set,
                        \ keeping the running total in A. We already set up
                        \ the first shift at the start of this routine, as
                        \ P = |A| >> 1 and C = bit 0 of A, so we now need to set
                        \ up a loop to sift through the other 7 bits in P

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LDX #7                 \ Set up a counter in X to count the 7 bits remaining
                        \ in P

.MUL4

 BCC P%+4               \ If C (i.e. the next bit from P) is set, do the
 ADC T1                 \ addition for this bit of P:
                        \
                        \   A = A + T1 + C
                        \     = A + |Q| - 1 + 1
                        \     = A + |Q|

 ROR A                  \ As mentioned above, this ROR shifts A right and
                        \ catches bit 0 in C - giving another digit for our
                        \ result - and the next ROR sticks that bit into the
                        \ left end of P while also extracting the next bit of P
                        \ for the next addition

 ROR P                  \ Add the overspill from shifting A to the right onto
                        \ the start of P, and shift P right to fetch the next
                        \ bit for the calculation

 DEX                    \ Decrement the loop counter

 BNE MUL4               \ Loop back for the next bit until P has been rotated
                        \ all the way

 LSR A                  \ Rotate (A P) once more to get the final result, as
 ROR P                  \ we only pushed 7 bits through the above process

 ORA T                  \ Set the sign bit of the result that we stored in T

 RTS                    \ Return from the subroutine

.mu10

 STA P                  \ If we get here, the result is 0 and A = 0, so set
                        \ P = 0 so (A P) = 0

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MULT12
\
\ Calculate:
\
\   (S R) = Q * A
\
\ ******************************************************************************

.MULT12
{
 JSR MULT1              \ Set (A P) = Q * A

 STA S                  \ Set (S R) = (A P)
 LDA P
 STA R
 
 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TAS3
\
\ Calculate the dot product of the vector in XX15 and one of the orientation
\ vectors, as determined by the value of Y. If vect is the orientation vector,
\ we calculate this:
\
\   (A X) = vect . XX15
\         = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
\
\ Arguments:
\
\   Y                   The orientation vector:
\
\                         * If Y = 10, calculate nosev . XX15
\
\                         * If Y = 16, calculate roofv . XX15
\
\                         * If Y = 22, calculate sidev . XX15
\
\ Returns:
\
\   (A X)               The result of the dot product
\
\ ******************************************************************************

.TAS3
{
 LDX INWK,Y             \ Set Q = the Y-th byte of INWK, i.e. vect_x
 STX Q

 LDA XX15               \ Set A = XX15

 JSR MULT12             \ Set (S R) = Q * A = 

 LDX INWK+2,Y           \ Set Q = the Y+2-th byte of INWK, i.e. vect_y
 STX Q

 LDA XX15+1             \ Set A = XX15+1

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = vect_y * XX15+1 + vect_x * XX15

 STA S                  \ Set (S R) = (A X)
 STX R

 LDX INWK+4,Y           \ Set Q = the Y+2-th byte of INWK, i.e. vect_z
 STX Q

 LDA XX15+2             \ Set A = XX15+2

                        \ Fall through into MAD to set:
                        \
                        \   (A X) = Q * A + (S R)
                        \           = vect_z * XX15+2 + vect_y * XX15+1 +
                        \             vect_x * XX15
}

\ ******************************************************************************
\
\ Subroutine: MAD
\
\ Multiply and add
\
\   (A X) = Q * A + (S R)
\
\ ******************************************************************************

.MAD
{
 JSR MULT1              \ Call MULT1 to set (A P) = Q * A

                        \ Fall through into ADD to do:
                        \
                        \   (A X) = (A P) + (S R)
                        \         = Q * A + (S R)
}

\ ******************************************************************************
\
\ Subroutine: ADD
\
\ Add two signed 16-bit numbers together, making sure the result has the
\ correct sign. Specifically:
\
\   (A X) = (A P) + (S R)
\
\ ******************************************************************************
\
\ Deep dive: Adding sign-magnitude numbers
\ ----------------------------------------
\ When adding two signed numbers using two's complement, the result can have
\ the wrong sign when an overflow occurs. The classic example in 8-bit signed
\ arithmetic is 127 + 1, which doesn't give the expected 128, but instead gives
\ -128. In binary the sum looks like this:
\
\   0111 1111 + 0000 0001 = 1000 0000
\
\ The result has bit 7 set, so it is a negative number, 127 + 1 gives -128.
\ This is where the overflow flag V comes in - V would be set by the above sum
\ - but this means that every time you do a sum, you have to check the overflow
\ flag and deal with the overflow.
\
\ Elite doesn't want to have to bother with this overhead, so the ADD
\ subroutine, which adds two signed 16-bit numbers, instead ensures that the
\ result always had the correct sign, even in the event of an overflow, though
\ if the addition does overflow, the result still won't be correct. It will
\ have the right sign, though.
\
\ To implement this, the algorithm goes as follows. We want to add A and S, so:
\
\   * If both A and S are positive, just add them as normal
\
\   * If both A and S are negative, then add them and make sure the result is
\     negative
\
\   * If A and S have different signs, then we can use the absolute values of A
\     and S to work out the sum, as follows:
\
\     * Subtract the smaller absolute value from the larger absolute value
\
\     * Give the answer the same sign as the argument with the larger absolute
\       value
\
\ To see why this works, try visualising a number line containing the two
\ numbers A and S, with one to the left of zero and one to the right. Adding
\ the numbers is a bit like moving the number with the larger absolute value
\ towards zero on the number line, moving it by the amount of the smaller
\ absolute number; so it's like subtracting the smaller absolute value from the
\ larger one. You can also see that the sum of the two numbers will be on the
\ same side of zero as the number that is furthest from zero, so that's why the
\ answer should have the same sign as the argument with the larger absolute
\ value.
\
\ We can implement these steps like this:
\
\   * If |A| = |S|, then the result is 0
\
\   * If |A| > |S|, then the result is |A| - |S|, with the sign set to the same
\     sign as A
\
\   * If |S| > |A|, then the result is |S| - |A|, with the sign set to the same
\     sign as S
\
\ So that's what we do below to implement 16-bit signed addition that produces
\ results with the correct sign.
\
\ ******************************************************************************

.ADD
{
 STA T1                 \ Store argument A in T1

 AND #128               \ Extract the sign (bit 7) of A and store it in T
 STA T

 EOR S                  \ EOR bit 7 of A with S. If they have different bit 7s
 BMI MU8                \ (i.e. they have different signs) then bit 7 in the
                        \ EOR result will be 1, which means the EOR result is
                        \ negative. So the AND, EOR and BMI together mean "jump
                        \ to MU8 if A and S have different signs"

                        \ If we reach here, then A and S have the same sign, so
                        \ we can add them and set the sign to get the result

 LDA R                  \ Add the least significant bytes together into X, so
 CLC                    \
 ADC P                  \   X = P + R
 TAX

 LDA S                  \ Add the most significant bytes together into A. We
 ADC T1                 \ stored the original argument A in T1 earlier, so we
                        \ can do this with:
                        \
                        \   A = A  + S + carry
                        \     = T1 + S + carry

 ORA T                  \ If argument A was negative (and therefore S was also
                        \ negative) then make sure result A is negative by
                        \ OR-ing the result with the sign bit from argument A
                        \ (which we stored in T)

 RTS                    \ Return from the subroutine

.MU8                    \ If we reach here, then A and S have different signs,
                        \ so we can subtract their absolute values and set the
                        \ sign to get the result

 LDA S                  \ Clear the sign (bit 7) in S and store the result in
 AND #127               \ U, so U now contains |S|
 STA U

 LDA P                  \ Subtract the least significant bytes into X, so
 SEC                    \   X = P - R
 SBC R
 TAX

 LDA T1                 \ Restore the A of the argument (A P) from T1 and
 AND #127               \ clear the sign (bit 7), so A now contains |A|

 SBC U                  \ Set A = |A| - |S|

                        \ At this point we have |A P| - |S R| in (A X), so we
                        \ need to check whether the subtraction above was the
                        \ the right way round (i.e. that we subtracted the
                        \ smaller absolute value from the larger absolute
                        \ value)

 BCS MU9                \ If |A| >= |S|, our subtraction was the right way
                        \ round, so jump to MU9 to set the sign

                        \ If we get here, then |A| < |S|, so our subtraction
                        \ above was the wrong way round (we actually subtracted
                        \ the larger absolute value from the smaller absolute
                        \ value. So let's subtract the result we have in (A X)
                        \ from zero, so that the subtraction is the right way
                        \ round

 STA U                  \ Store A in U

 TXA                    \ Set X = 0 - X using two's complement (to negate a
 EOR #&FF               \ number in two's complement, you can invert the bits
 ADC #1                 \ and add one - and we know carry is clear as we didn't
 TAX                    \ take the BCS branch above, so ADC will do the job)

 LDA #0                 \ Set A = 0 - A, which we can do this time using a
 SBC U                  \ a subtraction with carry clear

 ORA #128               \ We now set the sign bit of A, so that the EOR on the
                        \ next line wil give the result the opposite sign to
                        \ argument A (as T contains the sign bit of argument
                        \ A). This is the same as giving the result the same
                        \ sign as argument S (as A and S have different signs),
                        \ which is what we want, as S has the larger absolute
                        \ value

.MU9

 EOR T                  \ If we get here from the BCS above, then |A| >= |S|,
                        \ so we want to give the result the same sign as
                        \ argument A, so if argument A was negative, we flip
                        \ the sign of the result with an EOR (to make it
                        \ negative)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TIS1
\
\ Calculate the following expression between sign-magnitude numbers, ignoring
\ the low byte of the result:
\
\   (A ?) = (-X * A + (S R)) / 96
\
\ This uses the same "shift and subtract" algorithm as TIS2, just with the
\ quotient A hard-coded to 96.
\
\ Returns:
\
\   Q                   Gets set to the value of argument X
\
\ ******************************************************************************

.TIS1
{
 STX Q                  \ Set Q = X

 EOR #%10000000         \ Flip the sign bit in A

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = X * -A + (S R)

.DVID96

 TAX                    \ Set T to the sign bit of the result
 AND #%10000000
 STA T

 TXA                    \ Set A to the high byte of the result with the sign bit
 AND #%01111111         \ cleared, so (A ?) = |X * A + (S R)|
 
                        \ The following is identical to TIS2, except Q is
                        \ hard-coded to 96, so this does A = A / 96

 LDX #254               \ Set T1 to have bits 1-7 set, so we can rotate through 7
 STX T1                 \ loop iterations, getting a 1 each time, and then
                        \ getting a 0 on the 8th iteration... and we can also
                        \ use T1 to catch our result bits into bit 0 each time

.DVL3

 ASL A                  \ Shift A to the left

 CMP #96                \ If A < 96 skip the following subtraction
 BCC DV4

 SBC #96                \ Set A = A - 96
                        \
                        \ Going into this subtraction we we know the C flag is
                        \ set as we passed through the BCC above, and we also
                        \ know that A >= 96, so the C flag will still be set
                        \ once we are done

.DV4

 ROL T1                 \ Rotate the counter in T1 to the left, and catch the
                        \ result bit into bit 0 (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 BCS DVL3               \ If we still have set bits in T1, loop back to DVL3 to
                        \ do the next iteration of 7

 LDA T1                 \ Fetch the result from T1 into A

 ORA T                  \ Give A the sign of the result that we stored above
 
 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DV42
\
\ Calculate the following division and remainder:
\
\   P = DELTA / (the Y-th stardust particle's z-coordinate)
\
\   R = remainder as a fraction of A, where 1.0 = 255
\
\ This uses the same "shift and subtract" algorithm as TIS2, but this time we
\ keep the remainder.
\
\ Arguments:
\
\   Y                   The number of the stardust particle to process
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.DV42
{
 LDA SZ,Y               \ Fetch the Y-th dust particle's z-coordinate into A
}

\ ******************************************************************************
\
\ Subroutine: DV41
\
\ Calculate the following division and remainder:
\
\   P = DELTA / A
\
\   R = remainder as a fraction of A, where 1.0 = 255
\
\ This uses the same "shift and subtract" algorithm as TIS2, but this time we
\ keep the remainder.
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.DV41
{
 STA Q                  \ Store A in Q

 LDA DELTA              \ Fetch the speed from DELTA into A
}

\ ******************************************************************************
\
\ Subroutine: DVID4
\
\ Calculate the following division and remainder:
\
\   P = A / Q
\
\   R = remainder as a fraction of Q, where 1.0 = 255
\
\ This uses the same "shift and subtract" algorithm as TIS2, but this time we
\ keep the remainder.
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.DVID4
{
 LDX #8                 \ Set a counter in X to count the 8 bits in A

 ASL A                  \ Shift A left and store in P (we will build the result
 STA P                  \ in P)

 LDA #0                 \ Set A = 0 for us to build a remainder

.DVL4

 ROL A                  \ Shift A to the left

 BCS DV8                \ If the C flag is set (i.e. bit 7 of A was set) then
                        \ skip straight to the subtraction

 CMP Q                  \ If A < Q skip the following subtraction
 BCC DV5

.DV8

 SBC Q                  \ A >= Q, so set A = A - Q

 SEC                    \ Set the C flag, so that P gets a 1 shifted into bit 0

.DV5

 ROL P                  \ Shift P to the left, pulling the C flag into bit 0

 DEX                    \ Decrement the loop counter

 BNE DVL4               \ Loop back for the next bit until we have done all 8
                        \ bits of P

 JMP LL28+4             \ Jump to LL28+4 to convert the remainder in A into an
                        \ integer representation of the fractional value A / Q,
                        \ where 1.0 = 255. LL28+4 always returns with the C flag
                        \ cleared, and we return from the subroutine using a
                        \ tail call
}

\ ******************************************************************************
\
\ Subroutine: DVID3B2
\
\ Divide 3 bytes by 2 bytes, K = P.A/INWK_z for planet, Xreg protected.
\
\ ******************************************************************************

.DVID3B2                \ Divide 3 bytes by 2 bytes, K = P.A/INWK_z for planet, Xreg protected
{
 STA P+2                \ num sg
 LDA INWK+6             \ z coord lo
 STA Q
 LDA INWK+7             \ z coord hi
 STA R
 LDA INWK+8             \ z coord sg
 STA S

.DVID3B                 \ K (3bytes)=P(3bytes)/S.R.Q. aprx  Acc equiv K(0)

 LDA P                  \ num lo
 ORA #1                 \ avoid 0
 STA P
 LDA P+2                \ num sg
 EOR S                  \ zsg
 AND #128               \ extract sign
 STA T
 LDY #0                 \ counter
 LDA P+2                \ num sg
 AND #127               \ will look at lower 7 bits of Acc in

.DVL9                   \ counter Y up

 CMP #&40               \ object very far away?
 BCS DV14               \ scaled, exit Ycount
 ASL P
 ROL P+1
 ROL A                  \ 3 bytes
 INY
 BNE DVL9               \ loop Y

.DV14                   \ scaled, exited Ycount

 STA P+2                \ big numerator
 LDA S                  \ zsg
 AND #127               \ denom sg7
 BMI DV9                \ can't happen

.DVL6                   \ counter Y back down, roll S

 DEY                    \ scale Y back
 ASL Q                  \ denom lo
 ROL R
 ROL A                  \ hi S
 BPL DVL6               \ loop roll S until Abit7 set

.DV9                    \ bmi cant happen?

 STA Q                  \ mostly empty so now reuse as hi denom
 LDA #254               \ Xreg protected so can't LL28+4
 STA R
 LDA P+2                \ big numerator
 JSR LL31               \ R now =A*256/Q

 LDA #0                 \ K1to3 = 0
 STA K+1
 STA K+2
 STA K+3
 TYA                    \ Y counter for scale
 BPL DV12               \ Ycount +ve
 LDA R                  \ else Y count is -ve, Acc = remainder

.DVL8                   \ counter Y up

 ASL A                  \ boost up
 ROL K+1
 ROL K+2
 ROL K+3
 INY
 BNE DVL8               \ loop Y up
 STA K                  \ lo
 LDA K+3                \ sign
 ORA T
 STA K+3
 RTS

.DV13                   \ Ycount zero \ K(1to2) already = 0

 LDA R                  \ already correct
 STA K                  \ lo
 LDA T                  \ sign
 STA K+3
 RTS

.DV12                   \ Ycount +ve

 BEQ DV13               \ Ycount zero, up
 LDA R                  \ else reduce remainder

.DVL10                  \ counter Y reduce

 LSR A
 DEY
 BNE DVL10              \ loop Y reduce
 STA K                  \ lo
 LDA T                  \ sign
 STA K+3
 RTS
}

\ ******************************************************************************
\
\ Subroutine: cntr
\
\ Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
\ centre point (so X represents a position on a centre-based dashboard slider,
\ such as pitch or roll). If the value is in the left-hand side of the slider
\ (1-127) then it bumps the value up by 1 so it moves towards towards the
\ centre, and if it's in the right-hand side, it reduces it by 1, also moving
\ it towards the centre.
\
\ ******************************************************************************

.cntr
{
 LDA DAMP               \ If DAMP is non-zero, then keyboard damping is not
 BNE RE1                \ enabled, so jump to RE1 to return from the subroutine

 TXA                    \ If X < 128, then it's in the left-hand side of the
 BPL BUMP               \ dashboard slider, so jump to BUMP to bump it up by 1,
                        \ to move it closer to the centre

 DEX                    \ Otherwise X >= 128, so it's in the right-hand side
 BMI RE1                \ of the dashboard slider, so decrement X by 1, and if
                        \ it's still >= 128, jump to RE1 to return from the
                        \ subroutine, otherwise fall through to BUMP to undo
                        \ the bump and then return

.BUMP

 INX                    \ Bump X up by 1, and if it hasn't ovedrshot the end of
 BNE RE1                \ the dashboard slider, jump to RE1 to return from the
                        \ subroutine, otherwise fall through to REDU to drop
                        \ it down by 1 again

.REDU

 DEX                    \ Reduce X by 1, and if we have reached 0 jump up to
 BEQ BUMP               \ BUMP to add 1, because we need the value to be in the
                        \ range 1 to 255

.RE1

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: BUMP2
\
\ Increase ("bump up") X by A, where X is either the current rate of pitch or
\ the current rate of roll.
\
\ The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
\ This is the amount by which the pitch or roll is currently changing, so 1
\ means it is decreasing at the maximum rate, 128 means it is not changing,
\ and 255 means it is increasing at the maximum rate. These values correspond
\ to the line on the DC or RL indicators on the dashboard, with 1 meaning full
\ left, 128 meaning the middle, and 255 meaning full right.
\
\ If bumping up X would push it past 255, then X is set to 255.
\
\ If keyboard auto-recentre is configured and the result is less than 128, we
\ bump X up to the mid-point, 128. This is the equivalent of having a roll or
\ pitch in the left half of the indicator, when increasing the roll or pitch
\ should jump us straight to the mid-point.
\
\ Other entry points:
\
\   RE2+2               Restore A from T and return from the subroutine. Used by
\                       REDU2
\
\ ******************************************************************************

.BUMP2
{
 STA T                  \ Store argument A in T so we can restore it later

 TXA                    \ Copy argument X into A

 CLC                    \ Clear the carry flag so we can do addition without
                        \ the carry flag affecting the result

 ADC T                  \ Set X = A = argument X + argument A
 TAX

 BCC RE2                \ If carry is clear, then we didn't overflow, so jump
                        \ to RE2 to auto-recentre and return the result

 LDX #255               \ We have an overflow, so set X to the maximum possible
                        \ value, 255

.^RE2

 BPL RE3+2              \ If X has bit 7 clear (i.e. the result < 128), then
                        \ jump to RE3+2 below to do an auto-recentre, if
                        \ configured, because the result is on the left side of
                        \ the centre point of 128

                        \ Jumps to RE2+2 end up here

 LDA T                  \ Restore the original argument A into A

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: REDU2
\
\ Reduce X by A, where X is either the current rate of pitch or the current
\ rate of roll.
\
\ The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
\ This is the amount by which the pitch or roll is currently changing, so 1
\ means it is decreasing at the maximum rate, 128 means it is not changing,
\ and 255 means it is increasing at the maximum rate. These values correspond
\ to the line on the DC or RL indicators on the dashboard, with 1 meaning full
\ left, 128 meaning the middle, and 255 meaning full right.
\
\ If reducing X would bring it below 1, then X is set to 1.
\
\ If keyboard auto-recentre is configured and the result is greater than 128, we
\ reduce X down to the mid-point, 128. This is the equivalent of having a roll
\ or pitch in the right half of the indicator, when decreasing the roll or pitch
\ should jump us straight to the mid-point.
\
\ Other entry points:
\
\   RE3+2               Auto-recentre the value in X, if configured. Used by
\                       BUMP2
\
\ ******************************************************************************

.REDU2
{
 STA T                  \ Store argument A in T so we can restore it later

 TXA                    \ Copy argument X into A

 SEC                    \ Set the carry flag so we can do subtraction without
                        \ the carry flag affecting the result

 SBC T                  \ Set X = A = argument X - argument A
 TAX

 BCS RE3                \ If carry is set, then we didn't underflow, so jump
                        \ to RE3 to auto-recentre and return the result

 LDX #1                 \ We have an underflow, so set X to the minimum possible
                        \ value, 1

.^RE3

 BPL RE2+2              \ If X has bit 7 clear (i.e. the result < 128), then
                        \ jump to RE2+2 above to return the result as is,
                        \ because the result is on the left side of the centre
                        \ point of 128, so we don't need to auto-centre

                        \ Jumps to RE3+2 end up here

                        \ If we get here, then we need to apply auto-recentre,
                        \ if it is configured

 LDA DJD                \ If keyboard auto-recentre is disabled, then
 BNE RE2+2              \ jump to RE2+2 to restore A and return

 LDX #128               \ If keyboard auto-recentre is enabled, set X to 128
 BMI RE2+2              \ (the middle of our range) and jump to RE2+2 to
                        \ restore A and return
}

\ ******************************************************************************
\
\ Subroutine: ARCTAN
\
\ A=TAN-1(P/Q) \ A=arctan (P/Q)  called from block E
\
\ ******************************************************************************

.ARCTAN                 \ A=TAN-1(P/Q) \ A=arctan (P/Q)  called from block E
{
 LDA P
 EOR Q
 STA T1                 \ quadrant info
 LDA Q
 BEQ AR2                \ Q=0 so set angle to 63, pi/2
 ASL A                  \ drop sign
 STA Q
 LDA P
 ASL A                  \ drop sign
 CMP Q
 BCS AR1                \ swop A and Q as A >= Q
 JSR ARS1               \ get Angle for A*32/Q from table
 SEC

.AR4                    \ sub o.k

 LDX T1
 BMI AR3                \ -ve quadrant
 RTS

.AR1                    \ swop A and Q

 LDX Q
 STA Q
 STX P
 TXA
 JSR ARS1               \ get Angle for A*32/Q from table
 STA T                  \ angle
 LDA #64                \ next range of angle, pi/4 to pi/2
 SBC T
 BCS AR4                \ sub o.k

.AR2                    \ set angle to 90 degrees

 LDA #63
 RTS

.AR3                    \ -ve quadrant

 STA T                  \ angle
 LDA #128               \ pi
\SEC
 SBC T                  \ A = 128-T, so now covering range pi/2 to pi correctly
 RTS

.ARS1                   \ get Angle for A*32/Q from table

 JSR LL28               \ BFRDIV R=A*256/Q
 LDA R
 LSR A
 LSR A
 LSR A                  \ 31 max
 TAX                    \ index into table at end of words data
 LDA ACT,X
 RTS
}

\ ******************************************************************************
\
\ Variable: ACT
\
\ Arctan table.
\
\ ******************************************************************************

.ACT
{
FOR I%,0,31
 EQUB INT(128/PI*ATN(I%/32)+.5)
NEXT
}

\ ******************************************************************************
\
\ Subroutine: WARP
\
\ Perform an-system jump. This is called when we press "J" during flight. The
\ following checks are performed:
\
\   * Make sure we don't have any ships or space stations in the vicinity
\
\   * Make sure we are not in witchspace
\
\   * If we are facing the planet, make sure we aren't too close
\
\   * If we are facing the sun, make sure we aren't too close
\
\ If the above checks are passed, then we perform an in-system jump by moving
\ the sun and planet in the opposite direction to travel, so we appear to jump
\ in space. This means that any asteroids, cargo canisters or escape pods get
\ dragged along for the ride.
\
\ ******************************************************************************

.WARP
{
 LDA MANY+AST           \ Set X to the total number of asteroids, escape pods
 CLC                    \ and cargo canisters in the vicinity
 ADC MANY+ESC           \
 CLC                    \ The second CLC instruction appears in the BASIC
 ADC MANY+OIL           \ source file (ELITEC), but not in the text source file
 TAX                    \ (ELITEC.TXT). The second CLC has no effect, as there
                        \ is no way that adding the number of asteroids and the
                        \ number escape pods will cause a carry, so presumably
                        \ it got removed at some point

 LDA FRIN+2,X           \ If the slot at FRIN+2+X is non-zero, then we have
                        \ something else in the vicinity besides asteroids,
                        \ escape pods and cargo canisters, so to check whether
                        \ we can jump, we first grab the slot contents into A

 ORA SSPR               \ If there is a space station nearby, then SSPR will
                        \ be non-zero, so OR'ing with SSPR will produce a
                        \ a non-zero result if either A or SSPR are non-zero

 ORA MJ                 \ If we are in witchspace, then MJ will be non-zero, so
                        \ OR'ing with MJ will produce a non-zero result if
                        \ either A or SSPR or MJ are non-zero

 BNE WA1                \ A is non-zero if we have either a ship or a space
                        \ station in the vicinity, or we are in witchspace, in
                        \ which case jump to WA1 to make a low beep to show that
                        \ we can't do an in-system jump

 LDY K%+8               \ Otherwise we can do an in-system jump, so now we fetch
                        \ the byte at K%+8, which contains the z_sign for the
                        \ first ship slot, i.e. the distance of the planet

 BMI WA3                \ If the planet's z_sign is negative, then the planet
                        \ is behind us, so jump to WA3 to skip the following

 TAY                    \ Set A = Y = 0 (as we didn't BNE above) so the call
                        \ to MAS2 measures the distance to the planet

 JSR MAS2               \ Call MAS2 to set A to the largest distance to the
                        \ planet in any of the three axes (we could also call
                        \ routine m to do the same thing, as A = 0)

                        \ The following two instructions appear in the BASIC
                        \ source file (ELITEC), but in the text source file
                        \ (ELITEC.TXT) they are replaced by:
                        \
                        \   LSR A
                        \   BEQ WA1
                        \
                        \ which does the same thing, but saves one byte of
                        \ memory (as LSR A is a one-byte opcode, while CMP #2
                        \ takes up two bytes)

 CMP #2                 \ If A < 2 then jump to WA1 to abort the in-system jump
 BCC WA1                \ with a low beep, as we are facing the planet and are
                        \ too close to jump in that direction

.WA3

 LDY K%+NI%+8           \ Fetch the z_sign (byte 8) of the second ship in the
                        \ ship data workspace at K%, which is reserved for the
                        \ sun or the space station (in this case it's the
                        \ former, as we already confirmed there isn't a space
                        \ station in the vicinity)

 BMI WA2                \ If the sun's z_sign is negative, then the sun is
                        \ behind us, so jump to WA2 to skip the following

 LDY #NI%               \ Set Y to point to the offset of the ship data block
                        \ for the sun, which is NI% (as each block is NI% bytes
                        \ long, and the sun is the second block)

 JSR m                  \ Call m to set A to the largest distance to the sun
                        \ in any of the three axes

                        \ The following two instructions appear in the BASIC
                        \ source file (ELITEC), but in the text source file
                        \ (ELITEC.TXT) they are replaced by:
                        \
                        \   LSR A
                        \   BEQ WA1
                        \
                        \ which does the same thing, but saves one byte of
                        \ memory (as LSR A is a one-byte opcode, while CMP #2
                        \ takes up two bytes)

 CMP #2                 \ If A < 2 then jump to WA1 to abort the in-system jump
 BCC WA1                \ with a low beep, as we are facing the sun and are too
                        \ close to jump in that direction

.WA2

                        \ If we get here, then we can do an in-system jump, as
                        \ we don't have any ships or space stations in the
                        \ vicinity, we are not in witchspace, and if we are
                        \ facing the planet or the sun, we aren't too close to
                        \ jump towards it
                        \
                        \ We do an in-system jump by moving the sun and planet,
                        \ rather than moving our own little bubble (this is why
                        \ in-system jumps drag asteroids, cargo canisters and
                        \ escape pods along for the ride). Specifically, we move
                        \ them in the z-axis by a fixed amount in the opposite
                        \ direction to travel, thus performing a jump towards
                        \ our destination

 LDA #&81               \ Set R = R = P = &81
 STA S
 STA R
 STA P

 LDA K%+8               \ Set A = z_sign for the planet

 JSR ADD                \ Set (A X) = (A P) + (S R)
                        \           = (z_sign &81) + &8181
                        \           = (z_sign &81) - &0181
                        \
                        \ This moves the planet against the direction of travel
                        \ by reducing z_sign by 1, as the above maths is:
                        \
                        \         z_sign 00000000
                        \   +   00000000 10000001
                        \   -   00000001 10000001
                        \
                        \ or:
                        \
                        \         z_sign 00000000
                        \   +   00000000 00000000
                        \   -   00000001 00000000
                        \
                        \ i.e. the high byte is z_sign - 1, making sure the sign
                        \ is preserved

 STA K%+8               \ Set the planet's z_sign to the high byte of the result

 LDA K%+NI%+8           \ Set A = z_sign for the sun

 JSR ADD                \ Set (A X) = (A P) + (S R)
                        \           = (z_sign &81) + &8181
                        \           = (z_sign &81) - &0181
                        \
                        \ which moves the sun against the direction of travel
                        \ by reducing z_sign by 1

 STA K%+NI%+8           \ Set the planet's z_sign to the high byte of the result

 LDA #1                 \ These instructions have no effect, as the call to
 STA QQ11               \ LOOK1 below starts by setting QQ11 to 0; instead they
                        \ just set the current view type in QQ11 to 1 for the
                        \ duration of the next three instructions

 STA MCNT               \ Set the main loop counter to 1, so the next iteration
                        \ through the main loop will potentially spawn ships
                        \ (see part 2 of the main game loop at me3)

 LSR A                  \ Set EV, the extra vessels spawning counter, to 0
 STA EV                 \ (the LSR produces a 0 as A was previously 1)

 LDX VIEW               \ Set X to the current view (forward, rear, left or
 JMP LOOK1              \ right) and jump to LOOK1 to initialise that view,
                        \ returning from the subroutine with a tail call

.WA1

 LDA #40                \ If we get here then we can't do an in-system jump, so
 JMP NOISE              \ call the NOISE routine with A = 40 to make a long, low
                        \ beep and return from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: LASLI
\
\ Draw the laser lines, aiming them to slightly different place each time so
\ they appear to flicker and dance. Also heat up the laser temperature and drain
\ some energy.
\
\
\ Other entry points:
\
\   LASLI2              Just draw the current laser lines without moving the
\                       centre point, draining energy or heating up. This has
\                       the effect of removing the lines from the screen
\
\ ******************************************************************************

.LASLI
{
 JSR DORND              \ Set A and X to random numbers

 AND #7                 \ Restrict A to a random value in the range 0 to 7

 ADC #Y-4               \ Set LASY to four pixels above the centre of the
 STA LASY               \ screen (#Y), plus our random number, so the laser
                        \ dances above and below the centre point

 JSR DORND              \ Set A and X to random numbers

 AND #7                 \ Restrict A to a random value in the range 0 to 7

 ADC #X-4               \ Set LASX to four pixels left of the centre of the
 STA LASX               \ screen (#X), plus our random number, so the laser
                        \ dances to the left and right of the centre point

 LDA GNTMP              \ Add 8 to the laser temperature in GNTMP
 ADC #8
 STA GNTMP

 JSR DENGY              \ Call DENGY to deplete our energy banks by 1

.^LASLI2

 LDA QQ11               \ If this is not a space view (i.e. QQ11 is non-zero)
 BNE PU1-1              \ then jump to MA9 to return from the main flight loop
                        \ (as PU1-1 is an RTS)

 LDA #32                \ Call las with A = 32 and Y = 224 to draw one set of
 LDY #224               \ laser lines
 JSR las

 LDA #48                \ Fall through into las with A = 48 and Y = 208 to draw
 LDY #208               \ a second set of lines

                        \ The following routine draws two laser lines, one from
                        \ the centre point down to point A on the bottom row,
                        \ and the other from the centre point down to point Y
                        \ on the bottom row. We therefore get lines from the
                        \ centre point to points 32, 48, 208 and 224 along the
                        \ bottom row, giving us the triangular laser effect
                        \ we're after

.las

 STA X2                 \ Set X2 = A

 LDA LASX               \ Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 LDA #2*Y-1             \ Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
 STA Y2                 \ y-coordinate of the mid-point of the space view, so
                        \ this sets Y2 to 191, the y-coordinate of the bottom
                        \ pixel row of the space view

 JSR LOIN               \ Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        \ the centre point to (A, 191)

 LDA LASX               \ Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 STY X2                 \ Set X2 = Y

 LDA #2*Y-1             \ Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
 STA Y2                 \ pixel row of the space view (as before)

 JMP LOIN               \ Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        \ the centre point to (Y, 191), and return from
                        \ the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: PLUT
\
\ This routine flips the relevant geometric axes in INWK depending on which
\ view we are looking through (forward, rear, left, right).
\
\ Other entry points:
\
\   LO2                 Contains an RTS
\
\   PU1-1               Contains an RTS
\
\ ******************************************************************************
\
\ Deep dive: Flipping axes between space views
\ --------------------------------------------
\ The easiest way to think about this is that the z-axis always points into the
\ screen, the y-axis always points up, and the x-axis always points to the
\ right, like this:
\
\     y
\     ^
\     |   z (into screen)
\     |  /
\     | /
\     |/
\     +---------> x
\
\ This rule applies, whichever view we are looking through. So when we're
\ looking through the front view, z is into the screen - in the direction of
\ travel - but if we switch, then the direction of travel is now to our right.
\
\ The local universe is stored as if we are looking forward, so the z-axis is
\ in the direction of travel. This routine takes those stored coordinates and
\ switches the axes around if we are looking bahind us or to the sides, so that
\ we can use the same maths to display what's in that view - in other words, to
\ switch the axes so that the value of the z-coordinate that we've stored in
\ our universe - the direction of travel - is translated into the correct axis
\ for the view we are looking at (for the z-axis, which points into the screen
\ for the front view, we move it to point out of the screen if we are looking
\ backwards, to the right if we're looking out of the left view, or to the left
\ if we are looking out of the right view).
\
\ For the front view, then we change nothing as the default universe is set up
\ for this view (so the coordinates and vectors in K%, UNIV, INWK etc. are
\ already correct for this view). Let's look at the other views in more detail.
\
\ Rear view
\ ---------
\ For the rear view, this is what our original universe axes look like when we
\ we are looking backwards:
\
\                 y
\                 ^
\                 |
\                 |
\                 |
\                 |
\     x <---------+
\                /
\               z (out of screen)
\
\ so to convert these axes into the standard "up, right, into-the-screen" set
\ of axes we need for drawing to the screen, we need to do the changes on the
\ left (with the original set of axes on the right for comparison):
\
\   y                                           y
\   ^                                           ^
\   |   -z (into screen)                        |   z (into screen)
\   |  /                                        |  /
\   | /                                         | /
\   |/                                          |/
\   +---------> -x                              +---------> x
\
\ So to change the INWK workspace from the original axes on the right to the
\ new set on the left, we need to change the signs of the x and z coordinates
\ and vectors in INWK, which we can do by flipping the signs of the following:
\
\   * x_sign, z_sign
\   * nosev_x_hi, nosev_z_hi
\   * roofv_x_hi, roofv_z_hi
\   * sidev_x_hi, sidev_z_hi
\
\ so that's what we do below.
\
\ Left view
\ ---------
\ For the left view, this is what our original universe axes look like when we
\ are looking to the left:
\
\       y
\       ^
\       |
\       |
\       |
\       |
\       +---------> z
\      /
\     /
\    /
\   x (out of screen)
\
\ so to convert these axes into the standard "up, right, into-the-screen" set
\ of axes we need for drawing to the screen, we need to do the changes on the
\ left (with the original set of axes on the right for comparison):
\
\   y                                           y
\   ^                                           ^
\   |   -x (into screen)                        |   z (into screen)
\   |  /                                        |  /
\   | /                                         | /
\   |/                                          |/
\   +---------> z                               +---------> x
\
\ In other words, to go from the original set of axes on the right to the new
\ set of axes on the left, we need to swap the x- and z-axes around, and flip
\ the sign of the one now going in and out of the screen (i.e. the new z-axis).
\ In other words, we swap the following values in INWK:
\
\   * x_lo and z_lo
\   * x_hi and z_hi
\   * x_sign and z_sign
\   * nosev_x_lo and nosev_z_lo
\   * roofv_x_lo and roofv_z_lo
\   * sidev_x_lo and sidev_z_lo
\
\ and then change the sign of the axis going in and out of the screen by
\ flipping the signs of the following:
\
\   * z_sign
\   * nosev_z_hi
\   * roofv_z_hi
\   * sidev_z_hi
\
\ So this is what we do below.
\
\ Right view
\ ---------
\ For the right view, this is what our original universe axes look like when we
\ are looking to the right:
\
\               y
\               ^
\               |   x (into screen)
\               |  /
\               | /
\               |/
\   z <---------+
\
\ so to convert these axes into the standard "up, right, into-the-screen" set
\ of axes we need for drawing to the screen, we need to do the changes on the
\ left (with the original set of axes on the right for comparison):
\
\   y                                           y
\   ^                                           ^
\   |   x (into screen)                         |   z (into screen)
\   |  /                                        |  /
\   | /                                         | /
\   |/                                          |/
\   +---------> -z                              +---------> x
\
\ In other words, to go from the original set of axes on the right to the new
\ set of axes on the left, we need to swap the x- and z-axes around, and flip
\ the sign of the one now going to the right (i.e. the new x-axis). In other
\ words, we swap the following values in INWK:
\
\   * x_lo and z_lo
\   * x_hi and z_hi
\   * x_sign and z_sign
\   * nosev_x_lo and nosev_z_lo
\   * roofv_x_lo and roofv_z_lo
\   * sidev_x_lo and sidev_z_lo
\
\ and then change the sign of the axis going to the right by flipping the signs
\ of the following:
\
\   * x_sign
\   * nosev_x_hi
\   * roofv_x_hi
\   * sidev_x_hi
\
\ So this is what we do below.
\
\ ******************************************************************************

.PLUT
{
 LDX VIEW               \ Load the current view into X:
                        \
                        \   0 = forward
                        \   1 = rear
                        \   2 = left
                        \   3 = right


 BNE PU1                \ If the current view is forward, return from the
 RTS                    \ subroutine, as the geometry in INWK is already
                        \ correct

.^PU1

 DEX                    \ Decrement the view, so now:
                        \
                        \   0 = rear
                        \   1 = left
                        \   2 = right

 BNE PU2                \ If the current view is left or right, jump to PU2,
                        \ otherwise this is the rear view, so continue on

 LDA INWK+2             \ Flip the sign of x_sign
 EOR #%10000000
 STA INWK+2

 LDA INWK+8             \ Flip the sign of z_sign
 EOR #%10000000
 STA INWK+8

 LDA INWK+10            \ Flip the sign of nosev_x_hi
 EOR #%10000000
 STA INWK+10

 LDA INWK+14            \ Flip the sign of nosev_z_hi
 EOR #%10000000
 STA INWK+14

 LDA INWK+16            \ Flip the sign of roofv_x_hi
 EOR #%10000000
 STA INWK+16

 LDA INWK+20            \ Flip the sign of roofv_z_hi
 EOR #%10000000
 STA INWK+20

 LDA INWK+22            \ Flip the sign of sidev_x_hi
 EOR #%10000000
 STA INWK+22

 LDA INWK+26            \ Flip the sign of roofv_z_hi
 EOR #%10000000
 STA INWK+26

 RTS                    \ Return from the subroutine

.PU2                    \ We enter this with X set to the view, as follows:
                        \
                        \   1 = left
                        \   2 = right

 LDA #0                 \ Set RAT2 = 0 (left view) or -1 (right view)
 CPX #2
 ROR A
 STA RAT2

 EOR #%10000000         \ Set RAT = -1 (left view) or 0 (right view)
 STA RAT

 LDA INWK               \ Swap x_lo and z_lo
 LDX INWK+6
 STA INWK+6
 STX INWK

 LDA INWK+1             \ Swap x_hi and z_hi
 LDX INWK+7
 STA INWK+7
 STX INWK+1

 LDA INWK+2             \ Swap x_sign and z_sign
 EOR RAT                \ If left view, flip sign of new z_sign
 TAX                    \ If right view, flip sign of new x_sign
 LDA INWK+8
 EOR RAT2
 STA INWK+2
 STX INWK+8

 LDY #9                 \ Swap nosev_x_lo and nosev_z_lo
 JSR PUS1               \ Swap nosev_x_hi and nosev_z_hi
                        \ If left view, flip sign of new nosev_z_hi
                        \ If right view, flip sign of new nosev_x_hi

 LDY #15                \ Swap roofv_x_lo and roofv_z_lo
 JSR PUS1               \ Swap roofv_x_hi and roofv_z_hi
                        \ If left view, flip sign of new roofv_z_hi
                        \ If right view, flip sign of new roofv_x_hi

 LDY #21                \ Swap sidev_x_lo and sidev_z_lo
                        \ Swap sidev_x_hi and sidev_z_hi
                        \ If left view, flip sign of new sidev_z_hi
                        \ If right view, flip sign of new sidev_x_hi

.PUS1

 LDA INWK,Y             \ Swap the low x and z bytes for the vector in Y:
 LDX INWK+4,Y           \
 STA INWK+4,Y           \   * For Y =  9 swap nosev_x_lo and nosev_z_lo
 STX INWK,Y             \   * For Y = 15 swap roofv_x_lo and roofv_z_lo
                        \   * For Y = 21 swap sidev_x_lo and sidev_z_lo

 LDA INWK+1,Y           \ Swap the high x and z bytes for the offset in Y:
 EOR RAT                \
 TAX                    \   * If left view, flip sign of new z-coordinate
 LDA INWK+5,Y           \   * If right view, flip sign of new x-coordinate
 EOR RAT2
 STA INWK+1,Y
 STX INWK+5,Y

                        \ Fall through into LOOK1 to return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: LOOK1
\
\ Initialise the space view, with the direction of view given in X. This clears
\ the upper screen and draws the laser crosshairs, if the view in X has lasers
\ fitted. It also wipes all the ships from the scanner, so we can recalculate
\ ship positions for the new view (they get put back in the main flight loop).
\
\ Arguments:
\
\   X                   The space view to set:
\
\                         * 0 = forward
\
\                         * 1 = rear
\
\                         * 2 = left
\
\                         * 3 = right
\
\ ******************************************************************************

{
.LO2

 RTS                    \ Return from the subroutine

.LQ

 STX VIEW               \ Set the current space view to X

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR SIGHT              \ Draw the laser crosshairs

 JMP NWSTARS            \ Set up a new new stardust field and return from the
                        \ subroutine using a tail call

.^LOOK1

 LDA #0                 \ Set A = 0, the type number of a space view

 LDY QQ11               \ If the current view is not a space view, jump up to LQ
 BNE LQ                 \ to set up a new space view

 CPX VIEW               \ If the current view is already of type X, jump to LO2
 BEQ LO2                \ to return from the subroutine (as LO2 contains an RTS)

 STX VIEW               \ Change the current space view to X

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR FLIP               \ Swap the stardust X and Y blocks

 JSR WPSHPS             \ Wipe all the ships from the scanner

                        \ And fall through into SIGHT to draw the laser
                        \ crosshairs
.SIGHT

 LDY VIEW               \ Fetch the laser power for our new view, and if it is
 LDA LASER,Y            \ zero (i.e. there is no laser fitted to this view),
 BEQ LO2                \ jump to LO2 to return from the subroutine (as LO2
                        \ contains an RTS)

 LDA #128               \ Set QQ19 to the x-coordinate of the centre of the
 STA QQ19               \ screen

 LDA #Y-24              \ Set QQ19+1 to the y-coordinate of the centre of the
 STA QQ19+1             \ screen, minus 24 (because TT15 will add 24 to the
                        \ coordinate when it draws the crosshairs)

 LDA #20                \ Set QQ19+2 to size 20 for the crosshairs size
 STA QQ19+2

 JSR TT15               \ Call TT15 to draw crosshairs of size 20 just to the
                        \ left of the middle of the screen

 LDA #10                \ Set QQ19+2 to size 10 for the crosshairs size
 STA QQ19+2

 JMP TT15               \ Call TT15 to draw crosshairs of size 10 at the same
                        \ location, which will remove the centre part from the
                        \ laser crosshairs, leaving a gap in the middle, and
                        \ return from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT66
\
\ Clear the top part of the screen (mode 4), draw a white border, and set the
\ current view type in QQ11 to A.
\
\ Arguments:
\
\   A                   The type of the new current view (see QQ11 for a list of
\                       view types)
\
\ Other entry points:
\
\   TT66-2              Call TT66 with A = 1
\
\ ******************************************************************************

{
 LDA #1

.^TT66

 STA QQ11               \ Set the current view type in QQ11 to A

                        \ Fall through into TTX66 to clear the screen and draw a
                        \ white border
}

\ ******************************************************************************
\
\ Subroutine: TTX66
\
\ Clear the top part of the screen (the mode 4 part) and draw a white border
\ along the top and sides.
\
\ Other entry points:
\
\   BOX                 Just draw the border and (if this is a space view) the
\                       view name. This can be used to remove the border and
\                       view name, as it is drawn using EOR logic
\
\ ******************************************************************************

.TTX66
{
 LDA #128               \ Set QQ17 to 128, which denotes Sentence Case
 STA QQ17

 ASL A                  \ Set LASCT to 0, as 128 << 1 = %10000000 << 1 = 0. This
 STA LASCT              \ stops any laser pulsing. This instruction is STA LS2
                        \ in the text source file ELITEC.TXT

 STA DLY                \ Set the delay in DLY to 0, to indicate that we are
                        \ no longer showing an in-flight message, so any new
                        \ in-flight messages will be shown instantly

 STA de                 \ Clear de, the flag that appends " DESTROYED" to the
                        \ end of the next text token, so that it doesn't

 LDX #&60               \ Set X to the screen memory page for the top row of the
                        \ screen (as screen memory starts at &6000)

.BOL1

 JSR ZES1               \ Call ZES1 below to zero-fill the page in X, which
                        \ clears that character row on the screen

 INX                    \ Increment X to point to the next page, i.e. the next
                        \ character row

 CPX #&78               \ Loop back to BOL1 until we have cleared page &7700,
 BNE BOL1               \ the last character row in the space view part of the
                        \ screen (the mode 4 part)

 LDX QQ22+1             \ Fetch into X the number that's shown on-screen during
                        \ the hyperspace countdown

 BEQ BOX                \ If the counter is zero then we are not counting down
                        \ to hyperspace, so jump to BOX to skip the next
                        \ instruction

 JSR ee3                \ Print the 8-bit number in X at text location (0, 1),
                        \ i.e. print the hyperspace countdown in the top-left
                        \ corner

.^BOX                   \ front view box but no title if menu id > 0

 LDY #1                 \ Move the text cursor to row 1
 STY YC

 LDA QQ11               \ If this is not a space view, jump to tt66 to skip
 BNE tt66               \ displaying the view name

 LDY #11                \ Move the text cursor to row 11
 STY XC

 LDA VIEW               \ Load the current view into A:
                        \
                        \   0 = front
                        \   1 = rear
                        \   2 = left
                        \   3 = right

 ORA #&60               \ OR with &60 so we get a value of &60 to &63 (96 to 99)

 JSR TT27               \ Print recursive token 96 to 99, which will be in the
                        \ range "FRONT" to "RIGHT"

 JSR TT162              \ Print a space

 LDA #175               \ Print recursive token 15 ("VIEW ")
 JSR TT27

.tt66

 LDX #0                 \ Set (X1, Y1) to (0, 0)
 STX X1
 STX Y1

 STX QQ17               \ Set QQ17 = 0 to set ALL CAPS

 DEX                    \ Set X2 = 255
 STX X2

 JSR HLOIN              \ Draw a horizontal line from (X1, Y1) to (X2, Y1), so
                        \ that's (0, 0) to (255, 0), along the very top of the
                        \ screen

 LDA #2                 \ Set X1 = X2 = 2
 STA X1
 STA X2

 JSR BOS2               \ Call BOS2 below, which will call BOS1 twice, and then
                        \ fall through into BOS2 again, so we effectively do
                        \ BOS1 four times, decrementing X1 and X2 each time
                        \ before calling LOIN, so this whole loop-within-a-loop
                        \ mind-bender ends up drawing these four lines:
                        \
                        \   (1, 0)   to (1, 191)
                        \   (0, 0)   to (0, 191)
                        \   (255, 0) to (255, 191)
                        \   (254, 0) to (254, 191)
                        \
                        \ So that's a 2-pixel wide vertical border along the
                        \ left edge of the upper, mode 4 part of the screen, and
                        \ a 2-pixel wide vertical border along the right edge

.BOS2

 JSR BOS1               \ Call BOS1 below and then fall through into it, which
                        \ ends up running BOS1 twice. This is all part of the
                        \ loop-the-loop border-drawing mind-bender explained
                        \ above

.BOS1

 LDA #0                 \ Set Y1 = 0
 STA Y1

 LDA #2*Y-1             \ Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
 STA Y2                 \ y-coordinate of the mid-point of the space view, so
                        \ this sets Y2 to 191, the y-coordinate of the bottom
                        \ pixel row of the space view

 DEC X1                 \ Decrement X1 and X2
 DEC X2

 JMP LOIN               \ Draw a line from (X1, Y1) to (X2, Y2), and return from
                        \ the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: DELAY-5
\
\ Short delay
\
\ ******************************************************************************

 LDY #2
 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A0 &08, or BIT &08A0, which does nothing bar
                        \ affecting the flags

\ ******************************************************************************
\
\ Subroutine: DEL8
\
\ Wait for 8/50 of a second (0.16 seconds).
\
\ ******************************************************************************

.DEL8
{
 LDY #8                 \ Set Y to 8 vertical syncs and fall through into DELAY
                        \ to wait for this long
}

\ ******************************************************************************
\
\ Subroutine: DELAY
\
\ Wait for the number of vertical syncs given in Y, so this effectively waits
\ for Y/50 of a second (as the vertical sync occurs 50 times a second).
\
\ Arguments:
\
\   Y                   The number of vertical sync events to wait for
\
\ ******************************************************************************

.DELAY
{
 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn

 DEY                    \ Decrement the counter in Y

 BNE DELAY              \ If Y isn't yet at zero, jump back to DELAY to wait
                        \ for another vertical sync

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: hm
\
\ Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
\ system, redraw the crosshairs on the chart accordingly (if they are being
\ shown), and, if this is not a space view, clear the bottom three text rows of
\ the screen.
\
\ ******************************************************************************

.hm
{
 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will draw the crosshairs at our current home
                        \ system

 LDA QQ11               \ If this is a space view, return from the subroutine
 BEQ SC5                \ (as SC5 contains an RTS)

                        \ Otherwise fall through into CLYNS to clear space at
                        \ the bottom of the screen
}

\ ******************************************************************************
\
\ Subroutine: CLYNS
\
\ Clear some space at the bottom of the screen and move the text cursor to
\ column 1, row 21. Specifically, this zeroes the following screen locations:
\
\   &7507 to &75F0
\   &7607 to &76F0
\   &7707 to &77F0
\
\ which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
\ clearing each row from text column 1 to 30 (so it doesn't overwrite the box
\ border in columns 0 and 32, or the last usable column in column 31).
\
\ Returns:
\
\   A                   A is set to 0
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.CLYNS
{
 LDA #20                \ Move the text cursor to row 20, near the bottom of
 STA YC                 \ the screen

 LDA #&75               \ Set the two-byte value in SC to &7507
 STA SC+1
 LDA #7
 STA SC

 JSR TT67               \ Print a newline, which will move the text cursor down
                        \ a line (to row 21) and back to column 1

 LDA #0                 \ Call LYN to clear the pixels from &7507 to &75F0
 JSR LYN

 INC SC+1               \ Increment SC+1 so SC points to &7607

 JSR LYN                \ Call LYN to clear the pixels from &7607 to &76F0

 INC SC+1               \ Increment SC+1 so SC points to &7707

 INY                    \ Move the text cursor to column 1 (as LYN sets Y to 0)
 STY XC

                        \ Fall through into LYN to clear the pixels from &7707
                        \ to &77F0
}

\ ******************************************************************************
\
\ Subroutine: LYN
\
\ Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
\
\ Arguments:
\
\   A                   The value to store in pixels 1-233 (the only value that
\                       is actually used is A = 0, which clears those pixels)
\
\ Returns:
\
\   Y                   Y is set to 0
\
\ Other entry points:
\
\   SC5                 Contains an RTS
\
\ ******************************************************************************

.LYN
{
 LDY #233               \ Set up a counter in Y to count down from pixel 233

.EE2

 STA (SC),Y             \ Store A in the Y-th byte after the address pointed to
                        \ by SC

 DEY                    \ Decrement Y

 BNE EE2                \ Loop back until Y is zero

.^SC5

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: SCAN
\
\ Display the current ship on the scanner.
\
\
\ Arguments:
\
\   INWK                The ship's data block
\
\ ******************************************************************************
\
\ Deep dive: The 3D scanner
\ -------------------------
\ To display a ship on the iconic 3D scanner in Elite, there are six main hoops
\ we have to jump through.
\ 
\ We start with the ship's coordinates in space, given relative to our position
\ (and therefore relative to the centre of the ellipse in the scanner, which
\ represents our ship). Let's call the other ship's coordinates (x, y, z), with
\ our position being at the origin (0, 0, 0).
\ 
\ We want to display a dot on the scanner at the ship's position, as well as a
\ stick that drops down (or rises up) from the dot onto the scanner's ellipse.
\ 
\ The steps we have to perform are as follows:
\ 
\   1. Check that the ship is within the scanner range (and stop if it isn't)
\ 
\   2. Set X1 = the screen x-coordinate of the ship's dot (and stick)
\ 
\   3. Set SC = the screen y-coordinate of the base of the ship's stick
\ 
\   4. Set A = the screen height of the ship's stick
\ 
\   5. Use these values to calculate Y1, the screen y-coordinate of the ship's
\      dot
\ 
\   6. Draw the dot at (X1, Y1) and draw a stick of length A from that dot (up
\      or down as appropriate)
\ 
\ Before looking at these steps individually, first we need to talk about the
\ scanner's dimensions.
\ 
\ Scanner dimensions
\ ------------------
\ In terms of screen coordinates, the scanner is laid out as follows.
\ 
\ The rectangle containing the scanner and compass has the following range of
\ screen coordinates inside the rectangle (so we definitely don't want to draw
\ anything outside these values, or the scanner will leak out into the
\ surrounding dashboard and space view):
\ 
\   * x-coordinate from  50 to 204
\   * y-coordinate from 193 to 246
\ 
\ The scanner's ellipse is 138 screen coordinates wide and 36 screen coordinates
\ high, and the range of coordinates is:
\ 
\   * x-coordinate from  56 to 192
\   * y-coordinate from 204 to 239
\ 
\ The centre of the scanner is at (124, 220).
\ 
\ That said, this routine restricts itself to a slightly smaller range when
\ passing coordinates to the drawing routines, only drawing dots and sticks
\ within this range:
\ 
\   * x-coordinate from  60 to 186
\   * y-coordinate from 194 to 246
\ 
\ These values are explained in the following.
\ 
\ Now that we know the screen area in which we are going to show our ships,
\ let's look at the different things we have to do.
\ 
\ Check the ship is in range
\ --------------------------
\ Elite does a simple check to see whether to show a ship on the scanner. Ship
\ coordinates are stored in the INWK workspace using three bytes, like this:
\ 
\   x = (x_sign x_hi x_lo)
\   y = (y_sign y_hi y_lo)
\   z = (z_sign z_hi z_lo)
\ 
\ The sign bytes only use bit 7, so the actual value is in the high and low
\ bytes (these two bytes store the absolute value, without the sign).
\ 
\ A ship should be shown on the scanner if bits 7 and 6 of all the high bytes
\ are 0. This means that ships to be shown on the scanner have high bytes in the
\ range 0-63, as 63 = %00111111, and because the sign is kept separately, it
\ means that for ships that we show on the scanner, the following are true:
\ 
\   -63 <= x_hi <= 63
\   -63 <= y_hi <= 63
\   -63 <= z_hi <= 63
\ 
\ We can now move on to calculating the screen coordinates of the dot and stick.
\ 
\ Calculate the x-coordinate
\ --------------------------
\ The x-coordinate is the easiest, as all we have to do is scale x so that it
\ fits into the horizontal range of the scanner... and it turns out that the
\ range of (x_sign x_hi) is already pretty close to the full width of the
\ scanner (the ellipse is 138 screen coordinates wide, while the range of
\ (x_sign x_hi) values from -63 to +63 is 127, which is in the right ballpark).
\ 
\ So if we take the x-coordinate of the centre of the scanner, 124, and add
\ (x_sign x_hi), we get a range of 61 to 187, which fits nicely within the the
\ ellipse range of 56 to 192 and is quick and easy to calculate.
\ 
\ There is one small tweak to this, however. If we add 124 to (x_sign x_hi),
\ then if the other ship is dead ahead of us - i.e. when (x_sign x_hi) = 0 - the
\ dot will be drawn with the left pixel on the centre line and the right pixel
\ just to the right of the line. This isn't a problem, but because we draw the
\ stick down (or up) from the right-hand pixel, this means that ships that are
\ dead ahead have a stick that lands on the ellipse just to the right of the
\ centre line. So to fix this, we actually add 123 to get the scanner
\ x-coordinate, as this not only moves the stick to the correct spot, it also
\ has the benefit of making the end-points even numbers, as the range of 123 +
\ (x_sign x_hi) is 60 to 186 (and even numbers are good news when your pixels
\ are always 2 screen coordinates wide).
\ 
\ So this is how we get the screen x-coordinate of the ship on the scanner:
\ 
\   X1 = 123 + (x_sign x_hi)
\   
\ This was the easy one. Now for the y-coordinate of the base of the stick,
\ which is a bit more challenging.
\ 
\ Calculate the base of the stick
\ ---------------------------------
\ We already know the x-coordinate of dot, as we just calculated that, and the
\ stick will have the same x-coordinate as the dot, though we will add 1 when
\ drawing it, as the stick is on the right side of the 2-pixel-wide dot. So we
\ already know the x-coordinate of the base of the stick - now to find the
\ y-coordinate.
\ 
\ The main observation here is that the scanner's ellipse is a plane in space,
\ and for every point in that plane, the space y-coordinate is zero, and the
\ space x- and z-coordinates determine where those points appear, either from
\ left to right (for the x-axis) or front to back (the z-axis). We've already
\ worked out where the base of the stick is in terms of left and right, but what
\ about front to back?
\ 
\ If you think about it, points on the ellipse that are further in front of us
\ will be further up the screen, while those behind us will be lower down the
\ screen. It turns out that this is an easy way to work out the y-coordinate of
\ the base of the stick - we just take the space y-coordinate and scale it so
\ that it fits into the height of the ellipse on screen. As long as we reverse
\ things so that large positive y-coordinates (far in front of us) are scaled to
\ smaller screen y-coordinates (higher up the screen), this should work pretty
\ well.
\ 
\ The maths for this is relatively simple. We take (z_sign z_hi), which is in
\ the range -63 to +63, divide it by 4 to get a range of -15 to +15, and then
\ negate it. We then add this to the coordinate of the centre of the ellipse,
\ which is at screen y-coordinate 220, to get the following:
\ 
\   SC = 220 - (z_sign z_hi) / 4
\ 
\ This is in the range 205 to 235, which is really close to the range of
\ y-coordinates of the ellipse on screen (204 to 239), and fits within the
\ ellipse nicely.
\ 
\ Next, we need to work out the height of the stick, and then we'll have all the
\ information we need to draw this thing.
\ 
\ Convert the stick height
\ ------------------------
\ The stick height should be a signed number that contains the number of pixels
\ in the stick, with the sign set so that we can get the dot's y-coordinate by
\ adding the height to the y-coordinate of the base of the stick. This means
\ that we want the following to be true:
\ 
\   * The stick height should be negative for dots above the ellipse (as the dot
\     is above the base of the stick, so it has a lower y-coordinate)
\ 
\   * The stick height should be zero for dots on the ellipse
\ 
\   * The stick height should be positive for dots below the ellipse (as the dot
\     is below the base of the stick, so it has a lower y-coordinate)
\ 
\ The main observation here is that the length of the stick is effectively the
\ same as the ship's y-coordinate in space, just negated. Specifically:
\ 
\   * If the y-coordinate is 0, then the dot is in the plane of the ellipse and
\     there is no stick
\ 
\   * If the y-coordinate is positive, then the ship is above us and the stick
\     length should be negative
\ 
\   * If the y-coordinate is negative, then the ship is above us and the stick
\     length should be positive
\ 
\   * The further the ship is above or below us, the longer the stick
\ 
\ It turns out that it's good enough just to scale the y-coordinate to get the
\ stick length. Sure, if you were building an accurate scanner than the stick
\ length would also have to be scaled for reasons of perspective, but this is an
\ 8-bit space simulation from 1984 where every processor cycle counts, and the
\ following approximation is easily good enough.
\ 
\ It also turns out that dividing the y-coordinate by 2 does a good enough job.
\ We take (y_sign y_hi), which is in the range -63 to +63, and divide it by 2 to
\ get a range of -31 to +31. As we noted above, the y-coordinate for the base of
\ the stick is in the range 205 to 235, so this means the range of screen
\ y-coordinates for our dots comes out as 174 to 266.
\ 
\ But this is a bit of a problem - the dashboard only covers y-coordinates from
\ 193 to 246, so quite a few of the more distant dots will end up spilling out
\ of the dashboard if we don't do something about it. The solution is pretty
\ simple - if the dot is outside of the dashboard limits, we move it back
\ inside. This does mean that the dots and sticks of distant ships don't behave
\ correctly - they get shifted up or down to keep them within the dashboard,
\ which isn't correct - but somehow our brains don't seem to care. The stick
\ heights still remain correct, and the orientation of these outliers is still
\ generally in the right direction, so we can get away with this simplification.
\ 
\ In terms of this clipping, we actually clip the dot's y-coordinate so that it
\ is in the range 194 to 246, rather than 193 to 246. This is because the
\ double-height dot-drawing routine at CPIX2 takes the coordinate of the bottom
\ row of the dot, so we have to restrict it to a minimum of 194, as passing 193
\ would draw a dot that overlapped the top border of the dashboard.
\ 
\ So this is how we calculate the stick height from the ship's y-coordinate in
\ space:
\ 
\   A = - (y_sign y_hi) / 2
\ 
\ and clip the result so that it's in the range 193 to 246.
\
\ ******************************************************************************

.SCAN
{
 LDA INWK+31            \ Fetch the ship's scanner flag from INWK+31

 AND #16                \ If bit 4 is clear then the ship should not be shown
 BEQ SC5                \ on the scanner, so return from the subroutine (as SC5
                        \ contains an RTS)

 LDA TYPE               \ Fetch the ship's type from TYPE into A

 BMI SC5                \ If this is the planet or the sun, then the type will
                        \ have bit 7 set and we don't want to display it on the
                        \ scanner, so return from the subroutine (as SC5
                        \ contains an RTS)

 LDX #&FF               \ Set X to the default scanner colour of green/cyan
                        \ (a 4-pixel mode 5 byte in colour 3)

\CMP #TGL               \ These instructions are commented out in the original
\BEQ SC49               \ source. Along with the block just below, they would
                        \ set X to colour 1 (red) for asteroids, cargo canisters
                        \ and escape pods, rather than green/cyan. Presumably
                        \ they decided it didn't work that well against the red
                        \ ellipse and took this code out for release

 CMP #MSL               \ If this is not a missile, skip the following
 BNE P%+4               \ instruction

 LDX #&F0               \ This is a missile, so set X to colour 2 (yellow/white)

\CMP #AST               \ These instructions are commented out in the original
\BCC P%+4               \ source. See above for an explanation of what they do
\LDX #&0F
\.SC49

 STX COL                \ Store X, the colour of this ship on the scanner, in
                        \ COL

 LDA INWK+1             \ If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
 ORA INWK+4             \ then the ship is too far away to be shown on the
 ORA INWK+7             \ scanner, so return from the subroutine (as SC5
 AND #%11000000         \ contains an RTS)
 BNE SC5

                        \ If we get here, we know x_hi, y_hi and z_hi are all
                        \ 63 (%00111111) or less

                        \ Now, we convert the x_hi coordinate of the ship into
                        \ the screen x-coordinate of the dot on the scanner,
                        \ using the following (see above for an explanation):
                        \
                        \   X1 = 123 + (x_sign x_hi)

 LDA INWK+1             \ Set x_hi

 CLC                    \ Clear the C flag so we can do addition below

 LDX INWK+2             \ Set X = x_sign

 BPL SC2                \ If x_sign is positive, skip the following

 EOR #%11111111         \ x_sign is negative, so flip the bits in A and subtract
 ADC #1                 \ 1 to make it a negative number (bit 7 will now be set
                        \ as we confirmed above that bits 6 and 7 are clear). So
                        \ this gives A the sign of x_sign and gives it a value
                        \ range of -63 (%11000001) to 0

.SC2

 ADC #123               \ Set X1 = 123 + x_hi
 STA X1
                        \ Next, we convert the z_hi coordinate of the ship into
                        \ the y-coordinate of the base of the ship's stick,
                        \ like this (see above for an explanation):
                        \
                        \   SC = 220 - (z_sign z_hi) / 4
                        \
                        \ though the following code actually does it like this:
                        \
                        \   SC = 255 - (35 + z_hi / 4)

 LDA INWK+7             \ Set A = z_hi / 4
 LSR A                  \
 LSR A                  \ So A is in the range 0-15

 CLC                    \ Clear the C flag

 LDX INWK+8             \ Set X = z_sign

 BPL SC3                \ If z_sign is positive, skip the following

 EOR #%11111111         \ z_sign is negative, so flip the bits in A and set the
 SEC                    \ C flag. As above, this makes A negative, this time
                        \ with a range of -16 (%11110000) to -1 (%11111111). And
                        \ as we are about to do an ADC, the SEC effectively adds
                        \ another 1 to that value, giving a range of -15 to 0

.SC3

 ADC #35                \ Set A = 35 + A to give a number in the range 20 to 50

 EOR #%11111111         \ Flip all the bits and store in SC, so SC is in the
 STA SC                 \ range 205 to 235, with a higher z_hi giving a lower SC

                        \ Now for the stick height, which we calculate using the
                        \ following (see above for an explanation):
                        \
                        \ A = - (y_sign y_hi) / 2

 LDA INWK+4             \ Set A = y_hi / 2
 LSR A

 CLC                    \ Clear the C flag

 LDX INWK+5             \ Set X = y_sign

 BMI SCD6               \ If y_sign is negative, skip the following, as we
                        \ already have a positive value in A

 EOR #%11111111         \ y_sign is positive, so flip the bits in A and set the
 SEC                    \ C flag. This makes A negative, and as we are about to
                        \ do an ADC below, the SEC effectively adds another 1 to
                        \ that value to implement two's complement negation, so
                        \ we don't need to add another 1 here

.SCD6                   \ We now have all the information we need to draw this
                        \ ship on the scanner, namely:
                        \
                        \   X1 = the screen x-coordinate of the ship's dot
                        \
                        \   SC = the screen y-coordinate of the base of the
                        \        stick
                        \
                        \   A = the screen height of the ship's stick, with the
                        \       correct sign for adding to the base of the stick
                        \       to get the dot's y-coordinate
                        \
                        \ First, though, we have to make sure the dot is inside
                        \ the dashboard, by moving it if necessary

 ADC SC                 \ Set A = SC + A, so A now contains the y-coordinate of
                        \ the end of the stick, plus the length of the stick, to
                        \ give us the screen y-coordinate of the dot

 BPL ld246              \ If the result has bit 0 clear, then the result has
                        \ overflowed and is bigger than 256, so jump to ld246 to
                        \ set A to the maximum allowed value of 246 (this
                        \ instruction isn't required as we test both the maximum
                        \ and minimum below, but it might save a few cycles)

 CMP #194               \ If A >= 194, skip the following instruction, as 194 is
 BCS P%+4               \ the minimum allowed value of A

 LDA #194               \ A < 194, so set A to 194, the minimum allowed value
                        \ for the y-coordinate of our ship's dot

 CMP #247               \ If A < 247, skip the following instruction, as 246 is
 BCC P%+4               \ the maximum allowed value of A

.ld246

 LDA #246               \ A >= 247, so set A to 246, the maximum allowed value
                        \ for the y-coordinate of our ship's dot

 STA Y1                 \ Store A in Y1, as it now contains the screen 
                        \ y-coordinate for the ship's dot, clipped so that it
                        \ fits within the dashboard

 SEC                    \ Set A = A - SC to get the stick length, by reversing
 SBC SC                 \ the ADC SC we did above. This clears the C flag if the
                        \ result is negative (i.e. the stick length is negative)
                        \ and sets it if the result is positive (i.e. the stick
                        \ length is negative)

                        \ So now we have the following:
                        \
                        \   X1 = the screen x-coordinate of the ship's dot,
                        \        clipped to fit into the dashboard
                        \
                        \   Y1 = the screen y-coordinate of the ship's dot,
                        \        clipped to fit into the dashboard
                        \
                        \   SC = the screen y-coordinate of the base of the
                        \        stick
                        \
                        \   A = the screen height of the ship's stick, with the
                        \       correct sign for adding to the base of the stick
                        \       to get the dot's y-coordinate
                        \
                        \   C = 0 if A is negative, 1 if A is positive
                        \
                        \ and we can get on with drawing the dot and stick

 PHP                    \ Store the flags (specifically the C flag) from the
                        \ above subtraction

\BCS SC48               \ These instructions are commented out in the original
\EOR #&FF               \ source. They would negate A if the C flag were set,
\ADC #1                 \ which would reverse the direction of all the sticks.
                        \ Goodness knows why you would want to do that, but
                        \ there you go

.SC48

 PHA                    \ Store the stick height in A on the stack

 JSR CPIX4              \ Draw a double-height mode 5 dot at (X1, Y1). This also
                        \ leaves the following variables set up for the dot's
                        \ top-right pixel, the last pixel to be drawn (as the
                        \ dot gets drawn from the bottom up):
                        \
                        \   SC(1 0) = screen address of the pixel's character
                        \             block
                        \ 
                        \   Y = number of the character row containing the pixel
                        \
                        \   X = the pixel's number (0-3) in that row
                        \
                        \ We can use there as the starting point for drawing the
                        \ stick, if there is one

 LDA CTWOS+1,X          \ Load the same mode 5 1-pixel byte that we just used
 AND COL                \ for the top-right pixel, and mask it with the same
 STA X1                 \ colour, storing the result in X1, so we can use it as
                        \ the character row byte for the stick
 
 PLA                    \ Restore the stick height from the stack into A
 
 PLP                    \ Restore the flags from above, so the C flag once again
                        \ reflects the sign of the stick height
 
 TAX                    \ Copy the stick height into X
 
 BEQ RTS                \ If the stick height is zero, then there is no stick to
                        \ draw, so return from the subroutine (as RTS contains
                        \ an RTS)
 
 BCC RTS+1              \ If the C flag is clear then the stick height in A is
                        \ negative, so jump down to RTS+1

.VLL1                   \ If we get here then the stick length is positive (so
                        \ the dot is below the ellipse and the stick is above
                        \ the dot, and we need to draw the stick upwards from
                        \ the dot)

 DEY                    \ We want to draw the stick upwards, so decrement the
                        \ pixel row in Y

 BPL VL1                \ If Y is still positive then it correctly points at the
                        \ line above, so jump to VL1 to skip the following

 LDY #7                 \ We just decremented Y up through the top of the
                        \ character block, so we need to move it to the last row
                        \ in the character above, so set Y to 7, the number of
                        \ the last row

 DEC SC+1               \ Decrement the high byte of the screen address to move
                        \ to the character block above

.VL1

 LDA X1                 \ Set A to the character row byte for the stick, which
                        \ we stored in X1 above, and which has the same pixel
                        \ pattern as the bottom-right pixel of the dot (so the
                        \ stick comes out of the right side of the dot)

 EOR (SC),Y             \ Draw the stick on row Y of the character block using
 STA (SC),Y

 DEX                    \ Decrement (positive) the stick height in X

 BNE VLL1               \ If we still have more stick to draw, jump up to VLL1
                        \ to draw the next pixel

.RTS

 RTS                    \ Return from the subroutine

\.SCRTS+1               \ If we get here then the stick length is negative (so
                        \ the dot is above the ellipse and the stick is below
                        \ the dot, and we need to draw the stick downwards from
                        \ the dot)

 INY                    \ We want to draw the stick downwards, so we first
                        \ increment the row counter so that it's pointing to the
                        \ bottom-right pixel in the dot (as opposed to the top-
                        \ right pixel that the call to CPIX2 finished on)

 CPY #8                 \ If the row number in Y is less than 8, then it
 BNE P%+6               \ correctly points at the next line down, so jump to
                        \ VLL2 to skip the following

 LDY #0                 \ We just incremented Y down through the bottom of the
                        \ character block, so we need to move it to the first
                        \ row in the character below, so set Y to 0, the number
                        \ of the first row

 INC SC+1               \ Increment the high byte of the screen address to move
                        \ to the character block above

.VLL2

 INY                    \ We want to draw the stick itsef, heading downwards, so
                        \ increment the pixel row in Y

 CPY #8                 \ If the row number in Y is less than 8, then it
 BNE VL2                \ correctly points at the next line down, so jump to
                        \ VL2 to skip the following

 LDY #0                 \ We just incremented Y down through the bottom of the
                        \ character block, so we need to move it to the first
                        \ row in the character below, so set Y to 0, the number
                        \ of the first row

 INC SC+1               \ Increment the high byte of the screen address to move
                        \ to the character block above

.VL2

 LDA X1                 \ Set A to the character row byte for the stick, which
                        \ we stored in X1 above, and which has the same pixel
                        \ pattern as the bottom-right pixel of the dot (so the
                        \ stick comes out of the right side of the dot)

 EOR (SC),Y             \ Draw the stick on row Y of the character block using
 STA (SC),Y

 INX                    \ Decrement the (negative) stick height in X

 BNE VLL2               \ If we still have more stick to draw, jump up to VLL2
                        \ to draw the next pixel

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: WSCAN
\
\ Wait for vertical sync to occur on the video system - in other words, wait
\ for the screen to start its refresh cycle, which it does 50 times a second
\ (50Hz).
\
\ ******************************************************************************

.WSCAN
{
 LDA #0                 \ Set DL to 0
 STA DL

 LDA DL                 \ Loop round these two instructions until DL is no
 BEQ P%-2               \ longer 0 (DL gets set to 30 in the LINSCN routine,
                        \ which is run when vertical sync has occurred on the
                        \ video system, so DL will change to a non-zero value
                        \ at the start of each screen refresh)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Save output/ELTC.bin
\
\ ******************************************************************************

PRINT "ELITE C"
PRINT "Assembled at ", ~CODE_C%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_C%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_C%

PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
SAVE "output/ELTC.bin", CODE_C%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE D
\
\ Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_D% = P%
LOAD_D% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\ Subroutine: tnpr
\
\ Given a market item and an amount, work out whether there is room in the
\ cargo hold for this item.
\
\ For standard tonne canisters, the limit is given by the type of cargo hold we
\ have, with a standard cargo hold having a capacity of 20t and an extended
\ cargo bay being 35t.
\
\ For items measured in kg (gold, platinum), g (gem-stones) and alien items,
\ the individual limit on each of these is 200 units.
\
\ Arguments:
\
\   A                   The number of units of this market item
\
\   QQ29                The type of market item (see QQ23 for a list of market
\                       item numbers)
\
\ Returns:
\
\   A                   A is preserved
\
\   C flag              Returns the result:
\
\                         * Set if there is no room for this item
\
\                         * Clear if there is room for this item
\
\ ******************************************************************************

.tnpr
{
 PHA                    \ Store A on the stack

 LDX #12                \ If QQ29 > 12 then jump to kg below, as this cargo
 CPX QQ29               \ type is gold, platinum, gem-stones or alien items,
 BCC kg                 \ and they have different cargo limits to the standard
                        \ tonne canisters

.Tml                    \ Here we count the tonne canisters we have in the hold
                        \ and add to A to see if we have enough room for A more
                        \ tonnes of cargo, using X as the loop counter, starting
                        \ with X = 12

 ADC QQ20,X             \ Set A = A + the number of tonnes we have in the hold
                        \ of market item number X. Note that the first time we
                        \ go round this loop, the C flag is set (as we didn't
                        \ branch with the BCC above, so the effect of this loop
                        \ is count the number of tonne canisters in the hold, and
                        \ add 1

 DEX                    \ Decrement the loop counter

 BPL Tml                \ Loop back to add in the next market item in the hold,
                        \ until we have added up all market items from 12
                        \ (minerals) down to 0 (food)

 CMP CRGO               \ If A < CRGO then the C flag will be clear (we have
                        \ room in the hold)
                        \
                        \ If A >= CRGO then the C flag will be set (we do not
                        \ have room in the hold)
                        \
                        \ This works because A contains the number of canisters
                        \ plus 1, while CRGO contains our cargo capacity plus 2,
                        \ so if we actually have "a" canisters and a capacity
                        \ of "c", then:
                        \
                        \ A < CRGO means: a+1 <  c+2
                        \                 a   <  c+1
                        \                 a   <= c
                        \
                        \ So this is why the value in CRGO is 2 higher than the
                        \ actual cargo bay size, i.e. it's 22 for the standard
                        \ 20-tonne bay, and 37 for the large 35-tonne bay

 PLA                    \ Restore A from the stack

 RTS                    \ Return from the subroutine

.kg                     \ Here we count the number of items of this type that
                        \ we already have in the hold, and add to A to see if
                        \ we have enough room for A more units

 LDY QQ29               \ Set Y to the item number we want to add

 ADC QQ20,Y             \ Set A = A + the number of units of this item that we
                        \ already have in the hold

 CMP #200               \ Is the result greater than 200 (the limit on
                        \ individual stocks of gold, platinum, gem-stones and
                        \ alien items)?
                        \
                        \ If so, this sets the carry flag (no room)
                        \
                        \ Otherwise it is clear (we have room)

 PLA                    \ Restore A from the stack

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT20
\
\ Twist the three 16-bit seeds in QQ15 (selected system) four times, to
\ generate the next system.
\
\ ******************************************************************************

.TT20
{
 JSR P%+3               \ This line calls the line below as a subroutine, which
                        \ does two twists before returning here, and then we
                        \ fall through to the line below for another two
                        \ twists, so the net effect of these two consecutive
                        \ JSR calls is four twists, not counting the ones
                        \ inside your head as you try to follow this process

 JSR P%+3               \ This line calls TT54 as a subroutine to do a twist,
                        \ and then falls through into TT54 to do another twist
                        \ before returning from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT54
\
\ This routine twists the three 16-bit seeds in QQ15 once.
\
\ ******************************************************************************
\
\ Deep dive: Twisting the system seeds
\ ------------------------------------
\ Famously, the universe in Elite is generated procedurally, and the core of
\ this process is the set of three 16-bit seeds that describe each system in
\ the universe. Each of the eight galaxies in the game is generated in the same
\ way, by taking an initial set of seeds and "twisting" them to generate 256
\ systems, one after the other (the actual twisting process is described
\ below).
\
\ Specifically, given the initial set of seeds, we can generate the next system
\ in the sequence by twisting that system's seeds four times. As we do these
\ twists, we can extract the system's data from the seed values - including the
\ system name, which is generated by the subroutine cpl, where you can read
\ about how this aspect works.
\
\ It is therefore no exaggeration that the twisting process implemented below
\ is the fundamental building block of Elite's "universe in a bottle" approach,
\ which enabled the authors to squeeze eight galaxies of 256 planets out of
\ nothing more then three initial numbers and a short twisting routine (and
\ they could have had far larger galaxies and many more of them, if they had
\ wanted, but they made the wise decision to limit the number). Let's look at
\ how this twisting proces works.
\
\ The three seeds that describe a system represent three consecutive numbers in
\ a Tribonacci sequence, where each number is equal to the sum of the preceding
\ three numbers (the name is a play on Fibonacci sequence, in which each number
\ is equal to the sum of the preceding two numbers). Twisting is the process of
\ moving along the sequence by one place. So, say our seeds currently point to
\ these numbers in the sequence:
\
\   0   0   1   1   2   4   7   13   24   44   ...
\                       ^   ^    ^
\
\ so they are 4, 7 and 13, then twisting would move them all along by one
\ place, like this:
\
\   0   0   1   1   2   4   7   13   24   44   ...
\                           ^    ^    ^
\
\ giving us 7, 13 and 24. To generalise this, if we start with seeds w0, w1
\ and w2 and we want to work out their new values after we perform a twist
\ (let's call the new values x0, x1 and x2), then:
\
\   x0 = w1
\   x1 = w2
\   x2 = w0 + w1 + w2
\
\ So given an existing set of seeds in w0, w1 and w2, we can get the new values
\ x0, x1 and x2 simply by doing the above sums. And if we want to do the above
\ in-place without creating three new x variables, then we can do the
\ following:
\
\   tmp = w0 + w1
\   w0 = w1
\   w1 = w2
\   w2 = tmp + w1
\
\ In Elite, the numbers we're dealing with are two-byte, 16-bit numbers, and
\ because these 16-bit numbers can only hold values up to 65535, the sequence
\ wraps around at the end. But the maths is the same, it just has to be done
\ on 16-bit numbers, one byte at a time.
\
\ The seeds are stored as little-endian 16-bit numbers, so the low (least
\ significant) byte is first, followed by the high (most significant) byte.
\ Taking the case of the currently selected system, whose seeds are stored
\ in the six bytes from QQ15, that means our seed values are stored like this:
\
\       low byte  high byte
\   w0  QQ15      QQ15+1
\   w1  QQ15+2    QQ15+3
\   w2  QQ15+4    QQ15+5
\
\ If we denote the low byte of w0 as w0_lo and the high byte as w0_hi, then
\ the twist operation above can be rewritten for 16-bit values like this,
\ assuming the additions include the carry flag:
\
\   tmp_lo = w0_lo + w1_lo          (tmp = w0 + w1)
\   tmp_hi = w0_hi + w1_hi
\   w0_lo  = w1_lo                  (w0 = w1)
\   w0_hi  = w1_hi
\   w1_lo  = w2_lo                  (w1 = w2)
\   w1_hi  = w2_hi
\   w2_lo  = tmp_lo + w1_lo         (w2 = tmp + w1)
\   w2_hi  = tmp_hi + w1_hi
\
\ And that's exactly what this subroutine does to twist our three 16-bit
\ seeds to the next values in the sequence, using X to store tmp_lo and Y to
\ store tmp_hi.
\
\ ******************************************************************************

.TT54
{
 LDA QQ15               \ X = tmp_lo = w0_lo + w1_lo
 CLC
 ADC QQ15+2
 TAX

 LDA QQ15+1             \ Y = tmp_hi = w1_hi + w1_hi + carry
 ADC QQ15+3
 TAY

 LDA QQ15+2             \ w0_lo = w1_lo
 STA QQ15

 LDA QQ15+3             \ w0_hi = w1_hi
 STA QQ15+1

 LDA QQ15+5             \ w1_hi = w2_hi
 STA QQ15+3

 LDA QQ15+4             \ w1_lo = w2_lo
 STA QQ15+2

 CLC                    \ w2_lo = X + w1_lo
 TXA
 ADC QQ15+2
 STA QQ15+4

 TYA                    \ w2_hi = Y + w1_hi + carry
 ADC QQ15+3
 STA QQ15+5

 RTS                    \ The twist is complete so return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT146
\
\ Print the distance to the selected system in light years, if non-zero. If
\ zero, just move the text cursor down a line.
\
\ Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
\ then a colon, then the distance to one decimal place, then token 35 ("LIGHT
\ YEARS"). If the distance is zero, move the cursor down one line.
\
\ ******************************************************************************

.TT146
{
 LDA QQ8                \ Take the two bytes of the 16-bit value in QQ8 and
 ORA QQ8+1              \ OR them together to check whether there are any
 BNE TT63               \ non-zero bits, and if so, jump to TT63 to print the
                        \ distance

 INC YC                 \ The distance is zero, so we just move the text cursor
 RTS                    \ in YC down by one line and return from the subroutine

.TT63

 LDA #191               \ Print recursive token 31 ("DISTANCE") followed by
 JSR TT68               \ a colon

 LDX QQ8                \ Load (Y X) from QQ8, which contains the 16-bit
 LDY QQ8+1              \ distance we want to show

 SEC                    \ Set the carry flag so that the call to pr5 will
                        \ include a decimal point, and display the value as
                        \ (Y X) / 10

 JSR pr5                \ Print (Y X) to 5 digits, including a decimal point

 LDA #195               \ Set A to the recursive token 35 (" LIGHT YEARS") and
                        \ fall through into TT60 to print the token followed
                        \ by a paragraph break
}

\ ******************************************************************************
\
\ Subroutine: TT60
\
\ Print a text token (i.e. a character, control code, two-letter token or
\ recursive token). Then print a paragraph break (a blank line between
\ paragraphs) by moving the cursor down a line, setting Sentence Case, and then
\ printing a newline.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.TT60
{
 JSR TT27               \ Print the text token in A and fall through into TTX69
                        \ to print the paragraph break
}

\ ******************************************************************************
\
\ Subroutine: TTX69
\
\ Print a paragraph break (a blank line between paragraphs) by moving the cursor
\ down a line, setting Sentence Case, and then printing a newline.
\
\ ******************************************************************************

.TTX69
{
 INC YC                 \ Move the text cursor down a line and then fall
                        \ through into TT69 to set Sentence Case and print a
                        \ newline
}

\ ******************************************************************************
\
\ Subroutine: TT69
\
\ Set Sentence Case and print a newline.
\
\ ******************************************************************************

.TT69
{
 LDA #128               \ Set QQ17 to 128, which denotes Sentence Case, and
 STA QQ17               \ fall througn into TT67 to print a newline
}

\ ******************************************************************************
\
\ Subroutine: TT67
\
\ Print a newline.
\
\ ******************************************************************************

.TT67
{
 LDA #13                \ Load a newline character into A

 JMP TT27               \ Print the text token in A and return from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT70
\
\ Display "MAINLY " and jump to TT72. This subroutine is called by TT25 when
\ displaying a system's economy.
\
\ ******************************************************************************

.TT70
{
 LDA #173               \ Print recursive token 13 ("MAINLY ")
 JSR TT27

 JMP TT72               \ Jump to TT72 to continue printing system data as part
                        \ of routine TT25
}

\ ******************************************************************************
\
\ Subroutine: spc
\
\ Print a text token (i.e. a character, control code, two-letter token or
\ recursive token) followed by a space.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.spc
{
 JSR TT27               \ Print the text token in A

 JMP TT162              \ Print a space and return from the subroutine using a
                        \ tail call
}

\ ******************************************************************************
\
\ Subroutine: TT25
\
\ Show the Data on System screen (red key f6).
\
\ Other entry points:
\
\ TT72                  Used by TT70 to re-enter the routine after displaying
\                       "MAINLY" for the economy type
\
\ ******************************************************************************
\
\ Deep dive: Generating system data (TT25)
\ ----------------------------------------
\ Although most system data is calculated in TT24 below and stored in locations
\ QQ3 to QQ7, the species type and average radius are not. Here's how they are
\ calculated.
\
\ Species type
\ ------------
\ The species type is either Human Colonials, or it's an alien species that
\ consists of up to three adjectives and a species name (so you can get
\ anything from "Rodents" and "Fierce Frogs" to "Black Fat Felines" and "Small
\ Yellow Bony Lobsters").
\
\ As with the rest of the system data, the species is built from various bits
\ in the seeds. Specifically, all the bits in w2_hi are used, along with bits
\ 0-2 of w0_hi and w1_hi, and bit 7 of w2_lo.
\
\ First, we check bit 7 of w2_lo. It it is clear, print "Human Colonials" and
\ stop, otherwise this is an alien species, so we move onto the following
\ steps. (In the following steps, the potential range of the calculated value
\ of A is 0-7, and if a match isn't made, nothing is printed for that step.)
\
\   1. Set A = bits 2-4 of w2_hi
\
\     * If A = 0,  print "Large "
\     * If A = 1,  print "Fierce "
\     * If A = 2,  print "Small "
\
\   2. Set A = bits 5-7 of w2_hi
\
\     * If A = 0,  print "Green "
\     * If A = 1,  print "Red "
\     * If A = 2,  print "Yellow "
\     * If A = 3,  print "Blue "
\     * If A = 4,  print "Black "
\     * If A = 5,  print "Harmless "
\
\   3. Set A = bits 0-2 of (w0_hi EOR w1_hi)
\
\     * If A = 0,  print "Slimy "
\     * If A = 1,  print "Bug-Eyed "
\     * If A = 2,  print "Horned "
\     * If A = 3,  print "Bony "
\     * If A = 4,  print "Fat "
\     * If A = 5,  print "Furry "
\
\   4. Add bits 0-1 of w2_hi to A from step 3, and take bits 0-2 of the result
\
\     * If A = 0,  print "Rodents"
\     * If A = 1,  print "Frogs"
\     * If A = 2,  print "Lizards"
\     * If A = 3,  print "Lobsters"
\     * If A = 4,  print "Birds"
\     * If A = 5,  print "Humanoids"
\     * If A = 6,  print "Felines"
\     * If A = 7,  print "Insects"
\
\ So if we print an adjective at step 3, then the only options for the species
\ name are from A to A + 3 (because we add a 2-bit number) in step 4. So only
\ certain combinations are possible:
\
\   * Only rodents, frogs, lizards and lobsters can be slimy
\   * Only frogs, lizards, lobsters and birds can be bug-eyed
\   * Only lizards, lobsters, birds and humanoids can be horned
\   * Only lobsters, birds, humanoids and felines can be bony
\   * Only birds, humanoids, felines and insects can be fat
\   * Only humanoids, felines, insects and rodents can be furry
\
\ So however hard you look, you will never find slimy humanoids, bony insects,
\ fat rodents or furry frogs, which is probably for the best.
\
\ Average radius
\ --------------
\ The average radius is calculated as follows:
\
\   ((w2_hi AND %1111) + 11) * 256 + w1_hi
\
\ The highest average radius is (15 + 11) * 256 + 255 = 6911 km, and the lowest
\ is 11 * 256 = 2816 km.
\
\ ******************************************************************************

.TT25
{
 JSR TT66-2             \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 1

 LDA #9                 \ Set the text cursor XC to column 9
 STA XC

 LDA #163               \ Print recursive token 3 as a title in capitals at
 JSR TT27               \ the top ("DATA ON {selected system name}")

 JSR NLIN               \ Draw a horizontal line underneath the title

 JSR TTX69              \ Print a paragraph break and set Sentence Case

 INC YC                 \ Move the text cursor down one more line

 JSR TT146              \ If the distance to this system is non-zero, print
                        \ "DISTANCE", then the distance, "LIGHT YEARS" and a
                        \ paragraph break, otherwise just move the cursor down
                        \ a line

 LDA #194               \ Print recursive token 34 ("ECONOMY") followed by
 JSR TT68               \ a colon

 LDA QQ3                \ The system economy is determined by the value in QQ3,
                        \ so fetch it into A. First we work out the system's
                        \ prosperity as follows:
                        \
                        \   QQ3 = 0 or 5 = %000 or %101 = Rich
                        \   QQ3 = 1 or 6 = %001 or %110 = Average
                        \   QQ3 = 2 or 7 = %010 or %111 = Poor
                        \   QQ3 = 3 or 4 = %011 or %100 = Mainly

 CLC                    \ If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
 ADC #1                 \ (3 or 4), then call TT70, which prints "MAINLY " and
 LSR A                  \ jumps down to TT72 to print the type of economy
 CMP #%00000010
 BEQ TT70

 LDA QQ3                \ The LSR A above shifted bit 0 of QQ3 into the carry
 BCC TT71               \ flag, so this jumps to TT71 if bit 0 of QQ3 is 0,
                        \ i.e. if QQ3 = %000, %001 or %010 (0, 1 or 2)

 SBC #5                 \ Here QQ3 = %101, %110 or %111 (5, 6 or 7), so
 CLC                    \ subtract 5 to bring it down to 0, 1 or 2 (the carry
                        \ flag is already set so the SBC will be correct)

.TT71

 ADC #170               \ A is now 0, 1 or 2, so print recursive token 10 + A.
 JSR TT27               \ This means that:
                        \
                        \   QQ3 = 0 or 5 prints token 10 ("RICH ")
                        \   QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
                        \   QQ3 = 2 or 7 prints token 12 ("POOR ")

.^TT72

 LDA QQ3                \ Now to work out the type of economy, which is
 LSR A                  \ determined by bit 2 of QQ3, as follows:
 LSR A                  \
                        \   QQ3 bit 2 = 0 = Industrial
                        \   QQ3 bit 2 = 1 = Agricultural
                        \
                        \ So we fetch QQ3 into A and set A = bit 2 of QQ3 using
                        \ two right shifts (which will work as QQ3 is only a
                        \ 3-bit number)

 CLC                    \ Print recursive token 8 + A, followed by a paragraph
 ADC #168               \ break and Sentence Case, so:
 JSR TT60               \
                        \   QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
                        \   QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")

 LDA #162               \ Print recursive token 2 ("GOVERNMENT") followed by
 JSR TT68               \ a colon

 LDA QQ4                \ The system economy is determined by the value in QQ4,
                        \ so fetch it into A

 CLC                    \ Print recursive token 17 + A, followed by a paragraph
 ADC #177               \ break and Sentence Case, so:
 JSR TT60               \
                        \   QQ4 = 0 prints token 17 ("ANARCHY")
                        \   QQ4 = 1 prints token 18 ("FEUDAL")
                        \   QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
                        \   QQ4 = 3 prints token 20 ("DICTATORSHIP")
                        \   QQ4 = 4 prints token 21 ("COMMUNIST")
                        \   QQ4 = 5 prints token 22 ("CONFEDERACY")
                        \   QQ4 = 6 prints token 23 ("DEMOCRACY")
                        \   QQ4 = 7 prints token 24 ("CORPORATE STATE")

 LDA #196               \ Print recursive token 36 ("TECH.LEVEL") followed by a
 JSR TT68               \ colon

 LDX QQ5                \ Fetch the tech level from QQ5 and increment it, as it
 INX                    \ is stored in the range 0-14 but the displayed range
                        \ should be 1-15

 CLC                    \ Call pr2 to print the technology level as a 3-digit
 JSR pr2                \ number without a decimal point (by clearing the carry
                        \ flag)

 JSR TTX69              \ Print a paragraph break and set Sentence Case

 LDA #192               \ Print recursive token 32 ("POPULATION") followed by a
 JSR TT68               \ colon

 SEC                    \ Call pr2 to print the population as a 3-digit number
 LDX QQ6                \ with a decimal point (by setting the carry flag), so
 JSR pr2                \ the number printed will be population / 10

 LDA #198               \ Print recursive token 38 (" BILLION"), followed by a
 JSR TT60               \ paragraph break and Sentence Case

 LDA #'('               \ Print an opening bracket
 JSR TT27

 LDA QQ15+4             \ Now to calculate the species, so first check bit 7 of
 BMI TT75               \ w2_lo, and if it is set, jump to TT75 as this is an
                        \ alien species

 LDA #188               \ Bit 7 of w2_lo is clear, so print recursive token 28
 JSR TT27               \ ("HUMAN COLONIAL")

 JMP TT76               \ Jump to TT76 to print "S)" and a paragraph break, so
                        \ the whole species string is "(HUMAN COLONIALS)"

.TT75

 LDA QQ15+5             \ This is an alien species, and we start with the first
 LSR A                  \ adjective, so fetch bits 2-7 of w2_hi into A and push
 LSR A                  \ onto the stack so we can use this later
 PHA

 AND #7                 \ Set A = bits 0-2 of A (so that's bits 2-4 of w2_hi)

 CMP #3                 \ If A >= 3, jump to TT205 to skip the first adjective,
 BCS TT205

 ADC #227               \ Otherwise A = 0, 1 or 2, so print recursive token
 JSR spc                \ 67 + A, followed by a space, so:
                        \
                        \   A = 0 prints token 67 ("LARGE") and a space
                        \   A = 1 prints token 67 ("FIERCE") and a space
                        \   A = 2 prints token 67 ("SMALL") and a space

.TT205

 PLA                    \ Now for the second adjective, so restore A to bits
 LSR A                  \ 2-7 of w2_hi, and throw away bits 2-4 to leave
 LSR A                  \ A = bits 5-7 of w2_hi
 LSR A

 CMP #6                 \ If A >= 6, jump to TT206 to skip the second adjective
 BCS TT206

 ADC #230               \ Otherwise A = 0 to 5, so print recursive token
 JSR spc                \ 70 + A, followed by a space, so:
                        \
                        \   A = 0 prints token 70 ("GREEN") and a space
                        \   A = 1 prints token 71 ("RED") and a space
                        \   A = 2 prints token 72 ("YELLOW") and a space
                        \   A = 3 prints token 73 ("BLUE") and a space
                        \   A = 4 prints token 74 ("BLACK") and a space
                        \   A = 5 prints token 75 ("HARMLESS") and a space

.TT206

 LDA QQ15+3             \ Now for the third adjective, so EOR the high bytes of
 EOR QQ15+1             \ w0 and w1 and extract bits 0-2 of the result:
 AND #%00000111         \
 STA QQ19               \   A = (w0_hi EOR w1_hi) AND %111
                        \
                        \ storing the result in QQ19 so we can use it later

 CMP #6                 \ If A >= 6, jump to TT207 to skip the third adjective
 BCS TT207

 ADC #236               \ Otherwise A = 0 to 5, so print recursive token
 JSR spc                \ 76 + A, followed by a space, so:
                        \
                        \   A = 0 prints token 76 ("SLIMY") and a space
                        \   A = 1 prints token 77 ("BUG-EYED") and a space
                        \   A = 2 prints token 78 ("HORNED") and a space
                        \   A = 3 prints token 79 ("BONY") and a space
                        \   A = 4 prints token 80 ("FAT") and a space
                        \   A = 5 prints token 81 ("FURRY") and a space

.TT207

 LDA QQ15+5             \ Now for the actual species, so take bits 0-1 of
 AND #3                 \ w2_hi, add this to the value of A that we used for
 CLC                    \ the third adjective, and take bits 0-2 of the result
 ADC QQ19
 AND #7

 ADC #242               \ A = 0 to 7, so print recursive token 82 + A, so:
 JSR TT27               \
                        \   A = 0 prints token 76 ("RODENT")
                        \   A = 1 prints token 76 ("FROG")
                        \   A = 2 prints token 76 ("LIZARD")
                        \   A = 3 prints token 76 ("LOBSTER")
                        \   A = 4 prints token 76 ("BIRD")
                        \   A = 5 prints token 76 ("HUMANOID")
                        \   A = 6 prints token 76 ("FELINE")
                        \   A = 7 prints token 76 ("INSECT")

.TT76

 LDA #'S'               \ Print an "S" to pluralise the species
 JSR TT27

 LDA #')'               \ And finally, print a closing bracket, followed by a
 JSR TT60               \ paragraph break and Sentence Case, to end the species
                        \ section

 LDA #193               \ Print recursive token 33 ("GROSS PRODUCTIVITY"),
 JSR TT68               \ followed by colon

 LDX QQ7                \ Fetch the 16-bit productivity value from QQ7 into
 LDY QQ7+1              \ (Y X)

 JSR pr6                \ Print (Y X) to 5 digits with no decimal point

 JSR TT162              \ Print a space

 LDA #0                 \ Set QQ17 = 0 for ALL CAPS
 STA QQ17

 LDA #'M'               \ Print "M"
 JSR TT27

 LDA #226               \ Print recursive token 66 (" CR"), followed by a
 JSR TT60               \ paragraph break and Sentence Case

 LDA #250               \ Print recursive token 90 ("AVERAGE RADIUS"), followed
 JSR TT68               \ by a colon

                        \ The average radius is calculated like this:
                        \
                        \   ((w2_hi AND %1111) + 11) * 256 + w1_hi
                        \
                        \ or, in terms of memory locations:
                        \
                        \   ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
                        \
                        \ Because the multiplication is by 256, this is the
                        \ same as saying a 16-bit number, with high byte:
                        \
                        \   (QQ15+5 AND %1111) + 11
                        \
                        \ and low byte:
                        \
                        \   QQ15+3
                        \
                        \ so we can set this up in (Y X) and call the pr5
                        \ routine to print it out

 LDA QQ15+5             \ Set A = QQ15+5
 LDX QQ15+3             \ Set X = QQ15+3

 AND #%00001111         \ Set Y = (A AND %1111) + 11
 CLC
 ADC #11
 TAY

 JSR pr5                \ Print (Y X) to 5 digits, not including a decimal
                        \ point, as the carry flag will be clear (as the
                        \ maximum radius will always fit into 16 bits)

 JSR TT162              \ Print a space

 LDA #'k'               \ Print "km", returning from the subroutine using a
 JSR TT26               \ tail call
 LDA #'m'
 JMP TT26
}

\ ******************************************************************************
\
\ Subroutine: TT24
\
\ Calculate system data from the seeds in QQ15 and store them in the relevant
\ locations. Specifically, this routine calculates the following from the three
\ 16-bit seeds in QQ15 (using only w0_hi, w1_hi and w1_lo):
\
\   QQ3 = economy (0-7)
\   QQ4 = government (0-7)
\   QQ5 = technology level (0-14)
\   QQ6 = population * 10 (1-71)
\   QQ7 = productivity (96-62480)
\
\ The ranges of the various values are shown in brackets. Note that the radius
\ and type of inhabitant are calculated on-the-fly in the TT25 routine when
\ the system data gets displayed, so they aren't calculated here.
\
\ ******************************************************************************
\
\ Deep dive: Generating system data (TT24)
\ ----------------------------------------
\ The above system statistics are generated from the system seeds, specifically
\ from parts of w0_hi, w1_hi and w1_lo. Here's how it all works.
\
\ Government
\ ----------
\ The government is given by a 3-bit value, taken from bits 3-5 of w1_lo. This
\ value determine the type of government as follows:
\
\   0 = Anarchy
\   1 = Feudal
\   2 = Multi-government
\   3 = Dictatorship
\   4 = Communist
\   5 = Confederacy
\   6 = Democracy
\   7 = Corporate State
\
\ The highest government value is 7 and the lowest is 0.
\
\ Economy
\ -------
\ The economy is given by a 3-bit value, taken from bits 0-2 of w0_hi. This
\ value determine the prosperity of the economy:
\
\   0 or 5 = %000 or %101 = Rich
\   1 or 6 = %001 or %110 = Average
\   2 or 7 = %010 or %111 = Poor
\   3 or 4 = %011 or %100 = Mainly
\
\ while bit 2 determines the type of economy:
\
\   bit 2 = %0 = Industrial
\   bit 2 = %1 = Agricultural
\
\ Putting these two together, we get:
\
\   0 = Rich Industrial
\   1 = Average Industrial
\   2 = Poor Industrial
\   3 = Mainly Industrial
\   4 = Mainly Agricultural
\   5 = Rich Agricultural
\   6 = Average Agricultural
\   7 = Poor Agricultural
\
\ If the government is an anarchy or feudal state, we need to fix the economy
\ so it can't be rich (as that wouldn't make sense). We do this by setting bit
\ 1 of the economy value, giving possible values of %010, %011, %110, %111.
\ Looking at the prosperity list above, we can see this forces the economy to
\ be poor, mainly, average, or poor respectively, so there's now a 50% chance
\ of the system being poor, a 25% chance of it being average, and a 25% chance
\ of it being "Mainly Agricultural" or "Mainly Industrial".
\
\ The highest economy value is 7 and the lowest is 0.
\
\ Technology level
\ ----------------
\ The tech level is calculated as follows:
\
\   flipped economy + (w1_hi AND %11) + (government / 2)
\
\ where "flipped economy" is the economy value with its bits inverted (keeping
\ it as a 3-bit value, so if the economy is %001, the flipped economy is %110).
\ The division is done using LSR and the addition uses ADC, so this rounds up
\ the division for odd-numbered government types.
\
\ Flipping the three economy bits gives the following spread of numbers:
\
\   7 or 2 = %111 or %010 = Rich
\   6 or 1 = %110 or %001 = Average
\   5 or 0 = %101 or %000 = Poor
\   4 or 3 = %100 or %011 = Mainly
\
\ This, on average, gives a higher number to rich states compared with poor
\ states, as well as giving higher values to industrial economies compared to
\ agricultural, all of which makes a reasonable basis for a measurement of
\ technology level.
\
\ The highest tech level is 7 + 3 + (7 / 2) = 14 (when rounded up) and the
\ lowest is 0.
\
\ Population
\ ----------
\ The population is calculated as follows:
\
\   (tech level * 4) + economy + government + 1
\
\ This means that systems with higher tech levels, better economies and more
\ stable governments have higher populations, with the tech level having the
\ most influence. The number stored is actually the population * 10 (in
\ billions), so we can display it to one decimal place by calling the pr2
\ subroutine (so if the population value is 52, it means 5.2 billion).
\
\ The highest population is 14 * 4 + 7 + 7 + 1 = 71 (7.1 billion) and the
\ lowest is 1 (0.1 billion).
\
\ Productivity
\ ------------
\ The productivity is calculated as follows:
\
\   (flipped economy + 3) * (government + 4) * population * 8
\
\ Productivity is measured in millions of credits, so a productivity of 23740
\ would be displayed as "23740 M CR".
\
\ The highest productivity is 10 * 11 * 71 * 8 = 62480, while the lowest is 3 *
\ 4 * 1 * 8 = 96 (so the range is between 96 and 62480 million credits).
\
\ ******************************************************************************

.TT24
{
 LDA QQ15+1             \ Fetch w0_hi and extract bits 0-2 to determine the
 AND #%00000111         \ system's economy, and store in QQ3
 STA QQ3

 LDA QQ15+2             \ Fetch w1_lo and extract bits 3-5 to determine the
 LSR A                  \ system's government, and store in QQ4
 LSR A
 LSR A
 AND #%00000111
 STA QQ4

 LSR A                  \ If government isn't anarchy or feudal, skip to TT77,
 BNE TT77               \ as we need to fix the economy of anarchy and feudal
                        \ systems so they can't be rich

 LDA QQ3                \ Set bit 1 of the economy in QQ3 to fix the economy
 ORA #%00000010         \ for anarchy and feudal governments
 STA QQ3

.TT77

 LDA QQ3                \ Now to work out the tech level, which we do like this:
 EOR #%00000111         \
 CLC                    \   flipped economy + (w1_hi AND %11) + (government / 2)
 STA QQ5                \
                        \ or, in terms of memory locations:
                        \
                        \   QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
                        \
                        \ We start by setting QQ5 = QQ3 EOR %111

 LDA QQ15+3             \ We then take the first 2 bits of w1_hi (QQ15+3) and
 AND #%00000011         \ add it into QQ5
 ADC QQ5
 STA QQ5

 LDA QQ4                \ And finally we add QQ4 / 2 and store the result in
 LSR A                  \ QQ5, using LSR then ADC to divide by 2, which rounds
 ADC QQ5                \ up the result for odd-numbered government types
 STA QQ5

 ASL A                  \ Now to work out the population, like so:
 ASL A                  \
 ADC QQ3                \   (tech level * 4) + economy + government + 1
 ADC QQ4                \
 ADC #1                 \ or, in terms of memory locations:
 STA QQ6                \
                        \   QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1

 LDA QQ3                \ Finally, we work out productivity, like this:
 EOR #%00000111         \
 ADC #3                 \  (flipped economy + 3) * (government + 4)
 STA P                  \                        * population
 LDA QQ4                \                        * 8
 ADC #4                 \
 STA Q                  \ or, in terms of memory locations:
 JSR MULTU              \
                        \   QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
                        \
                        \ We do the first step by setting P to the first
                        \ expression in brackets and Q to the second, and
                        \ calling MULTU, so now (A P) = P * Q. The highest this
                        \ can be is 10 * 11 (as the maximum values of economy
                        \ and government are 7), so the high byte of the result
                        \ will always be 0, so we actually have:
                        \
                        \   P = P * Q
                        \     = (flipped economy + 3) * (government + 4)

 LDA QQ6                \ We now take the result in P and multiply by the
 STA Q                  \ population to get the productivity, by setting Q to
 JSR MULTU              \ the population from QQ6 and calling MULTU again, so
                        \ now we have:
                        \
                        \   (A P) = P * population

 ASL P                  \ Next we multiply the result by 8, as a 16-bit number,
 ROL A                  \ so we shift both bytes to the left three times,
 ASL P                  \ using the carry flag to carry bits from bit 7 of the
 ROL A                  \ low byte into bit 0 of the high byte
 ASL P
 ROL A

 STA QQ7+1              \ Finally, we store the productivity in two bytes, with
 LDA P                  \ the low byte in QQ7 and the high byte in QQ7+1
 STA QQ7

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT22
\
\ Show the Long-range Chart (red key f4).
\
\ ******************************************************************************

.TT22
{
 LDA #64                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32 (Long-
                        \ range Chart)

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #199               \ Print recursive token 39 ("GALACTIC CHART{galaxy
 JSR TT27               \ number right-aligned to width 3}")

 JSR NLIN               \ Draw a horizontal line at pixel row 23 to box in the
                        \ title and act as the top frame of the chart, and move
                        \ the text cursor down one line

 LDA #152               \ Draw a screen-wide horizontal line at pixel row 152
 JSR NLIN2              \ for the bottom edge of the chart, so the chart itself
                        \ is 128 pixels high, starting on row 24 and ending on
                        \ row 151

 JSR TT14               \ Call TT14 to draw a circle with crosshairs at the
                        \ current system's galactic coordinates

 LDX #0                 \ We're now going to plot each of the galaxy's systems,
                        \ so set up a counter in X for each system, starting at
                        \ 0 and looping through to 255

.TT83

 STX XSAV               \ Store the counter in XSAV

 LDX QQ15+3             \ Fetch the w1_hi seed into X, which gives us the
                        \ galactic x-coordinate of this system

 LDY QQ15+4             \ Fetch the w2_lo seed and clear all the bits apart
 TYA                    \ from bits 4 and 6, storing the result in ZZ to give a
 ORA #%01010000         \ random number out of 0, &10, &40 or &50 (but which
 STA ZZ                 \ will always be the same for this system). We use this
                        \ value to determine the size of the point for this
                        \ system on the chart by passing it as the distance
                        \ argument to the PIXEL routine below

 LDA QQ15+1             \ Fetch the w0_hi seed into A, which gives us the
                        \ galactic y-coordinate of this system

 LSR A                  \ We halve the y-coordinate because the galaxy in
                        \ in Elite is rectangular rather than square, and is
                        \ twice as wide (x-axis) as it is high (y-axis), so the
                        \ chart is 256 pixels wide and 128 high

 CLC                    \ Add 24 to the halved y-coordinate and store in XX15+1
 ADC #24                \ (as the top of the chart is on pixel row 24, just
 STA XX15+1             \ below the line we drew on row 23 above)

 JSR PIXEL              \ Call PIXEL to draw a point at (X, A), with the size of
                        \ the point dependent on the distance specified in ZZ
                        \ (so a high value of ZZ will produce a 1-pixel point,
                        \ a medium value will produce a 2-pixel dash, and a
                        \ small value will produce a 4-pixel square)

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 LDX XSAV               \ Restore the loop counter from XSAV

 INX                    \ Increment the counter

 BNE TT83               \ If X > 0 then we haven't done all 256 systems yet, so
                        \ loop back up to TT83

 LDA QQ9                \ Set QQ19 to the selected system's x-coordinate
 STA QQ19

 LDA QQ10               \ Set QQ19+1 to the selected system's y-coordinate,
 LSR A                  \ halved to fit it into the chart
 STA QQ19+1

 LDA #4                 \ Set QQ19+2 to size 4 for the crosshairs size
 STA QQ19+2

                        \ Fall through into TT15 to draw crosshairs of size 4 at
                        \ the selected system's coordinates
}

\ ******************************************************************************
\
\ Subroutine: TT15
\
\ Draw a set of crosshairs. For all views except the Short-range Chart, the
\ centre is drawn 24 pixels to the right of the y-coordinate given.
\
\ Arguments:
\
\   QQ19                The pixel x-coordinate of the centre of the crosshairs
\
\   QQ19+1              The pixel y-coordinate of the centre of the crosshairs
\
\   QQ19+2              The size of the crosshairs
\
\ ******************************************************************************

.TT15
{
 LDA #24                \ Set A to 24, which we will use as the minimum
                        \ screen indent for the crosshairs (i.e. the minimum
                        \ distance from the top-left corner of the screen)

 LDX QQ11               \ If the current view is not the Short-range Chart,
 BPL P%+4               \ which is the only view with bit 7 set, then skip the
                        \ following instruction

 LDA #0                 \ This is the Short-range Chart, so set A to 0, so the
                        \ crosshairs can go right up against the screen edges

 STA QQ19+5             \ Set QQ19+5 to A, which now contains the correct indent
                        \ for this view

 LDA QQ19               \ Set A = crosshairs x-coordinate - crosshairs size
 SEC                    \ to get the x-coordinate of the left edge of the
 SBC QQ19+2             \ crosshairs

 BCS TT84               \ If the above subtraction didn't underflow, then A is
                        \ positive, so skip the next instruction

 LDA #0                 \ The subtraction underflowed, so set A to 0 so the
                        \ crosshairs don't spill out of the left of the screen

.TT84

                        \ In the following, the authors have used XX15 for
                        \ temporary storage. XX15 shares location with X1, Y1,
                        \ X2 and Y2, so in the following, you can consider
                        \ the varibles like this:
                        \
                        \   XX15   is the same as X1
                        \   XX15+1 is the same as Y1
                        \   XX15+2 is the same as X2
                        \   XX15+3 is the same as Y2
                        \
                        \ Presumably this routine was written at a different
                        \ time to the line drawing routine, before the two
                        \ workspaces were merged to save space

 STA XX15               \ Set XX15 (X1) = A (the x-coordinate of the left edge
                        \ of the crosshairs)

 LDA QQ19               \ Set A = crosshairs x-coordinate + crosshairs size
 CLC                    \ to get the x-coordinate of the right edge of the
 ADC QQ19+2             \ crosshairs

 BCC P%+4               \ If the above addition didn't overflow, then A is
                        \ correct, so skip the next instruction

 LDA #255               \ The addition overflowed, so set A to 255 so the
                        \ crosshairs don't spill out of the right of the screen
                        \ (as 255 is the x-coordinate of the rightmost pixel
                        \ on screen)

 STA XX15+2             \ Set XX15+2 (X2) = A (the x-coordinate of the right
                        \ edge of the crosshairs)

 LDA QQ19+1             \ Set XX15+1 (Y1) = crosshairs y-coordinate + indent
 CLC                    \ to get the y-coordinate of the centre of the
 ADC QQ19+5             \ crosshairs
 STA XX15+1

 JSR HLOIN              \ Draw a horizontal line from (X1, Y1) to (X2, Y1),
                        \ which will draw from the left edge of the crosshairs
                        \ to the right edge, through the centre of the
                        \ crosshairs

 LDA QQ19+1             \ Set A = crosshairs y-coordinate - crosshairs size
 SEC                    \ to get the y-coordinate of the top edge of the
 SBC QQ19+2             \ crosshairs

 BCS TT86               \ If the above subtraction didn't underflow, then A is
                        \ correct, so skip the next instruction

 LDA #0                 \ The subtraction underflowed, so set A to 0 so the
                        \ crosshairs don't spill out of the top of the screen

.TT86

 CLC                    \ Set XX15+1 (Y1) = A + indent to get the y-coordinate
 ADC QQ19+5             \ of the top edge of the indented crosshairs
 STA XX15+1

 LDA QQ19+1             \ Set A = crosshairs y-coordinate + crosshairs size
 CLC                    \ + indent to get the y-coordinate of the bottom edge
 ADC QQ19+2             \ of the indented crosshairs
 ADC QQ19+5

 CMP #152               \ If A < 152 then skip the following, as the crosshairs
 BCC TT87               \ won't spill out of the bottom of the screen

 LDX QQ11               \ A >= 152, so we need to check whether this will fit in
                        \ this view, so fetch the view number

 BMI TT87               \ If this is the Short-range Chart then the y-coordinate
                        \ is fine, so skip to TT87

 LDA #151               \ Otherwise this is the Long-range Chart, so we need to
                        \ clip the crosshairs at a maximum y-coordinate of 151

.TT87

 STA XX15+3             \ Set XX15+3 (Y2) = A (the y-coordinate of the bottom
                        \ edge of the crosshairs)

 LDA QQ19               \ Set XX15 (X1) = the x-coordinate of the centre of the
 STA XX15               \ crosshairs

 STA XX15+2             \ Set XX15+2 (X2) = the x-coordinate of the centre of
                        \ the crosshairs

 JMP LL30               \ Draw a vertical line (X1, Y1) to (X2, Y2), which will
                        \ draw from the top edge of the crosshairs to the bottom
                        \ edge, through the centre of the crosshairs, returning
                        \ from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT14
\
\ Draw a circle with crosshairs at the current system's galactic coordinates.
\
\ ******************************************************************************

{
.TT126

 LDA #104               \ Set QQ19 = 104, for the x-coordinate of the centre of
 STA QQ19               \ the fixed circle on the Short-range Chart

 LDA #90                \ Set QQ19+1 = 90, for the y-coordinate of the centre of
 STA QQ19+1             \ the fixed circle on the Short-range Chart

 LDA #16                \ Set QQ19+2 = 16, the size of the crosshairs on the
 STA QQ19+2             \ Short-range Chart

 JSR TT15               \ Draw the set of crosshairs defined in QQ19, at the
                        \ exact coordinates as this is the Short-range Chart

 LDA QQ14               \ Set K to the fuel level from QQ14, so this can act as
 STA K                  \ the circle's radius (70 being a full tank)

 JMP TT128              \ Jump to TT128 to draw a circle with the centre at the
                        \ same coordinates as the crosshairs, (QQ19, QQ19+1),
                        \ and radius K that reflects the current fuel levels,
                        \ returning from the subroutine using a tail call

.^TT14

 LDA QQ11               \ If the current view is the Short-range Chart, which
 BMI TT126              \ is the only view with bit 7 set, then jump up to TT126
                        \ to draw the crosshairs and circle for that view
                        
                        \ Otherwise this is the Long-range Chart, so we draw the
                        \ crosshairs and circle for that view instead

 LDA QQ14               \ Set K to the fuel level from QQ14 divided by 4, so
 LSR A                  \ this can act as the circle's radius (70 being a full
 LSR A                  \ tank, which divides down to a radius of 17)
 STA K

 LDA QQ0                \ Set QQ19 to the x-coordinate of the current system,
 STA QQ19               \ which will be the centre of the circle and crosshairs
                        \ we draw

 LDA QQ1                \ Set QQ19+1 to the y-coordinate of the current system,
 LSR A                  \ halved because the galactic chart is half as high as
 STA QQ19+1             \ it is wide, which will again be the centre of the
                        \ circle and crosshairs we draw

 LDA #7                 \ Set QQ19+2 = 7, the size of the crosshairs on the
 STA QQ19+2             \ Long-range Chart

 JSR TT15               \ Draw the set of crosshairs defined in QQ19, which will
                        \ be drawn 24 pixels to the right of QQ19+1

 LDA QQ19+1             \ Add 24 to the y-coordinate of the crosshairs in QQ19+1
 CLC                    \ so that the centre of the circle matches the centre
 ADC #24                \ of the crosshairs
 STA QQ19+1

                        \ Fall through into TT128 to draw a circle with the
                        \ centre at the same coordinates as the crosshairs,
                        \ (QQ19, QQ19+1),  and radius K that reflects the
                        \ current fuel levels
}

\ ******************************************************************************
\
\ Subroutine: TT128
\
\ Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
\
\ Arguments:
\
\   QQ19                The x-coordinate of the centre of the circle
\
\   QQ19+1              The y-coordinate of the centre of the circle
\
\   K                   The radius of the circle
\
\ ******************************************************************************

.TT128
{
 LDA QQ19               \ Set K3 = the x-coordinate of the centre
 STA K3

 LDA QQ19+1             \ Set K4 = the x-coordinate of the centre
 STA K4

 LDX #0                 \ Set the high bytes of K3(1 0) and K4(1 0) to 0
 STX K4+1
 STX K3+1

\STX LSX                \ This instruction is commented out in the original
                        \ source

 INX                    \ Set LSP = 1, the arc step for the circle
 STX LSP

 LDX #2                 \ Set STP = 2, the step size for the circle
 STX STP

 JSR CIRCLE2            \ Call CIRCLE2 to draw a circle with the centre at
                        \ (K3(1 0), K4(1 0)) and radius K

\LDA #&FF               \ These instructions are commented out in the original
\STA LSX                \ source

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT219
\
\ Show the Buy Cargo screen (red key f1).
\
\ Other entry points:
\
\   BAY2                Jump into the main loop at FRCE, setting the key
\                       "pressed" to red key f9 (so we show the Inventory
\                       screen)
\
\ ******************************************************************************

.TT219
{
\LDA#2                  \ This instruction is commented out in the original
                        \ source. Perhaps this view originally had a QQ11 value
                        \ of 2, but it turned out not to need its own unique ID,
                        \ so the authors found they could just use a view value
                        \ of 1 and save an instruction at the same time?

 JSR TT66-2             \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 1

 JSR TT163              \ Print the column headers for the prices table

 LDA #128               \ Set QQ17 = 128 to switch to Sentence Case, with the
 STA QQ17               \ next letter in capitals

\JSR FLKB               \ This instruction is commented out in the original
                        \ source. It calls a routine to flush the keyboard
                        \ buffer (FLKB) that isn't present in the tape version
                        \ but is in the disc version

 LDA #0                 \ We're going to loop through all the available market
 STA QQ29               \ items, so we set up a counter in QQ29 to denote the
                        \ current item and start it at 0

.TT220

 JSR TT151              \ Call TT151 to print the item name, market price and
                        \ availability of the current item, and set QQ24 to the
                        \ item's price / 4, QQ25 to the quantity available and
                        \ QQ19+1 to byte #1 from the market prices table for
                        \ this item

 LDA QQ25               \ If there are some of the current item available, jump
 BNE TT224              \ to TT224 below to see if we want to buy any

 JMP TT222              \ Otherwise there are none available, so jump down to
                        \ TT222 to skip this item

.TQ4

 LDY #176               \ Set Y to the recursive token 16 ("QUANTITY")

.Tc

 JSR TT162              \ Print a space

 TYA                    \ Print the recursive token in Y followed by a question
 JSR prq                \ mark

.TTX224

 JSR dn2                \ Call dn2 to make a short, high beep and delay for 1
                        \ second

.TT224

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #204               \ Print recursive token 44 ("QUANTITY OF ")
 JSR TT27

 LDA QQ29               \ Print recursive token 48 + QQ29, which will be in the
 CLC                    \ range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               \ prints the current item's name
 JSR TT27

 LDA #'/'               \ Print "/"
 JSR TT27

 JSR TT152              \ Print the unit ("t", "kg" or "g") for the current item
                        \ (as the call to TT151 above set QQ19+1 with the
                        \ appropriate value)

 LDA #'?'               \ Print "?"
 JSR TT27

 JSR TT67               \ Print a newline

 LDX #0                 \ These instructions have no effect, as they are
 STX R                  \ repeated at the start of gnum, which we call next.
 LDX #12                \ Perhaps they were left behind when code was moved from
 STX T1                 \ here into gnum, and weren't deleted?

\.TT223                 \ This label is commented out in the original source,
                        \ and is a duplicate of a label in gnum, so this could
                        \ also be a remnant if the code in gnum was originally
                        \ here, but got moved into the gnum subroutine

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the quantity of this item we want to purchase,
                        \ returning the number entered in A and R

 BCS TQ4                \ If gnum set the C flag, the number entered is greater
                        \ then the quantity available, so jump up to TQ4 to
                        \ display a "Quantity?" error, beep, clear the number
                        \ and try again

 STA P                  \ Otherwise we have a valid purchase quantity entered,
                        \ so store the amount we want to purchase in P

 JSR tnpr               \ Call tnpr to work out whether there is room in the
                        \ cargo hold for this item

 LDY #206               \ If the C flag is set, then there is no room in the
 BCS Tc                 \ cargo hold, so set Y to the recursive token 46
                        \ (" CARGO{switch to sentence case}") and jump up to
                        \ Tc to print a "Cargo?" error, beep, clear the number
                        \ and try again

 LDA QQ24               \ There is room in the cargo hold, so now to check
 STA Q                  \ whether we have enough cash, so fetch the item's
                        \ price / 4, which was returned in QQ24 by the call
                        \ to TT151 above and store it in Q

 JSR GCASH              \ Call GCASH to calculate
                        \
                        \   (Y X) = P * Q * 4
                        \
                        \ which will be the total price of this transaction
                        \ (as P contains the purchase quantity and Q contains
                        \ the item's price / 4)

 JSR LCASH              \ Subtract (Y X) cash from the cash pot in CASH

 LDY #197               \ If the C flag is clear, we didn't have enough cash,
 BCC Tc                 \ so set Y to the recursive token 37 ("CASH") and jump
                        \ up to Tc to print a "Cash?" error, beep, clear the
                        \ number and try again

 LDY QQ29               \ Fetch the current market item number from QQ29 into Y

 LDA R                  \ Set A to the number of items we just purchased (this
                        \ was set by gnum above)

 PHA                    \ Store the quantity just purchased on the stack

 CLC                    \ Add the number purchased to the Y-th byte of QQ20,
 ADC QQ20,Y             \ which contains the number of items of this type in
 STA QQ20,Y             \ our hold (so this transfers the bought items into our
                        \ cargo hold)

 LDA AVL,Y              \ Subtract the number of items from the Y-th byte of
 SEC                    \ AVL,which contains the number of items of this type
 SBC R                  \ that are available on the market
 STA AVL,Y

 PLA                    \ Restore the quantity just purchased

 BEQ TT222              \ If we didn't buy anything, jump to TT222 to skip the
                        \ following instruction

 JSR dn                 \ Call dn to print the amount of cash left in the cash
                        \ pot, then make a short, high beep to confirm the
                        \ purchase, and delay for 1 second

.TT222

 LDA QQ29               \ Move the text cursor to row QQ29 + 5 (where QQ29 is
 CLC                    \ the item numberm starting from 0)
 ADC #5
 STA YC

 LDA #0                 \ Move the text cursor to column 0
 STA XC

 INC QQ29               \ Increment QQ29 to point to the next item

 LDA QQ29               \ If QQ29 >= 17 then jump to BAY2 as we have done the
 CMP #17                \ last item
 BCS BAY2

 JMP TT220              \ Otherwise loop back to TT220 to print the next market
                        \ item

.^BAY2

 LDA #f9                \ Jump into the main loop at FRCE, setting the key
 JMP FRCE               \ "pressed" to red key f9 (so we show the Inventory
                        \ screen)
}

\ ******************************************************************************
\
\ Subroutine: gnum
\
\ Get a number from the keyboard, up to the maximum number in QQ25. Pressing a
\ key with an ASCII code less than ASCII "0" will return a 0 in A (so that
\ includes pressing Space or Return), while pressing a ley with an ASCII code
\ greater than ASCII "9" will jump to the Inventory screen (so that includes
\ all letters and most punctuation).
\
\ Arguments:
\
\   QQ25                The maximum number allowed
\
\ Returns:
\
\   A                   The number entered
\
\   R                   Also contains the number entered
\
\   C flag              Set if the number is too large (> QQ25), clear otherwise
\
\ ******************************************************************************

.gnum
{
 LDX #0                 \ We will build the number entered in R, so initialise
 STX R                  \ it with 0

 LDX #12                \ We will check for up to 12 key presses, so set a
 STX T1                 \ counter in T1

.TT223

 JSR TT217              \ Scan the keyboard until a key is pressed, and return
                        \ the key's ASCII code in A (and X)

 STA Q                  \ Store the key pressed in Q

 SEC                    \ Subtract ASCII '0' from the key pressed, to leave the
 SBC #'0'               \ numeric value of the key in A (if it was a number key)

 BCC OUT                \ If A < 0, jump to OUT to return from the subroutine
                        \ with a result of 0, as the key pressed was not a
                        \ number or letter and is less than ASCII "0"

 CMP #10                \ If A >= 10, jump to BAY2 to display the Inventory
 BCS BAY2               \ screen, as the key pressed was a letter or other
                        \ non-digit and is greater than ASCII "9"

 STA S                  \ Store the numeric value of the key pressed in S

 LDA R                  \ Fetch the result so far into A

 CMP #26                \ If A >= 26, where A is the number entered so far, then
 BCS OUT                \ adding a further digit will make it bigger than 256,
                        \ so jump to OUT to return from the subroutine with the
                        \ result in R (i.e. ignore the last key press)

 ASL A                  \ Set A = (A * 2) + (A * 8) = A * 10
 STA T
 ASL A
 ASL A
 ADC T

 ADC S                  \ Add the pressed digit to A and store in R, so R now
 STA R                  \ contains its previous value with the new key press
                        \ tacked onto the end

 CMP QQ25               \ If the result in R = the maximum allowed in QQ25, jump
 BEQ TT226              \ to TT226 to print the key press and keep looping (the
                        \ BEQ is needed because the BCS below would jump to OUT
                        \ if R >= QQ25, which we don't want)

 BCS OUT                \ If the result in R > QQ25, jump to OUT to return from
                        \ the subroutine with the result in R

.TT226

 LDA Q                  \ Print the character in Q (i.e. the key that was
 JSR TT26               \ pressed, as we stored the ASCII value in Q earlier)

 DEC T1                 \ Decrement the loop counter

 BNE TT223              \ Loop back to TT223 until we have checked for 12 digits

.OUT

 LDA R                  \ Set A to the result we have been building in R

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT208
\
\ Show the Sell Cargo screen (red key f2).
\
\ ******************************************************************************

.TT208
{
 LDA #4                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 4 (Sell
                        \ Cargo screen)

 LDA #4                 \ Move the text cursor to row 4, column 4
 STA YC
 STA XC

\JSR FLKB               \ This instruction is commented out in the original
                        \ source. It calls a routine to flush the keyboard
                        \ buffer (FLKB) that isn't present in the tape version
                        \ but is in the disc version

 LDA #205               \ Print recursive token 45 ("SELL")
 JSR TT27

 LDA #206               \ Print recursive token 46 (" CARGO{switch to sentence
 JSR TT68               \ case}") followed by a colon

                        \ Fall through into TT210 to show the Inventory screen
                        \ with the option to sell
}

\ ******************************************************************************
\
\ Subroutine: TT210
\
\ Show a list of current cargo in our hold, either with the abilty to sell (the
\ Sell Cargo screen) or without (the Inventory screen), depending on the current
\ view.
\
\ Arguments:
\
\   QQ11                The current view:
\
\                           * 4 = Sell Cargo
\
\                           * 8 = Inventory
\
\ ******************************************************************************

.TT210
{
 LDY #0                 \ We're going to loop through all the available market
                        \ items and check whether we have any in the hold (and,
                        \ if we are in the Sell Cargo screen, whether we want
                        \ to sell any items), so we set up a counter in Y to
                        \ denote the current item and start it at 0

.TT211

 STY QQ29               \ Store the current item number in QQ29

 LDX QQ20,Y             \ Fetch into X the amount of the current item that we
 BEQ TT212              \ have in our cargo hold, which is stored in QQ20+Y,
                        \ and if there are no items of this type in the hold,
                        \ jump down to TT212 to skip to the next item

 TYA                    \ Set Y = Y * 4, so this will act as an index into the
 ASL A                  \ market prices table at QQ23 for this item (as there
 ASL A                  \ are four bytes per item in the table)
 TAY

 LDA QQ23+1,Y           \ Fetch byte #1 from the market prices table for the
 STA QQ19+1             \ current item and store it in QQ19+1, for use by the
                        \ call to TT152 below

 TXA                    \ Store the amount of item in the hold (in X) on the
 PHA                    \ stack

 JSR TT69               \ Call TT69 to set Sentence Case and print a newline

 CLC                    \ Print recursive token 48 + QQ29, which will be in the
 LDA QQ29               \ range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               \ prints the current item's name
 JSR TT27

 LDA #14                \ Set the text cursor to column 14, for the item's
 STA XC                 \ quantity

 PLA                    \ Retore the amount of item in the hold into X
 TAX

 CLC                    \ Print the 8-bit number in X to 3 digits, without a
 JSR pr2                \ decimal point

 JSR TT152              \ Print the unit ("t", "kg" or "g") for the market item
                        \ whose byte #1 from the market prices table is in
                        \ QQ19+1 (which we set up above)

 LDA QQ11               \ If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 \ screen), jump to TT212 to skip the option to sell
 BNE TT212              \ items

 LDA #205               \ Set A to recursive token 45 ("SELL")

 JSR TT214              \ Call TT214 to print "Sell(Y/N)?" and return the
                        \ response in the C flag

 BCC TT212              \ If the response was "no", jump to TT212 to move on to
                        \ the next item

 LDA QQ29               \ We are selling this item, so fetch the item number
                        \ from QQ29

 LDX #255               \ Set QQ17 = 255 to disable printing
 STX QQ17

 JSR TT151              \ Call TT151 to set QQ24 to the item's price / 4 (the
                        \ routine doesn't print the item details, as we just
                        \ disabled printing)

 LDY QQ29               \ Set P to the amount of this item we have in our cargo
 LDA QQ20,Y             \ hold (which is the amount to sell)
 STA P

 LDA QQ24               \ Set Q to the item's price / 4
 STA Q

 JSR GCASH              \ Call GCASH to calculate
                        \
                        \   (Y X) = P * Q * 4
                        \
                        \ which will be the total price we make from this sale
                        \ (as P contains the quantity we're selling and Q
                        \ contains the item's price / 4)

 JSR MCASH              \ Add (Y X) cash to the cash pot in CASH

 LDA #0                 \ We've made the sale, so set the amount
 LDY QQ29               \ item index
 STA QQ20,Y             \ ship cargo count

 STA QQ17               \ Set QQ17 = 0, which enables printing again

.TT212

 LDY QQ29               \ Fetch the item number from QQ29 into Y, and increment
 INY                    \ Y to point to the next item

 CPY #17                \ If A >= 17 then skip the next instruction as we have
 BCS P%+5               \ done the last item

 JMP TT211              \ Otherwise loop back to TT211 to print the next item
                        \ in the hold

 LDA QQ11               \ If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 \ screen), skip the next two instructions and just return
 BNE P%+8               \ from the subroutine

 JSR dn2                \ This is the Sell Cargo screen, so call dn2 to make a
                        \ short, high beep and delay for 1 second

 JMP BAY2               \ And then jump to BAY2 to display the Inventory
                        \ screen, as we have finished selling cargo

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT213
\
\ Show the Inventory screen (red key f9).
\
\ ******************************************************************************

.TT213
{
 LDA #8                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 8 (Inventory
                        \ screen)

 LDA #11                \ Move the text cursor to column 11 to print the screen
 STA XC                 \ title

 LDA #164               \ Print recursive token 4 ("INVENTORY{crlf}") followed
 JSR TT60               \ by a paragraph break and Sentence Case

 JSR NLIN4              \ Draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR fwl                \ Call fwl to print the fuel and cash levels on two
                        \ separate lines

 LDA CRGO               \ If our ship's cargo capacity is < 26 (i.e. we do not
 CMP #26                \ have a cargo bay extension), skip the following two
 BCC P%+7               \ instructions

 LDA #107               \ We do have a cargo bay extension, so print recursive
 JSR TT27               \ token 107 ("LARGE CARGO{switch to sentence case}
                        \ BAY")

 JMP TT210              \ Jump to TT210 to print the contents of our cargo bay
                        \ and return from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT214
\
\ Ask a question with a "Y/N?" prompt and return the response.
\
\ Arguments:
\
\   A                   The text token to print before the "Y/N?" prompt
\
\ Returns:
\
\   C flag              Set if the response was "yes", clear otherwise
\
\ ******************************************************************************

.TT214
{
 PHA                    \ Print a space, using the stack to preserve the value
 JSR TT162              \ of A
 PLA

.TT221

 JSR TT27               \ Print the text token in A

 LDA #225               \ Pring recursive token 65 ("(Y/N)?")
 JSR TT27

 JSR TT217              \ Scan the keyboard until a key is pressed, and return
                        \ the key's ASCII code in A and X

 ORA #%00100000         \ Set bit 5 in the value of the key pressed, which
                        \ converts it to lower case

 CMP #'y'               \ If "y" was pressed, jump to TT218
 BEQ TT218

 LDA #'n'               \ Otherwise jump to TT26 to print "n" and return from
 JMP TT26               \ the subroutine using a tail call (so all other
                        \ responses apart from "y" indicate a no)

.TT218

 JSR TT26               \ Print the character in A, i.e. print "y"

 SEC                    \ Set the C flag to indicate a "yes" response

 RTS
}

\ ******************************************************************************
\
\ Subroutine: TT16
\
\ Move the chart crosshairs by the amount in X and Y.
\
\ Arguments:
\
\   X                   The amount to move the crosshairs in the x-axis
\
\   Y                   The amount to move the crosshairs in the y-axis
\
\ ******************************************************************************

.TT16
{
 TXA                    \ Push the change in X onto the stack (let's call this
 PHA                    \ the x-delta)

 DEY                    \ Negate the change in Y and push it onto the stack
 TYA                    \ (let's call this the y-delta)
 EOR #255
 PHA

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn and we can move the crosshairs with
                        \ no screen flicker

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 PLA                    \ Store the y-delta in QQ19+3 and fetch the current
 STA QQ19+3             \ y-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ10               \ for the call to TT123

 JSR TT123              \ Call TT123 to move the selected system's galactic
                        \ y-coordinate by the y-delta, putting the new value in
                        \ QQ19+4

 LDA QQ19+4             \ Store the updated y-coordinate in QQ10 (the current
 STA QQ10               \ y-coordinate of the crosshairs)

 STA QQ19+1             \ This instruction has no effect, as QQ19+1 is
                        \ overwritten below, both in TT103 and TT105

 PLA                    \ Store the x-delta in QQ19+3 and fetch the current
 STA QQ19+3             \ x-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ9                \ for the call to TT123

 JSR TT123              \ Call TT123 to move the selected system's galactic
                        \ x-coordinate by the x-delta, putting the new value in
                        \ QQ19+4

 LDA QQ19+4             \ Store the updated x-coordinate in QQ9 (the current
 STA QQ9                \ x-coordinate of the crosshairs)

 STA QQ19               \ This instruction has no effect, as QQ19 is overwritten
                        \ below, both in TT103 and TT105

                        \ Now we've updated the coordinates of the crosshairs,
                        \ fall through into TT103 to redraw them at their new
                        \ location
}

\ ******************************************************************************
\
\ Subroutine: TT103
\
\ Draw a small set of crosshairs on a galactic chart at the cooordinates in
\ (QQ9, QQ10).
\
\ ******************************************************************************

.TT103
{
 LDA QQ11               \ If this is a space view, return from the subroutine
 BEQ TT180              \ (as TT180 contains an RTS), as there are no moveable
                        \ crosshairs in space

 BMI TT105              \ If this is the Short-range Chart screen, jump to TT105

 LDA QQ9                \ Store the crosshairs x-coordinate in QQ19
 STA QQ19

 LDA QQ10               \ Halve the crosshairs y-coordinate and store it in QQ19
 LSR A                  \ (we halve it because the Long-range Chart is half as
 STA QQ19+1             \ high as it is wide)

 LDA #4                 \ Set QQ19+2 to 4 denote crosshairs of size 4
 STA QQ19+2

 JMP TT15               \ Jump to TT15 to draw crosshairs of size 4 at the
                        \ crosshairs coordinates, returning from the subroutine
                        \ using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT123
\
\ Move an 8-bit galactic coordinate by a certain distance in either direction
\ (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
\ overflow. The coordinate is in a single axis, so it's either an x-coordinate
\ or a y-coordinate.
\
\ Arguments:
\
\   A                   The galactic coordinate to update
\
\   QQ19+3              The delta (can be positive or negative)
\
\ Returns:
\
\   QQ19+4              The updated coordinate after moving by the delta (this
\                       will be the same as A if moving by the delta overflows)
\
\ Other entry points:
\
\   TT180               Contains an RTS
\
\ ******************************************************************************

.TT123
{
 STA QQ19+4             \ Store the original coordinate in temporary storage at
                        \ QQ19+4

 CLC                    \ Set A = A + QQ19+3, so A now contains the original
 ADC QQ19+3             \ coordinate, moved by the delta

 LDX QQ19+3             \ If the delta is negative, jump to TT124
 BMI TT124

 BCC TT125              \ If the C flag is clear, then the above addition didn't
                        \ overflow, so jump to TT125 to return the updated value

 RTS                    \ Otherwise the C flag is set and the above addition
                        \ overflowed, so do not update the return value

.TT124

 BCC TT180              \ If the C flag is clear, then because the delta is
                        \ negative, this indicates the addition (which is
                        \ effectively a subtraction) underflowed, so jump to
                        \ TT180 to return from the subroutine without updating
                        \ the return value

.TT125

 STA QQ19+4             \ Store the updated coordinate in QQ19+4

.^TT180

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT105
\
\ Check whether the crosshairs are close enough to the current system to appear
\ on the Short-range Chart, and if so, draw them.
\
\ ******************************************************************************

.TT105
{
 LDA QQ9                \ Set A = QQ9 - QQ0, the horizontal distance between the
 SEC                    \ crosshairs (QQ9) and the current system (QQ0)
 SBC QQ0

 CMP #38                \ If the horizontal distance in A is < 38, then the
 BCC TT179              \ crosshairs are close enough to the current system to
                        \ appear in the Short-range Chart, so jump to TT179 to
                        \ check the vertical distance

 CMP #230               \ If the horizontal distance in A is < -26, then the
 BCC TT180              \ crosshairs are too far from the current system to
                        \ appear in the Short-range Chart, so jump to TT180 to
                        \ return from the subroutine (as TT180 contains an RTS)

.TT179

 ASL A                  \ Set QQ19 = 104 + A * 4
 ASL A                  \
 CLC                    \ 104 is the x-coordinate of the centre of the chart,
 ADC #104               \ so this sets QQ19 to the screen pixel x-coordinate
 STA QQ19               \ of the crosshairs

 LDA QQ10               \ Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    \ crosshairs (QQ10) and the current system (QQ1)
 SBC QQ1

 CMP #38                \ If the vertical distance in A is < 38, then the
 BCC P%+6               \ crosshairs are close enough to the current system to
                        \ appear in the Short-range Chart, so skip the next two
                        \ instructions

 CMP #220               \ If the horizontal distance in A is < -36, then the
 BCC TT180              \ crosshairs are too far from the current system to
                        \ appear in the Short-range Chart, so jump to TT180 to
                        \ return from the subroutine (as TT180 contains an RTS)

 ASL A                  \ Set QQ19+1 = 90 + A * 2
 CLC                    \
 ADC #90                \ 90 is the y-coordinate of the centre of the chart,
 STA QQ19+1             \ so this sets QQ19+1 to the screen pixel x-coordinate
                        \ of the crosshairs


 LDA #8                 \ Set QQ19+2 to 8 denote crosshairs of size 8
 STA QQ19+2

 JMP TT15               \ Jump to TT15 to draw crosshairs of size 8 at the
                        \ crosshairs coordinates, returning from the subroutine
                        \ using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT23
\
\ Show the Short-range Chart (red key f5).
\
\ ******************************************************************************

.TT23
{
 LDA #128               \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 128 (Short-
                        \ range Chart)

 LDA #7                 \ Move the text cursor to column 7
 STA XC

 LDA #190               \ Print recursive token 30 ("SHORT RANGE CHART") and
 JSR NLIN3              \ draw a horizontal line at pixel row 19 to box in the
                        \ title

 JSR TT14               \ Call TT14 to draw a circle with crosshairs at the
                        \ current system's galactic coordinates

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ i.e. at the selected system

 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #0                 \ Set A = 0, which we'll use below to zero out the INWK
                        \ workspace

 STA XX20               \ We're about to start working our way through each of
                        \ the galaxy's systems, so set up a counter in XX20 for
                        \ each system, starting at 0 and looping through to 255

 LDX #24                \ First, though, we need to zero out the 25 bytes at
                        \ INWK so we can use them to work out which systems have
                        \ room for a label, so set a counter in X for 25 bytes

.EE3

 STA INWK,X             \ Set the X-th byte of INWK to zero

 DEX                    \ Decrement the counter

 BPL EE3                \ Loop back to EE3 for the next byte until we've zeroed
                        \ all 25 bytes

                        \ We now loop through every single system in the galaxy
                        \ and check the distance from the current system whose
                        \ coordinates are in (QQ0, QQ1). We get the galactic
                        \ coordinates of each system from the system's seeds,
                        \ like this:
                        \
                        \   x = w1_hi (which is stored in QQ15+3)
                        \   y = w0_hi (which is stored in QQ15+1)
                        \
                        \ so the following loops through each system in the
                        \ galaxy in turn and calculates the distance between
                        \ (QQ0, QQ1) and (w1_hi, w0_hi) to find the closest one

.TT182

 LDA QQ15+3             \ Set A = w1_hi - QQ0, the horizontal distance between
 SEC                    \ (w1_hi, w0_hi) and (QQ0, QQ1)
 SBC QQ0

 BCS TT184              \ If a borrow didn't occur, i.e. w1_hi >= QQ0, then the
                        \ result is positive, so jump to TT184 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |w1_hi - QQ0|)

.TT184

 CMP #20                \ If the horizontal distance in A is >= 20, then this
 BCS TT187              \ system is too far away from the current system to
                        \ appear in the Short-range Chart, so jump to TT187 to
                        \ move on to the next system

 LDA QQ15+1             \ Set A = w0_hi - QQ1, the vertical distance between
 SEC                    \ (w1_hi, w0_hi) and (QQ0, QQ1)
 SBC QQ1

 BCS TT186              \ If a borrow didn't occur, i.e. w0_hi >= QQ1, then the
                        \ result is positive, so jump to TT186 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |w0_hi - QQ1|)

.TT186

 CMP #38                \ If the vertical distance in A is >= 38, then this
 BCS TT187              \ system is too far away from the current system to
                        \ appear in the Short-range Chart, so jump to TT187 to
                        \ move on to the next system

                        \ This system should be shown on the Short-range Chart,
                        \ so now we need to work out where the label should go,
                        \ and set up the various variables we need to draw the
                        \ system's filled circle on the chart

 LDA QQ15+3             \ Set A = w1_hi - QQ0, the horizontal distance between
 SEC                    \ this system and the current system, where |A| < 20.
 SBC QQ0                \ Let's call this the x-delta, as it's the horizontal
                        \ difference between the current system at the centre of
                        \ the chart, and this system (and this time we keep the
                        \ sign of A, so it can be negative if it's to the left
                        \ of the chart's centre, or positive if it's to the
                        \ right)

 ASL A                  \ Set XX12 = 104 + x-delta * 4
 ASL A                  \
 ADC #104               \ 104 is the x-coordinate of the centre of the chart,
 STA XX12               \ so this sets XX12 to the centre 104 +/- 76, the pixel
                        \ x-coordinate of this system

 LSR A                  \ Move the text cursor to column x-delta / 2 + 1
 LSR A                  \ which will be in the range 1-10
 LSR A
 STA XC
 INC XC

 LDA QQ15+1             \ Set A = w0_hi - QQ1, the vertical distance between
 SEC                    \ this system and the current system, where |A| < 38.
 SBC QQ1                \ Let's call this the y-delta, as it's the vertical
                        \ difference between the current system at the centre of
                        \ the chart, and this system (and this time we keep the
                        \ sign of A, so it can be negative if it's above the
                        \ chart's centre, or positive if it's below)

 ASL A                  \ Set K4 = 90 + y-delta * 2
 ADC #90                \
 STA K4                 \ 90 is the y-coordinate of the centre of the chart,
                        \ so this sets K4 to the centre 90 +/- 74, the pixel
                        \ y-coordinate of this system

 LSR A                  \ Set Y = K4 / 8, so Y contains the number of the text
 LSR A                  \ row that contains this system
 LSR A
 TAY

                        \ Now to see if there is room for this system's label.
                        \ Ideally we would print the system name on the same
                        \ text row as the system, but we only want to print one
                        \ label per row, to prevent overlap, so now we check
                        \ this system's row, and if that's already occupied,
                        \ the row above, and if that's already occupied, the
                        \ row below... and if that's already occupied, we give
                        \ up and don't print a label for this system

 LDX INWK,Y             \ If the value in INWK+Y is 0 (i.e. the text row
 BEQ EE4                \ containing this system does not already have another
                        \ system's label on it), jump to EE4 to store this
                        \ system's label on this row

 INY                    \ If the value in INWK+Y+1 is 0 (i.e. the text row below
 LDX INWK,Y             \ the one containing this system does not already have
 BEQ EE4                \ another system's label on it), jump to EE4 to store
                        \ this system's label on this row

 DEY                    \ If the value in INWK+Y-1 is 0 (i.e. the text row above
 DEY                    \ the one containing this system does not already have
 LDX INWK,Y             \ another system's label on it), fall through into to
 BNE ee1                \ EE4 to store this system's label on this row,
                        \ otherwise jump to ee1 to skip printing a label for
                        \ this system (as there simply isn't room)

.EE4

 STY YC                 \ Now to print the label, so move the text cursor to row
                        \ Y (which contains the row where we can print this
                        \ system's label)

 CPY #3                 \ If Y < 3, then the label would clash with the chart
 BCC TT187              \ title, so jump to TT187 to skip printing the label

 DEX                    \ We entered the EE4 routine with X = 0, so this stores
 STX INWK,Y             \ &FF in INWK+Y, to denote that this row is now occupied
                        \ so we don't try to print another system's label on
                        \ this row

 LDA #128               \ Set QQ17 to 128, which denotes Sentence Case
 STA QQ17

 JSR cpl                \ Call cpl to print out the system name for the seeds
                        \ in QQ15 (which now contains the seeds for the current
                        \ system)

.ee1

 LDA #0                 \ Now to plot the star, so set the high bytes of K, K3
 STA K3+1               \ and K4 to 0
 STA K4+1
 STA K+1

 LDA XX12               \ Set the low byte of K3 to XX12, the pixel x-coordinate
 STA K3                 \ of this system

 LDA QQ15+5             \ Fetch w2_hi for this system from QQ15+5, extract bit 0
 AND #1                 \ and add 2 to get the size of the star, which we store
 ADC #2                 \ in K. This will be either 2, 3 or 4, depending on the
 STA K                  \ value of bit 0, and whether the C flag is set (which
                        \ will vary depending on what happens in the above call
                        \ to cpl). Incidentally, the planet's average radius
                        \ also uses w2_hi, bits 0-3 to be precise, but that
                        \ doesn't mean the two sizes affect each other

                        \ We now have the following:
                        \
                        \   K(1 0)  = radius of star (2, 3 or 4)
                        \
                        \   K3(1 0) = pixel x-coordinate of system
                        \
                        \   K4(1 0) = pixel y-coordinate of system
                        \
                        \ which we can now pass to the SUN routine to draw a
                        \ small "sun" on the Short-range Chart for this system

 JSR FLFLLS             \ Call FLFLLS to reset the LSO block

 JSR SUN                \ Call SUN to plot a sun with radius K at pixel
                        \ coordinate (K3, K4)

 JSR FLFLLS             \ Call FLFLLS to reset the LSO block

.TT187

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 INC XX20               \ Increment the counter

 BEQ TT111-1            \ If X = 0 then we have done all 256 systems, so return
                        \ from the subroutine (as TT111-1 contains an RTS)

 JMP TT182              \ Otherwise jump back up to TT182 to process the next
                        \ system
}

\ ******************************************************************************
\
\ Subroutine: TT81
\
\ Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
\ seeds for the selected system (QQ15) - in other words, set the selected
\ system's seeds to those of the system 0.
\
\ ******************************************************************************

.TT81
{
 LDX #5                 \ Set up a counter in X to copy six bytes (for three
                        \ 16-bit numbers)

 LDA QQ21,X             \ Copy the X-th byte in QQ21 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    \ Decrement the counter

 BPL TT81+2             \ Loop back up to the LDA instruction if we still have
                        \ more bytes to copy

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT111
\
\ Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
\ to this point in the galaxy, and set this as the currently selected system.
\
\ Arguments:
\
\   QQ9                 The x-coordinate near which we want to find a system
\
\   QQ10                The y-coordinate near which we want to find a system
\
\ Returns:
\
\   QQ8(1 0)            The distance from the current system to the nearest
\                       system to the original coordinates
\
\   QQ9                 The x-coordinate of the nearest system to the original
\                       coordinates
\
\   QQ10                The y-coordinate of the nearest system to the original
\                       coordinates
\
\   QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
\                       original coordinates
\
\ Other entry points:
\
\   TT111-1             Contains an RTS
\
\ ******************************************************************************

.TT111
{
 JSR TT81               \ Set the seeds in QQ15 to those of system 0 in the
                        \ current galaxy (i.e. copy the seeds from QQ21 to QQ15)

                        \ We now loop through every single system in the galaxy
                        \ and check the distance from (QQ9, QQ10). We get the
                        \ galactic coordinates of each system from the system's
                        \ seeds, like this:
                        \
                        \   x = w1_hi (which is stored in QQ15+3)
                        \   y = w0_hi (which is stored in QQ15+1)
                        \
                        \ so the following loops through each system in the
                        \ galaxy in turn and calculates the distance between
                        \ (QQ9, QQ10) and (w1_hi, w0_hi) to find the closest one

 LDY #127               \ Set Y = T = 127 to hold the shortest distance we've
 STY T                  \ found so far, which we initially set to half the
                        \ distance across the galaxy, or 127, as our coordinate
                        \ system ranges from (0,0) to (255, 255)

 LDA #0                 \ Set A = U = 0 to act as a counter for each system in
 STA U                  \ the current galaxy, which we start at system 0 and
                        \ loop through to 255, the last system

.TT130

 LDA QQ15+3             \ Set A = w1_hi - QQ9, the horizontal distance between
 SEC                    \ (w1_hi, w0_hi) and (QQ9, QQ10)
 SBC QQ9

 BCS TT132              \ If a borrow didn't occur, i.e. w1_hi >= QQ9, then the
                        \ result is positive, so jump to TT132 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |w1_hi - QQ9|)

.TT132

 LSR A                  \ Set S = A / 2
 STA S                  \       = |w1_hi - QQ9| / 2

 LDA QQ15+1             \ Set A = w0_hi - QQ10, the vertical distance between
 SEC                    \ (w1_hi, w0_hi) and (QQ9, QQ10)
 SBC QQ10

 BCS TT134              \ If a borrow didn't occur, i.e. w0_hi >= QQ10, then the
                        \ result is positive, so jump to TT134 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |w0_hi - QQ10|)

.TT134

 LSR A                  \ Set A = S + A / 2
 CLC                    \       = |w1_hi - QQ9| / 2 + |w0_hi - QQ10| / 2
 ADC S                  \
                        \ So A now contains the sum of the horizontal and
                        \ vertical distances, both divided by 2 so the result
                        \ fits into one byte, and although this doesn't contain
                        \ the actual distance between the systems, it's a good
                        \ enough approximation to use for comparing distances

 CMP T                  \ If A >= T, then this system's distance is bigger than
 BCS TT135              \ our "minimum distance so far" stored in T, so it's no
                        \ closer than the systems we have already found, so
                        \ skip to TT135 to move on to the next system

 STA T                  \ This system is the closest to (QQ9, QQ10) so far, so
                        \ update T with the new "distance" approximation

 LDX #5                 \ As this system is the closest we have found yet, we
                        \ want to store the system's seeds in case it ends up
                        \ being the closest of all, so we set up a counter in X
                        \ to copy six bytes (for three 16-bit numbers)

.TT136

 LDA QQ15,X             \ Copy the X-th byte in QQ15 to the X-th byte in QQ19,
 STA QQ19,X             \ where QQ15 contains the seeds for the system we just
                        \ found to be the closest so far, and QQ19 is temporary
                        \ storage

 DEX                    \ Decrement the counter

 BPL TT136              \ Loop back to TT136 if we still have more bytes to
                        \ copy

.TT135

 JSR TT20               \ We want to move on to the next system, so call TT20
                        \ to twist the three 16-bit seeds in QQ15

 INC U                  \ Increment the system counter in U

 BNE TT130              \ If U > 0 then we haven't done all 256 systems yet, so
                        \ loop back up to TT130

                        \ We have now finished checking all the systems in the
                        \ galaxy, and the seeds for the closest system are in
                        \ QQ19, so now we want to copy these seeds to QQ15,
                        \ to set the selected system to this closest system

 LDX #5                 \ So we set up a counter in X to copy six bytes (for
                        \ three 16-bit numbers)

.TT137

 LDA QQ19,X             \ Copy the X-th byte in QQ19 to the X-th byte in QQ15,
 STA QQ15,X

 DEX                    \ Decrement the counter

 BPL TT137              \ Loop back to TT137 if we still have more bytes to
                        \ copy

 LDA QQ15+1             \ The y-coordinate of the system described by the seeds
 STA QQ10               \ in QQ15 is in QQ15+1 (w0_hi), so we copy this to QQ10
                        \ as this is where we store the selected system's
                        \ y-coordinate

 LDA QQ15+3             \ The x-coordinate of the system described by the seeds
 STA QQ9                \ in QQ15 is in QQ15+3 (w1_hi), so we copy this to QQ9
                        \ as this is where we store the selected system's
                        \ x-coordinate

                        \ We have now found the closest system to (QQ9, QQ10)
                        \ and have set it as the selected system, so now we
                        \ need to work out the distance between the selected
                        \ system and the current system

 SEC                    \ Set A = QQ9 - QQ0, the horizontal distance between
 SBC QQ0                \ the selected system's x-coordinate (QQ9) and the
                        \ current system's x-coordinate (QQ0)

 BCS TT139              \ If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
                        \ result is positive, so jump to TT139 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |QQ9 - QQ0|)

                        \ A now contains the difference between the two
                        \ systems' x-coordinates, with the sign removed. We
                        \ will refer to this as the x-delta ("delta" means
                        \ change or difference in maths)

.TT139

 JSR SQUA2              \ Set (A P) = A * A
                        \           = |QQ9 - QQ0| ^ 2
                        \           = x_delta ^ 2

 STA K+1                \ Store (A P) in K(1 0)
 LDA P
 STA K

 LDA QQ10               \ Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    \ selected system's y-coordinate (QQ10) and the current
 SBC QQ1                \ system's y-coordinate (QQ1)

 BCS TT141              \ If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
                        \ result is positive, so jump to TT141 and skip the
                        \ following two instructions

 EOR #&FF               \ Otherwise negate the result in A, so A is always
 ADC #1                 \ positive (i.e. A = |QQ10 - QQ1|)

.TT141

 LSR A                  \ Set A = A / 2

                        \ A now contains the difference between the two
                        \ systems' y-coordinates, with the sign removed, and
                        \ halved. We halve the value because the galaxy in
                        \ in Elite is rectangular rather than square, and is
                        \ twice as wide (x-axis) as it is high (y-axis), so to
                        \ get a distance that matches the shape of the
                        \ long-range galaxy chart, we need to halve the
                        \ distance between the vertical y-coordinates. We will
                        \ refer to this as the y-delta


 JSR SQUA2              \ Set (A P) = A * A
                        \           = (|QQ10 - QQ1| / 2) ^ 2
                        \           = y_delta ^ 2

                        \ By this point we have the following results:
                        \
                        \   K(1 0) = x_delta ^ 2
                        \    (A P) = y_delta ^ 2
                        \
                        \ so to find the distance between the two points, we
                        \ can use Pythagoras - so first we need to add the two
                        \ results together, and then take the square root

 PHA                    \ Store the high byte of the y-axis value on the stack,
                        \ so we can use A for another purpose

 LDA P                  \ Set Q = P + K, which adds the low bytes of the two
 CLC                    \ calculated values
 ADC K
 STA Q

 PLA                    \ Restore the high byte of the y-axis value from the
                        \ stack into A again

 ADC K+1                \ Set R = A + K+1, which adds the high bytes of the two
 STA R                  \ calculated values, so we now have:
                        \
                        \   (R Q) = K(1 0) + (A P)
                        \         = (x_delta ^ 2) + (y_delta ^ 2)

 JSR LL5                \ Set Q = SQRT(R Q), so Q now contains the distance
                        \ between the two systems, in terms of coordinates

                        \ We now store the distance to the selected system * 4
                        \ in the two-byte location QQ8, by taking (0 Q) and
                        \ shifting it left twice, storing it in (QQ8+1 QQ8)

 LDA Q                  \ First we shift the low byte left by setting
 ASL A                  \ A = Q * 2, with bit 7 of A going into the C flag

 LDX #0                 \ Now we set the high byte in QQ8+1 to 0 and rotate
 STX QQ8+1              \ the C flag into bit 0 of QQ8+1
 ROL QQ8+1

 ASL A                  \ And then we repeat the shift left of (QQ8+1 A)
 ROL QQ8+1

 STA QQ8                \ And store A in the low byte, QQ8, so QQ8(1 0) now
                        \ contains Q * 4. Given that the width of the galaxy is
                        \ 256 in coordinate terms, the width of the galaxy
                        \ would be 1024 in the units we store in QQ8

 JMP TT24               \ Call TT24 to calculate system data from the seeds in
                        \ QQ15 and store them in the relevant locations, so our
                        \ new selected system is fully set up, and return from
                        \ the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: hy6
\
\ Print "Docked" at the bottom of the screen to indicate we can't hyperspace
\ when docked.
\
\ ******************************************************************************

.hy6
{
 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #15                \ Move the text cursor to column 15 (the middle of the
 STA XC                 \ screen), setting A to 15 at the same time for the
                        \ following call to TT27

 JMP TT27               \ Print recursive token 129 ("{switch to sentence case}
                        \ DOCKED") and return from the subroutine using a tail
                        \ call
}

\ ******************************************************************************
\
\ Subroutine: hyp
\
\ Start the hyperspace process. Called when "H" or CTRL-H is pressed during
\ flight. Checks the following:
\
\   * We are in space
\
\   * We are not already in a hyperspace countdown
\
\ If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
\ othwerwise we check that:
\
\   * The selected system is not the current system
\
\   * We have enough fuel to make the jump
\
\ and if all the pre-jump checks are passed, we print the destination on screen
\ and start the countdown.
\
\ ******************************************************************************

.hyp
{
 LDA QQ12               \ If we are docked (QQ12 = &FF) then jump to hy6 to
 BNE hy6                \ print an error message and return from the subroutine
                        \ using a tail call (as we can't hyperspace when docked)

 LDA QQ22+1             \ Fetch QQ22+1, which contains the number that's shown
                        \ on-screen during hyperspace countdown

 BNE zZ+1               \ If it is non-zero, return from the subroutine (as zZ+1
                        \ contains an RTS), as there is already a countdown in
                        \ progress

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed

 BMI Ghy                \ If it is, then the galactic hyperdrive has been
                        \ activated, so jump to Ghy to process it

 JSR hm                 \ Set the system closest to galactic coordinates (QQ9,
                        \ QQ10) as the selected system

 LDA QQ8                \ If both bytes of the distance to the selected system
 ORA QQ8+1              \ in QQ8 are zero, return from the subroutine (as zZ+1
 BEQ zZ+1               \ contains an RTS), as the selected system is the
                        \ current system

 LDA #7                 \ Move the text cursor to column 7, row 23 (in the
 STA XC                 \ middle of the bottom text row)
 LDA #23
 STA YC

 LDA #0                 \ Set QQ17 = 0 for ALL CAPS
 STA QQ17

 LDA #189               \ Print recursive token 29 ("HYPERSPACE ")
 JSR TT27

 LDA QQ8+1              \ If the high byte of the distance to the selected
 BNE TT147              \ system in QQ8 is > 0, then it is definitely too far to
                        \ jump (as our maximum range is 7.0 light years, or a
                        \ value of 70 in QQ8(1 0), so jump to TT147 to print
                        \ "RANGE?" and return from the subroutine using a tail
                        \ call

 LDA QQ14               \ Fetch our current fuel level from Q114 into A

 CMP QQ8                \ If our fuel reserves are less than the distance to the
 BCC TT147              \ selected system, then we don't have enough fuel for
                        \ this jump, so jump to TT147 to print "RANGE?" and
                        \ return from the subroutine using a tail call

 LDA #'-'               \ Print a hyphen
 JSR TT27

 JSR cpl                \ Call cpl to print the name of the selected system

                        \ Fall through into wW to start the hyperspace
                        \ countdown
}

\ ******************************************************************************
\
\ Subroutine: wW
\
\ Start the hyperspace countdown (for both inter-system hyperspace and the
\ galactic hyperdrive).
\
\ ******************************************************************************

.wW
{
 LDA #15                \ The hyperspace countdown starts from 15, so set A to
                        \ to 15 so we can set the two hyperspace counters

 STA QQ22+1             \ Set the number in QQ22+1 to 15, which is the number
                        \ that's shown on screen during the hyperspace countdown

 STA QQ22               \ Set the number in QQ22 to 15, which is the internal
                        \ counter that counts down by 1 each iteration of the
                        \ main game loop, and each time it reaches zero, the
                        \ on-screen counter gets decremented, and QQ22 gets set
                        \ to 5, so setting QQ22 to 15 here makes the first tick
                        \ of the hyperspace counter longer than subsequent ticks

 TAX                    \ Print the 8-bit number in X (i.e. 15) at text location
 JMP ee3                \ (0, 1), padded to 5 digits, so it appears in the top
                        \ left corner of the screen, and return from the
                        \ subroutine using a tail call

\hy5                    \ This instruction and the hy5 label are commented out
\RTS                    \ in the original - they can actually be found at the
                        \ end of the jmp routine below, so perhaps this is where
                        \ they were originally, but the authors realised they
                        \ could save a byte by using a tail call instead of an
                        \ RTS?
}

\ ******************************************************************************
\
\ Subroutine: Ghy
\
\ Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
\ being pressed.
\
\ This routine also updates the galaxy seeds to point to the next galaxy. Using
\ a galactic hyperdrive rotates each seed byte to the left, rolling each byte
\ left within itself like this:
\
\   01234567 -> 12345670
\
\ to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
\ roll round to those of the first galaxy again.
\
\ We always arrive in a new galaxy at galactic coordinates (96, 96), and then
\ find the nearest system and set that as our location.
\
\ Other entry points:
\
\   zZ+1                Contains an RTS
\
\ ******************************************************************************

.Ghy
{
\JSR TT111              \ This instruction is commented out in the original
                        \ source, and appears in the text cassette code source
                        \ (ELITED.TXT) but not in the BASIC source file on the
                        \ source disc (ELITED). It finds the closest system to
                        \ coordinates (QQ9, QQ10)

 LDX GHYP               \ Fetch GHYP, which tells us whether we own a galactic
 BEQ hy5                \ hyperdrive, and if it is zero, which means we don't,
                        \ return from the subroutine (as hy5 contains an RTS)

 INX                    \ We own a galactic hyperdrive, so X is &FF, so this
                        \ instruction sets X = 0

 STX QQ8                \ Set the distance to the selected system in (QQ8+1 QQ8)
 STX QQ8+1              \ to 0

 STX GHYP               \ The galactic hyperdrive is a one-use item, so set GHYP
                        \ to 0 so we no longer have one fitted

 STX FIST               \ Changing galaxy also clears our criminal record, so
                        \ set our legal status in FIST to 0 ("clean")

 JSR wW                 \ Call wW to start the hyperspace countdown

 LDX #5                 \ To move galaxy, we rotate the galaxy's seeds left, so
                        \ set a counter in X for the 6 seed bytes

 INC GCNT               \ Increment the current galaxy number in GCNT

 LDA GCNT               \ Set GCNT = GCNT mod 7, so we jump from galaxy 7 back
 AND #7                 \ to galaxy 0 (shown in-game as going from galaxy 8 back
 STA GCNT               \ to the starting point in galaxy 1)

.G1

 LDA QQ21,X             \ Load the X-th seed byte into A

 ASL A                  \ Set the C flag to bit 7 of the seed

 ROL QQ21,X             \ Rotate the seed in memory, which will add bit 7 back
                        \ in as bit 0, so this rolls the seed around on itself

 DEX                    \ Decrement the counter

 BPL G1                 \ Loop back for the next seed byte, until we have
                        \ rotated them all

\JSR DORND              \ This instruction is commented out in the original
                        \ source, and would set A and X to random numbers, so
                        \ perhaps the original plan was to arrive in each new
                        \ galaxy in a random place?

.^zZ

 LDA #&60               \ Set (QQ9, QQ10) to (96, 96), which is where we always
 STA QQ9                \ arrive in a new galaxy (the selected system will be
 STA QQ10               \ set to the nearest actual system later on)

 JSR TT110              \ Call TT110 to show the forward space view

 LDA #116               \ Print recursive token 116 (GALACTIC HYPERSPACE ")
 JSR MESS               \ as an in-flight message

                        \ Fall through into jmp to set the system to the
                        \ current system and return from the subroutine there
}

\ ******************************************************************************
\
\ Subroutine: jmp
\
\ Set the current system to the selected system.
\
\ Returns:
\
\   (QQ0, QQ1)          The galactic coordinates of the new system
\
\ Other entry points:
\
\   hy5                 Contains an RTS
\
\ ******************************************************************************

.jmp
{
 LDA QQ9                \ Set the current system's galactic x-coordinate to the
 STA QQ0                \ x-coordinate of the selected system

 LDA QQ10               \ Set the current system's galactic y-coordinate to the
 STA QQ1                \ y-coordinate of the selected system

.^hy5

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: ee3
\
\ Print the 8-bit number in X at text location (0, 1). Print the number to
\ 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
\ numbers < 10000 are right-aligned), with no decimal point.
\
\ Arguments:
\
\   X                   The number to print
\
\ ******************************************************************************

.ee3
{
 LDY #1                 \ Set YC = 1 (first row)
 STY YC

 DEY                    \ Set XC = 0 (first character)
 STY XC

                        \ Fall through into pr6 to print X to 5 digits
}

\ ******************************************************************************
\
\ Subroutine: pr6
\
\ Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
\ numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
\ with no decimal point.
\
\ Arguments:
\
\   X                   The low byte of the number to print
\
\   Y                   The high byte of the number to print
\
\ ******************************************************************************

.pr6
{
 CLC                    \ Do not display a decimal point when printing

                        \ Fall through into pr5 to print X to 5 digits
}

\ ******************************************************************************
\
\ Subroutine: pr5
\
\ Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
\ numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
\ Optionally include a decimal point.
\
\ Arguments:
\
\   X                   The low byte of the number to print
\
\   Y                   The high byte of the number to print
\
\   C flag              If set, include a decimal point
\
\ ******************************************************************************

.pr5
{
 LDA #5                 \ Set the number of digits to print to 5

 JMP TT11               \ Call TT11 to print (Y X) to 5 digits and return from
                        \ the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT147
\
\ Print "RANGE?" for when the hyperspace distance is too far.
\
\ ******************************************************************************

.TT147
{
 LDA #202               \ Load A with token 42 ("RANGE") and fall through into
                        \ prq to print it, followed by a question mark
}

\ ******************************************************************************
\
\ Subroutine: prq
\
\ Print a text token followed by a question mark.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.prq
{
 JSR TT27               \ Print the text token in A

 LDA #'?'               \ Print a question mark and return from the
 JMP TT27               \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT151
\
\ Print the item name, market price and availability for a market item.
\
\ Arguments:
\
\   A                   The number of the market item to print, 0-16 (see QQ23
\                       for details of item numbers)
\
\ Results:
\
\   QQ19+1              Byte #1 from the market prices table for this item
\
\   QQ24                The item's price / 4
\
\   QQ25                The item's availability
\
\ ******************************************************************************
\
\ Deep dive: Market prices
\ ------------------------
\ Item prices are calculated using a formula that takes a number of variables
\ into consideration, and mixes in a bit of random behaviour to boot. This is
\ the formula, which is performed as an 8-bit calculation:
\
\   price = ((base_price + (random AND mask) + economy * economic_factor)) * 4
\
\ The resulting price is 10 times the displayed price, so we can show it to one
\ decimal place. The individual items in the calculation are as follows:
\
\   * The item's base_price is byte #0 in the market prices table at QQ23, so
\     it's 19 for food, 20 for textiles, 235 for narcotics and so on.
\
\   * Each time we arrive in a new system, a random number is generated and
\     stored in location QQ26, and this is shown as "random" in the calculation
\     above.
\
\   * The item's mask is byte #3 in the market prices table at QQ23, so
\     it's &01 for food, &03 for textiles, &78 for narcotics and so on. The
\     more set bits there are in this mask, and the higher their position in
\     this byte, the larger the price fluctuations for this commodity, as the
\     random number is AND'd with the mask. So narcotics will vary wildly in
\     price, while food and textiles will be relatively stable.
\
\   * The economy for a system is given in a 3-bit value, from 0 to 7, that is
\     stored in QQ28. This value is described in more detail in routine TT24,
\     but this is the range of values:
\
\       0 = Rich Industrial
\       1 = Average Industrial
\       2 = Poor Industrial
\       3 = Mainly Industrial
\       4 = Mainly Agricultural
\       5 = Rich Agricultural
\       6 = Average Agricultural
\       7 = Poor Agricultural
\
\   * The economic_factor is stored in bits 0-4 of byte #1 in the market prices
\     table at QQ23, and its sign is in bit 7, so it's -2 for food, -1 for
\     textiles, +8 for narcotics and so on. Negative factors show products that
\     tend to be cheaper than average in agricultural economies but closer to
\     average in rich industrial ones, while positive factors are more
\     expensive in poor agricultural systems than rich industrial ones - so
\     food is cheaper in poor agricultural systems while narcotics are very
\     expensive, and it's the other way round in rich industrial systems,
\     where narcotics are closer to the average price, but food is pricier.
\
\   * The units for this item (i.e. tonnes, grams pr kilograms) are given by
\     bits 5-6 of of byte #1 in the market prices table at QQ23.
\
\ ******************************************************************************

.TT151
{
 PHA                    \ Store the item number on the stack and in QQ14+4
 STA QQ19+4

 ASL A                  \ Store the item number * 4 in QQ19, so this will act as
 ASL A                  \ an index into the market prices table at QQ23 for this
 STA QQ19               \ item (as there are four bytes per item in the table)

 LDA #1                 \ Set the text cursor to column 1, for the item's name
 STA XC

 PLA                    \ Restore the item number

 ADC #208               \ Print recursive token 48 + A, which will be in the
 JSR TT27               \ range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
                        \ prints the item's name

 LDA #14                \ Set the text cursor to column 14, for the price
 STA XC

 LDX QQ19               \ Fetch byte #1 from the market prices table (units and
 LDA QQ23+1,X           \ economic_factor) for this item and store in QQ19+1
 STA QQ19+1

 LDA QQ26               \ Fetch the random number for this system visit and
 AND QQ23+3,X           \ AND with byte #3 from the market prices table (mask)
                        \ to give:
                        \
                        \   A = random AND mask

 CLC                    \ Add byte #0 from the market prices table (base_price),
 ADC QQ23,X             \ so we now have:
 STA QQ24               \
                        \   A = base_price + (random AND mask)

 JSR TT152              \ Call TT152 to print the item's unit ("t", "kg" or
                        \ "g"), padded to a width of two characters

 JSR var                \ Call var to set QQ19+3 = economy * |economic_factor|
                        \ (and set the availability of Alien Items to 0)

 LDA QQ19+1             \ Fetch the byte #1 that we stored above and jump to
 BMI TT155              \ TT155 if it is negative (i.e. if the economic_factor
                        \ is negative)

 LDA QQ24               \ Set A = QQ24 + QQ19+3
 ADC QQ19+3             \
                        \       = base_price + (random AND mask)
                        \         + (economy * |economic_factor|)
                        \
                        \ which is the result we want, as the economic_factor
                        \ is positive

 JMP TT156              \ Jump to TT156 to multiply the result by 4

.TT155

 LDA QQ24               \ Set A = QQ24 - QQ19+3
 SEC                    \
 SBC QQ19+3             \       = base_price + (random AND mask)
                        \         - (economy * |economic_factor|)
                        \
                        \ which is the result we want, as economic_factor
                        \ is negative

.TT156

 STA QQ24               \ Store the result in QQ24 and P
 STA P

 LDA #0                 \ Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
 JSR GC2                \ which is the same as (Y X) = P * 4 because A = 0

 SEC                    \ We now have our final price, * 10, so we can call pr5
 JSR pr5                \ to print (Y X) to 5 digits, including a decimal
                        \ point, as the carry flag is set

 LDY QQ19+4             \ We now move on to availability, so fetch the market
                        \ item number that we stored in QQ19+4 at the start

 LDA #5                 \ Set A to 5 so we can print the availability to 5
                        \ digits (right-padded with spaces)

 LDX AVL,Y              \ Set X to the item's availability, which is given in
                        \ the AVL table

 STX QQ25               \ Store the availability in QQ25

 CLC                    \ Clear the carry flag

 BEQ TT172              \ If none are available, jump to TT172 to print a tab
                        \ and a "-"

 JSR pr2+2              \ Otherwise print the 8-bit number in X to 5 digits,
                        \ right-aligned with spaces. This works because we set
                        \ A to 5 above, and we jump into the pr2 routine just
                        \ after the first instruction, which would normally
                        \ set the number of digits to 3

 JMP TT152              \ Print the unit ("t", "kg" or "g") for the market item,
                        \ with a following space if required to make it two
                        \ characters long

.TT172

 LDA XC                 \ Move the text cursor in XC to the right by 4 columns,
 ADC #4                 \ so the cursor is where the last digit would be if we
 STA XC                 \ were printing a 5-digit availability number

 LDA #'-'               \ Print a "-" character by jumping to TT162+2, which
 BNE TT162+2            \ contains JMP TT27 (this BNE is effectively a JMP as A
                        \ will never be zero), and return from the subroutine
                        \ using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT152
\
\ Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
\ market prices table is in QQ19+1, right-padded with spaces to a width of two
\ characters (so that's "t ", "kg" or "g ").
\
\ ******************************************************************************

.TT152
{
 LDA QQ19+1             \ Fetch the economic_factor from QQ19+1

 AND #96                \ If bits 5 and 6 are both clear, jump to TT160 to
 BEQ TT160              \ print "t" for tonne, followed by a space, and return
                        \ from the subroutine using a tail call

 CMP #32                \ If bit 5 is set, jump to TT161 to print "kg" for
 BEQ TT161              \ kilograms, and return from the subroutine using a tail
                        \ call

 JSR TT16a              \ Otherwise call TT16a to print "g" for grams, and fall
                        \ through into TT162 to print a space and return from
                        \ the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT162
\
\ Print a space.
\
\ ******************************************************************************

.TT162
{
 LDA #' '               \ Load a space character into A

 JMP TT27               \ Print the text token in A and return from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT160
\
\ Print "t" (for tonne) and a space.
\
\ ******************************************************************************

.TT160
{
 LDA #'t'               \ Load a "t" character into A

 JSR TT26               \ Print the character, using TT216 so that it doesn't
                        \ change the character case

 BCC TT162              \ Jump to TT162 to print a space and return from the
                        \ subroutine using a tail call (this BCC is effectively
                        \ a JMP as carry is cleared by TT26)
}

\ ******************************************************************************
\
\ Subroutine: TT161
\
\ Print "kg" (for kilograms).
\
\ ******************************************************************************

.TT161
{
 LDA #'k'               \ Load a "k" character into A

 JSR TT26               \ Print the character, using TT216 so that it doesn't
                        \ change the character case, and fall through into
                        \ TT16a to print a "g" character
}

\ ******************************************************************************
\
\ Subroutine: TT16a
\
\ Print "g" (for grams).
\
\ ******************************************************************************

.TT16a
{
 LDA #&67               \ Load a "k" character into A

 JMP TT26               \ Print the character, using TT216 so that it doesn't
                        \ change the character case, and return from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT163
\
\ Print the column headers for the prices table in the Buy Cargo and Market
\ Price screens.
\
\ ******************************************************************************

.TT163
{
 LDA #17                \ Move the text cursor in XC to column 17
 STA XC

 LDA #255               \ Print recursive token 95 token ("UNIT  QUANTITY
 BNE TT162+2            \ {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
                        \ jumping to TT162+2, which contains JMP TT27 (this BNE
                        \ is effectively a JMP as A will never be zero), and
                        \ return from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT167
\
\ Show the Market Price screen (red key f7).
\
\ ******************************************************************************

.TT167
{
 LDA #16                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 16 (Market
                        \ Price screen)

 LDA #5                 \ Move the text cursor to column 4
 STA XC

 LDA #167               \ Print recursive token 7 token ("{current system name}
 JSR NLIN3              \ MARKET PRICES") and draw a horizontal line at pixel
                        \ row 19 to box in the title

 LDA #3                 \ Move the text cursor to row 3
 STA YC

 JSR TT163              \ Print the column headers for the prices table

 LDA #0                 \ We're going to loop through all the available market
 STA QQ29               \ items, so we set up a counter in QQ29 to denote the
                        \ current item and start it at 0

.TT168

 LDX #128               \ Set QQ17 = 128 to switch to Sentence Case, with the
 STX QQ17               \ next letter in capitals

 JSR TT151              \ Call TT151 to print the item name, market price and
                        \ availability of the current item, and set QQ24 to the
                        \ item's price / 4, QQ25 to the quantity available and
                        \ QQ19+1 to byte #1 from the market prices table for
                        \ this item

 INC YC                 \ Move the text cursor down one row

 INC QQ29               \ Increment QQ29 to point to the next item

 LDA QQ29               \ If QQ29 >= 17 then jump to TT168 as we have done the
 CMP #17                \ last item
 BCC TT168

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: var
\
\ Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
\ table for an item. Also sets the availability of Alien Items to 0.
\
\ This routine forms part of the calculations for market item prices (TT151)
\ and availability (GVL).
\
\ Arguments:
\
\   QQ19+1              Byte #1 of the market prices table for this market item
\                       (which contains the economic_factor in bits 0-5, and the
\                       sign of the economic_factor in bit 7)
\
\ ******************************************************************************

.var
{
 LDA QQ19+1             \ Extract bits 0-5 from QQ19+1 into A, to get the
 AND #31                \ economic_factor without its sign, in other words:
                        \
                        \   A = |economic_factor|

 LDY QQ28               \ Set Y to the economy byte of the current system

 STA QQ19+2             \ Store A in QQ19+2

 CLC                    \ Clear the carry flag so we can do additions below

 LDA #0                 \ Set AVL+16 (availability of Alien Items) to 0,
 STA AVL+16             \ setting A to 0 in the process

.TT153                  \ We now do the multiplication by doing a series of
                        \ additions in a loop, building the result in A. Each
                        \ loop adds QQ19+2 (|economic_factor|) to A, and it
                        \ loops the number of times given by the economy byte;
                        \ in other words, because A starts at 0, this sets:
                        \
                        \   A = economy * |economic_factor|

 DEY                    \ Decrement the economy in Y, exiting the loop when it
 BMI TT154              \ becomes negative

 ADC QQ19+2             \ Add QQ19+2 to A

 JMP TT153              \ Loop back to TT153 to do another addition

.TT154

 STA QQ19+3             \ Store the result in QQ19+3

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: hyp1
\
\ Do a hyperspace jump to the system closest to galactic coordinates
\ (QQ9, QQ10), and set up the current system's state to those of the new system.
\
\ Returns:
\
\   (QQ0, QQ1)          The galactic coordinates of the new system
\
\   QQ2 to QQ2+6        The seeds of the new system
\
\   EV                  Set to 0
\
\   QQ28                The new system's economy
\
\   tek                 The new system's tech level
\
\   gov                 The new system's government
\
\ Other entry points:
\
\   hyp1+3              Jump straight to the the system at (QQ9, QQ10) without
\                       first calculating which system is closest. We do this
\                       if we already know that (QQ9, QQ10) points to a system
\
\ ******************************************************************************

.hyp1
{
 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 JSR jmp                \ Set the current system to the selected system

 LDX #5                 \ We now want to copy the seeds for the selected system
                        \ in QQ15 into QQ2, where we store the seeds for the
                        \ current system, so set up a counter in X for copying
                        \ 6 bytes (for three 16-bit seeds)

.TT112

 LDA QQ15,X             \ Copy the X-th byte in QQ15 to the X-th byte in QQ2,
 STA QQ2,X

 DEX                    \ Decrement the counter

 BPL TT112              \ Loop back to TT112 if we still have more bytes to
                        \ copy

 INX                    \ Set X = 0 (as we ended the above loop with X = &FF)

 STX EV                 \ Set EV, the extra vessels spawning counter, to 0, as
                        \ we are entering a new system with no extra vessels
                        \ spawned

 LDA QQ3                \ Set the current system's economy in QQ28 to the
 STA QQ28               \ selected system's economy from QQ3

 LDA QQ5                \ Set the current system's tech level in tek to the
 STA tek                \ selected system's economy from QQ5

 LDA QQ4                \ Set the current system's government in gov to the
 STA gov                \ selected system's government from QQ4

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: GVL
\
\ Calculate the availability for each market item and store it in AVL. This is
\ called on arrival in a new system.
\
\ Other entry points:
\
\   hyR                 Contains an RTS
\
\ ******************************************************************************
\
\ Deep dive: Market item availability
\ -----------------------------------
\ Item availability is calculated using a formula that takes a number of
\ variables into consideration, and mixes in a bit of random behaviour to boot.
\ This is the formula, which is performed as an 8-bit calculation:
\
\   availability =
\       ((base_availability + (random AND mask) - economy * economic_factor))
\       mod 64
\
\ If the result of the above is less than 0, then availability is set to 0. See
\ the documentation for routine TT151 for more details of the values in the
\ above calculation.
\
\ ******************************************************************************

.GVL
{
 JSR DORND              \ Set A and X to random numbers

 STA QQ26               \ Set QQ26 to the random byte that's used in the market
                        \ calculations

 LDX #0                 \ We are now going to loop through the market item
 STX XX4                \ availability table in AVL, so set a counter in XX4
                        \ (and X) for the market item number, starting with 0

.hy9

 LDA QQ23+1,X           \ Fetch byte #1 from the market prices table (units and
 STA QQ19+1             \ economic_factor) for item number X and store it in
                        \ QQ19+1

 JSR var                \ Call var to set QQ19+3 = economy * |economic_factor|
                        \ (and set the availability of Alien Items to 0)

 LDA QQ23+3,X           \ Fetch byte #3 from the market prices table (mask) and
 AND QQ26               \ AND with the random number for this system visit
                        \ to give:
                        \
                        \   A = random AND mask

 CLC                    \ Add byte #2 from the market prices table
 ADC QQ23+2,X           \ (base_quantity) so we now have:
                        \
                        \   A = base_quantity + (random AND mask)

 LDY QQ19+1             \ Fetch the byte #1 that we stored above and jump to
 BMI TT157              \ TT157 if it is negative (i.e. if the economic_factor
                        \ is negative)

 SEC                    \ Set A = A - QQ19+3
 SBC QQ19+3             \
                        \       = base_quantity + (random AND mask)
                        \         - (economy * |economic_factor|)
                        \
                        \ which is the result we want, as the economic_factor
                        \ is positive

 JMP TT158              \ Jump to TT158 to skip TT157

.TT157

 CLC                    \ Set A = A + QQ19+3
 ADC QQ19+3             \
                        \       = base_quantity + (random AND mask)
                        \         + (economy * |economic_factor|)
                        \
                        \ which is the result we want, as the economic_factor
                        \ is negative

.TT158

 BPL TT159              \ If A < 0, then set A = 0, so we don't have negative
 LDA #0                 \ availibility

.TT159

 LDY XX4                \ Fetch the counter (the market item number) into Y

 AND #%00111111         \ Take bits 0-5 of A, i.e. A mod 64, and store this as
 STA AVL,Y              \ this item's availability in the Y=th byte of AVL, so
                        \ each item has a maximum availability of 63t

 INY                    \ Increment the counter into XX44, Y and A
 TYA
 STA XX4

 ASL A                  \ Set X = counter * 4, so that X points to the next
 ASL A                  \ item's entry in the four-byte market prices table,
 TAX                    \ ready for the next loop

 CMP #63                \ If A < 63, jump back up to hy9 to set the availability
 BCC hy9                \ for the next market item

.^hyR

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: GTHG
\
\ Spawn a Thargoid ship and a Thargon companion.
\
\ ******************************************************************************

.GTHG
{
 JSR Ze                 \ Call Ze to initialise INWK

 LDA #%11111111         \ Set the AI flag in INWK+32 so that the ship has AI, is
 STA INWK+32            \ extremely and aggressively hostile, and has E.C.M.

 LDA #THG               \ Call NWSHP to add a new Thargoid ship to our local
 JSR NWSHP              \ bubble of universe

 LDA #TGL               \ Call NWSHP to add a new Thargon ship to our local
 JMP NWSHP              \ bubble of universe, and return from the subroutine
                        \ using a tail call
}

\ ******************************************************************************
\
\ Subroutine: MJP
\
\ Process a mis-jump into witchspace (which happens very rarely). Witchspace has
\ a strange, almost dust-free aspect to it, and it is populated by hostile
\ Thargoids. Using our escape pod will be fatal, and our position on the
\ galactic chart is inbetween systems. It is a scary place...
\
\ There is a 1% chance that this routine is is called from TT18 instead of doing
\ a normal hyperspace, or we can manually trigger a mis-jump by holding down
\ CTRL after first enabling the "author display" configuration option ("X") when
\ paused.
\
\ Other entry points:
\
\   ptg                 Called when the user manually forces a mis-jump
\
\ ******************************************************************************

{
.^ptg

 LSR COK                \ Set bit 0 of COK, the competition code, so that the
 SEC                    \ code shows we have manually forced a mis-jump into
 ROL COK                \ witchspace

.^MJP

\LDA #1                 \ This instruction is commented out in the original
                        \ source - it is not required as a call to TT66-2 sets
                        \ A to 1 for us. This is presumably an example of the
                        \ authors saving a couple of bytes by calling TT66-2
                        \ instead of TT66, while leaving the original LDA
                        \ instruction in place

 JSR TT66-2             \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 1

 JSR LL164              \ Call LL164 to show the hyperspace tunnel and make the
                        \ hyperspace sound for a second time (as we already
                        \ called LL164 in TT18)

 JSR RES2               \ Reset a number of flight variables and workspaces, as
                        \ well as setting Y to &FF

 STY MJ                 \ Set the mis-jump flag in MJ to &FF, to indicate that
                        \ we are now in witchspace

.MJP1

 JSR GTHG               \ Call GTHG to spawn a Thargoid ship

 LDA #3                 \ Fetch the number of Thargoid ships from MANY+THG, and
 CMP MANY+THG           \ if it is less than 3, loop back to MJP1 to spawn
 BCS MJP1               \ another one, until we have three Thargoids

 STA NOSTM              \ Set NOSTM (the maximum number of stardust particles)
                        \ to 3, so there are fewer bits of stardust in
                        \ witchspace (normal space has a maximum of 18)

 LDX #0                 \ Initialise the forward space view
 JSR LOOK1

 LDA QQ1                \ Fetch the current system's galactic y-coordinate in
 EOR #%00011111         \ QQ1 and flip bits 0-5, so we end up somewhere in the
 STA QQ1                \ vicinity of our original destination, but above or
                        \ below it in the galactic chart

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT18
\
\ Try to go through hyperspace. Called from TT102 in the main loop when the
\ hyperspace countdown has finished.
\
\ ******************************************************************************

.TT18
{
 LDA QQ14               \ Subtract the distance to the selected system (in QQ8)
 SEC                    \ from the amount of fuel in our tank (in QQ14)
 SBC QQ8
 STA QQ14

 LDA QQ11               \ If ths current view is not a space view, jump to ee5
 BNE ee5                \ to skip the following

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 0 (space
                        \ view)

 JSR LL164              \ Call LL164 to show the hyperspace tunnel and make the
                        \ hyperspace sound

.ee5

 JSR CTRL               \ Scan the keyboard to see if CTRL is currently pressed,
                        \ returning a negative value in A if it is

 AND PATG               \ If the game is configured to show the author's names
                        \ on the start-up screen, then PATG will contain &FF,
                        \ otherwise it will be 0

 BMI ptg                \ By now, A will be negative if we are holding down CTRL
                        \ and author names are configured, which is what we have
                        \ to do in order to trigger a manual mis-jump, so jump
                        \ to ptg to do a mis-jump (ptg not only mis-jumps, but
                        \ changes the competition code, so Acornsoft could tell
                        \ whether this feature had been used in a competition
                        \ entry)

 JSR DORND              \ Set A and X to random numbers

 CMP #253               \ If A >= 253 (1% chance) then jump to MJP to trigger a
 BCS MJP                \ mis-jump into witchspace

\JSR TT111              \ This instruction is commented out in the original
                        \ source. It finds the closest system to coordinates
                        \ (QQ9, QQ10), but we don't need to do this as the
                        \ crosshairs will already be on a system by this point

 JSR hyp1+3             \ Jump straight to the the system at (QQ9, QQ10) without
                        \ first calculating which system is closest

 JSR GVL                \ Calculate the availability for each market item in the
                        \ new system

 JSR RES2               \ Reset a number of flight variables and workspaces

 JSR SOLAR              \ Halve our legal status, update the missile indicators,
                        \ and set up data blocks and slots for the planet and
                        \ sun

 LDA QQ11               \ If the current view in QQ11 is not a space view (0) or
 AND #%00111111         \ one of the charts (64 or 128), return from the
 BNE hyR                \ subroutine (as hyR contains an RTS)

 JSR TTX66              \ Otherwise clear the screen and draw a white border

 LDA QQ11               \ If the current view is one of the charts, jump to
 BNE TT114              \ TT114 (from which we jump to the correct routine to
                        \ display the chart)

 INC QQ11               \ This is a space view, so increment QQ11 to 1

                        \ Fall through into TT110 to show the forward space view
}

\ ******************************************************************************
\
\ Subroutine: TT110
\
\ Launch the ship (if we are docked), or show the forward space view (if we are
\ already in space).
\
\ Called when red key f0 is pressed while docked (launch), after we arrive in a
\ new galaxy, or after a hyperspace if the current view is a space view.
\
\ ******************************************************************************

.TT110
{
 LDX QQ12               \ If we are not docked (QQ12 = 0) then jump to NLUNCH
 BEQ NLUNCH

 JSR LAUN               \ Show the space station launch tunnel

 JSR RES2               \ Reset a number of flight variables and workspaces

 JSR TT111              \ Select the system closest to galactic coordinates
                        \ (QQ9, QQ10)

 INC INWK+8             \ Increment z_sign ready for the call to SOS, so the
                        \ planet appears at a z_sign of 1 in front of us when
                        \ we launch

 JSR SOS1               \ Call SOS1 to set up the planet's data block and add it
                        \ to FRIN, where it will get put in the first slot as
                        \ it's the first one to be added to our little bubble of
                        \ universe following the call to RES2 above

 LDA #128               \ For the space station, set z_sign to &80, so it's
 STA INWK+8             \ behind us (&80 is negative)

 INC INWK+7             \ And increment z_hi, so it's only just behind us

 JSR NWSPS              \ Add a new space station to our little bubble of
                        \ universe

 LDA #12                \ Set our launch speed in DELTA to 12
 STA DELTA

 JSR BAD                \ Call BAD to work out how much illegal contraband we
                        \ are carrying in our hold (A is up to 40 for a
                        \ standard hold crammed with contraband, up to 70 for
                        \ an extended cargo hold full of narcotics and slaves)

 ORA FIST               \ OR the value in A with our legal status in FIST to
                        \ get a new value that is at least as high as both
                        \ values, to reflect the fact that launching with a
                        \ hold full of contraband can only make matters worse

 STA FIST               \ Update our legal status with the new value

.NLUNCH

 LDX #0                 \ Set QQ12 to 0 to indicate we are not docked
 STX QQ12

 JMP LOOK1              \ Jump to LOOK1 to switch to the front view (X = 0),
                        \ returning from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT114
\
\ Display either the Long-range or Short-range Chart, depending on the current
\ view setting. Called from TT18 once we know the current view is one of the
\ charts.
\
\ Arguments:
\
\   A                   The current view, loaded from QQ11
\
\ ******************************************************************************

.TT114
{
 BMI TT115              \ If bit 7 of the current view is set (i.e. the view is
                        \ the Short-range Chart, 128), skip to TT115 below to
                        \ jump to TT23 to display the chart

 JMP TT22               \ Otherwise the current view is the Long-range Chart, so
                        \ jump to TT22 to display it

.TT115

 JMP TT23               \ Jump to TT23 to display the Short-range Chart
}

\ ******************************************************************************
\
\ Subroutine: LCASH
\
\ Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
\ cash in the pot. As CASH is a four-byte number, this calculates:
\
\   CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
\
\ Returns:
\
\   C flag              If set, there was enough cash to do the subtraction
\
\                       If clear, there was not enough cash to do the
\                       subtraction
\
\ ******************************************************************************

.LCASH
{
 STX T1                 \ Subtract the least significant bytes:
 LDA CASH+3             \
 SEC                    \   CASH+3 = CASH+3 - X
 SBC T1
 STA CASH+3

 STY T1                 \ Then the second most significant bytes:
 LDA CASH+2             \
 SBC T1                 \   CASH+2 = CASH+2 - Y
 STA CASH+2

 LDA CASH+1             \ Then the third most significant bytes (which are 0):
 SBC #0                 \
 STA CASH+1             \   CASH+1 = CASH+1 - 0

 LDA CASH               \ And finally the most significant bytes (which are 0):
 SBC #0                 \
 STA CASH               \   CASH = CASH - 0

 BCS TT113              \ If the C flag is set then the subtraction didn't
                        \ underflow, so the value in CASH is correct and we can
                        \ jump to TT113 to return from the subroutine with the
                        \ C flag set to indicate success (as TT113 contains an
                        \ RTS)

                        \ Otherwise we didn't have enough cash in CASH to
                        \ subtract (Y X) from it, so fall through into
                        \ MCASH to reverse the sum and restore the original
                        \ value in CASH, and returning with the C flag clear
}

\ ******************************************************************************
\
\ Subroutine: MCASH
\
\ Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
\ calculates:
\
\   CASH(0 1 2 3) = CASH(0 1 2 3) + (0 0 Y X)
\
\ Other entry points:
\
\   TT113               Contains an RTS
\
\ ******************************************************************************

.MCASH
{
 TXA                    \ Add the least significant bytes:
 CLC                    \
 ADC CASH+3             \   CASH+3 = CASH+3 + X
 STA CASH+3

 TYA                    \ Then the second most significant bytes:
 ADC CASH+2             \
 STA CASH+2             \   CASH+2 = CASH+2 + Y

 LDA CASH+1             \ Then the third most significant bytes (which are 0):
 ADC #0                 \
 STA CASH+1             \   CASH+1 = CASH+1 + 0

 LDA CASH               \ And finally the most significant bytes (which are 0):
 ADC #0                 \
 STA CASH               \   CASH = CASH + 0

 CLC                    \ Clear the C flag, so if the above was done following
                        \ a failed LCASH call, the C flag correctly indicates
                        \ failure

.^TT113

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: GCASH
\
\ Calculate the following multiplication of unsigned 8-bit numbers:
\
\   (Y X) = P * Q * 4
\
\ ******************************************************************************

.GCASH
{
 JSR MULTU              \ Call MULTU to calculate (A P) = P * Q
}

\ ******************************************************************************
\
\ Subroutine: GC2
\
\ Calculate the following multiplication of unsigned 16-bit numbers:
\
\   (Y X) = (A P) * 4
\
\ ******************************************************************************

.GC2
{
 ASL P                  \ Set (A P) = (A P) * 4
 ROL A
 ASL P
 ROL A

 TAY                    \ Set (Y X) = (A P)
 LDX P

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: EQSHP
\
\ Show the Equip Ship screen (red key f3).
\
\ Other entry points:
\
\   err                 Beep, pause and go to the docking bay (i.e. show the
\                       Status Mode screen)
\
\ ******************************************************************************

{
.bay

 JMP BAY                \ Go to the docking bay (i.e. show the Status Mode
                        \ screen)

.^EQSHP

 JSR DIALS              \ Call DIALS to update the dashboard

 LDA #32                \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 32 (Equip
                        \ Ship screen)

 LDA #12                \ Move the text cursor to column 12
 STA XC

 LDA #207               \ Print recursive token 47 ("EQUIP") followed by a space
 JSR spc

 LDA #185               \ Print recursive token 25 ("SHIP") and draw a
 JSR NLIN3              \ horizontal line at pixel row 19 to box in the title

 LDA #128               \ Set QQ17 = 128 to switch to Sentence Case, with the
 STA QQ17               \ next letter in capitals

 INC YC                 \ Move the text cursor down one line

 LDA tek                \ Fetch the tech level of the current system from tek
 CLC                    \ and add 3 (the tech level is stored as 0-14, so A is
 ADC #3                 \ now set to between 3 and 17)

 CMP #12                \ If A >= 12 then set A = 12, so A is now set to between
 BCC P%+4               \ 3 and 12
 LDA #12

 STA Q                  \ Set QQ25 = A (so QQ25 is in the range 3-12 and
 STA QQ25               \ represents number of the most advanced item available
 INC Q                  \ in this system, which we can pass to gnum below when
                        \ asking which item we want to buy)
                        \
                        \ Set Q = A + 1 (so Q is in the range 4-13 and contains
                        \ QQ25 + 1, i.e. the highest item number on sale + 1)

 LDA #70                \ Set A = 70 - QQ14, where QQ14 contains the current
 SEC                    \ level in light years * 10, so this leaves the amount
 SBC QQ14               \ of fuel we need to fill 'er up (in light years * 10)

 ASL A                  \ The price of fuel is always 2 Cr per light year, so we
 STA PRXS               \ double A and store it in PRXS, as the first price in
                        \ the price list (which is reserved for fuel), and
                        \ because the table contains prices as price * 10, it's
                        \ in the right format (so a full tank, or 7.0 light
                        \ years, would be 14.0 Cr, or a PRXS value of 140)

 LDX #1                 \ We are now going to work our way through the equipment
                        \ price list at PRXS, printing out the equipment that is
                        \ available at this station, so set a counter in X,
                        \ starting at 1, to hold the number of the current item
                        \ plus 1 (so the item number in X loops through 1-13)

.EQL1

 STX XX13               \ Store the current item number + 1 in XX13

 JSR TT67               \ Print a newline

 LDX XX13               \ Print the current item number + 1 to 3 digits, left-
 CLC                    \ padding with spaces, and with no decimal point, so the
 JSR pr2                \ items are numbered from 1

 JSR TT162              \ Print a space

 LDA XX13               \ Print recursive token 104 + XX13, which will be in the
 CLC                    \ range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
 ADC #104               \ so this prints the current item's name
 JSR TT27

 LDA XX13               \ Call prx-3 to set (Y X) to the price of the item with
 JSR prx-3              \ number XX13 - 1 (as XX13 contains the item number + 1)

 SEC                    \ Set the C flag so we will print a decimal point when
                        \ we print the price

 LDA #25                \ Move the text cursor to column 25
 STA XC

 LDA #6                 \ Print the number in (Y X) to 6 digits, left-padding
 JSR TT11               \ with spaces and including a decimal point, which will
                        \ be the correct price for this item as (Y X) contains
                        \ the price * 10, so the trailing zero will go after the
                        \ decimal point (i.e. 5250 will be printed as 525.0)

 LDX XX13               \ Increment the current item number in XX13
 INX

 CPX Q                  \ If X < Q, loop back up to print the next item on the
 BCC EQL1               \ list of equipment available at this station

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

 LDA #127               \ Print recursive token 127 ("ITEM") followed by a
 JSR prq                \ question mark

 JSR gnum               \ Call gnum to get a number from the keyboard, which
                        \ will be the number of the item we want to purchase,
                        \ returning the number entered in A and R, and setting
                        \ the C flag if the number is bigger than the highest
                        \ item number in QQ25

 BEQ bay                \ If no number was entered, jump up to bay to go to the
                        \ docking bay (i.e. show the Status Mode screen)

 BCS bay                \ If the number entered was too big, jump up to bay to
                        \ go to the docking bay (i.e. show the Status Mode
                        \ screen)

 SBC #0                 \ Set A to the number entered - 1 (because the C flag is
                        \ clear), which will be the actual item number we want
                        \ to buy

 LDX #2                 \ Move the text cursor to column 2 on the next line
 STX XC
 INC YC

 PHA                    \ While preserving the value in A, call eq to subtract
 JSR eq                 \ the price of the item we want to buy (which is in A)
 PLA                    \ from our cash pot, but only if we have enough cash in
                        \ the pot. If we don't have enough cash, exit to the
                        \ docking bay (i.e. show the Status Mode screen)

 BNE et0                \ If A is not 0 (i.e. the item we've just bought is not
                        \ fuel), skip to et0

 STA MCNT               \ We just bought fuel, so we zero the main loop counter

 LDX #70                \ And set the current fuel level * 10 in QQ14 to 70, or
 STX QQ14               \ 7.0 light years (a full tank)

.et0

 CMP #1                 \ If A is not 1 (i.e. the item we've just bought is not
 BNE et1                \ a missile), skip to et1

 LDX NOMSL              \ Fetch the current number of missiles from NOMSL into X

 INX                    \ Increment X to the new number of missiles

 LDY #117               \ Set Y to recursive token 117 ("ALL")

 CPX #5                 \ If buying this missile would give us 5 missiles, this
 BCS pres               \ is more than the maximum of 4 missiles that we can
                        \ fit, so jump to pres to show the error "All Present",
                        \ beep and exit to the docking bay (i.e. show the Status
                        \ Mode screen)

 STX NOMSL              \ Otherwise update the number of missiles in NOMSL

 JSR msblob             \ And call msblob to update the dashboard's missile
                        \ indicators with our new purchase

.et1

 LDY #107               \ Set Y to recursive token 107 ("LARGE CARGO{switch to
                        \ sentence case} BAY")

 CMP #2                 \ If A is not 2 (i.e. the item we've just bought is not
 BNE et2                \ a large cargo bay), skip to et2

 LDX #37                \ If our current cargo capacity in CRGO is 37, then we
 CPX CRGO               \ already have a large cargo bay fitted, so jump to pres
 BEQ pres               \ to show the error "Large Cargo Bay Present", beep and
                        \ exit to the docking bay (i.e. show the Status Mode
                        \ screen)

 STX CRGO               \ Otherwise we just scored ourselves a large cargo bay,
                        \ so update our current cargo capacity in CRGO to 37

.et2

 CMP #3                 \ If A is not 3 (i.e. the item we've just bought is not
 BNE et3                \ an E.C.M. system), skip to et3

 INY                    \ Increment Y to recursive token 108 ("E.C.M.SYSTEM")

 LDX ECM                \ If we already have an E.C.M. fitted (i.e. ECM is
 BNE pres               \ non-zero), jump to pres to show the error "E.C.M.
                        \ System Present", beep and exit to the docking bay
                        \ (i.e. show the Status Mode screen)

 DEC ECM                \ Otherwise we just took delivery of a brand new E.C.M.
                        \ system, so set ECM to &FF (as ECM was 0 before the DEC
                        \ instruction)

.et3

 CMP #4                 \ If A is not 4 (i.e. the item we've just bought is not
 BNE et4                \ an extra pulse laser), skip to et4

 JSR qv                 \ Print a menu listing the four available laser mounts,
                        \ with a "View ?" prompt, and ask for a view number,
                        \ returned in X (which now contains 0-3)

 LDA #4                 \ This instruction doesn't appear to do anything, as we
                        \ either don't need it (if we already have this laser)
                        \ or we set A to 4 below (if we buy it)

 LDY LASER,X            \ If there is no laser mounted in the chosen view (i.e.
 BEQ ed4                \ LASER+X, which contains the laser power for mount X,
                        \ is zero), jump to ed4 to buy a pulse laser

.ed7

 LDY #187               \ Otherwise we already have a laser mounted in this
 BNE pres               \ view, so jump to pres with Y set to token 27
                        \ (" LASER") to show the error "Laser Present", beep
                        \ and exit to the docking bay (i.e. show the Status
                        \ Mode screen)

.ed4

 LDA #POW               \ We just bought a pulse laser for view X, so we need
 STA LASER,X            \ to mount it by storing the laser power for a pulse
                        \ laser (given in POW) in LASER+X

 LDA #4                 \ Set A to 4 as we just overwrote the original value,
                        \ and we still need it set correctly so we can continue
                        \ through the conditional statements for all the other
                        \ equipment

.et4

 CMP #5                 \ If A is not 5 (i.e. the item we've just bought is not
 BNE et5                \ an extra beam laser), skip to et5

 JSR qv                 \ Print a menu listing the four available laser mounts,
                        \ with a "View ?" prompt, and ask for a view number,
                        \ returned in X (which now contains 0-3)

 STX T1                 \ Store the view in T1 so we can retrieve it below

 LDA #5                 \ Set A to 5 as the call to qv will have overwritten
                        \ the original value, and we still need it set
                        \ correctly so we can continue through the conditional
                        \ statements for all the other equipment

 LDY LASER,X            \ If there is no laser mounted in the chosen view (i.e.
 BEQ ed5                \ LASER+X, which contains the laser power for mount X,
                        \ is zero), jump to ed5 to buy a beam laser

\BPL P%+4               \ This instruction is commented out in the original
                        \ source, though it would have no effect (it would
                        \ simply skip the BMI if A is positive, which is what
                        \ BMI does anyway)

 BMI ed7                \ If there is a beam laser already mounted in the chosen
                        \ view (i.e. LASER+X has bit 7 set, which indicates a
                        \ beam laser rather than a pulse laser), skip back to
                        \ ed7 to print a "Laser Present" error, beep and exit
                        \ to the docking bay (i.e. show the Status Mode screen)

 LDA #4                 \ If we get here then we already have a pulse laser in
 JSR prx                \ the selected view, so we call prx to set (Y X) to the
                        \ price of equipment item number 4 (extra pulse laser)
                        \ so we can give a refund of the pulse laser

 JSR MCASH              \ Add (Y X) cash to the cash pot in CASH, so we refund
                        \ the price of the pulse laser we are exchanging for a
                        \ new beam laser

.ed5

 LDA #POW+128           \ We just bought a beam laser for view X, so we need
 LDX T1                 \ to mount it by storing the laser power for a beam
 STA LASER,X            \ laser (given in POW+128) in LASER+X, using the view
                        \ number we stored in T1 earlier, as the call to prx
                        \ will have overwritten the original value in X


.et5

 LDY #111               \ Set Y to recursive token 107 ("FUEL SCOOPS")

 CMP #6                 \ If A is not 6 (i.e. the item we've just bought is not
 BNE et6                \ a fuel scoop), skip to et6

 LDX BST                \ If we already have fuel scoops fitted (i.e. BST is
 BEQ ed9                \ zero), jump to ed9, otherwise fall through into pres
                        \ to show the error "Fuel Scoops Present", beep and
                        \ exit to the docking bay (i.e. show the Status Mode
                        \ screen)

.pres                   \ If we get here we need to show an error to say that
                        \ item number A is already present, where the item's
                        \ name is recursive token Y

 STY K                  \ Store the item's name in K

 JSR prx                \ Call prx to set (Y X) to the price of equipment item
                        \ number A

 JSR MCASH              \ Add (Y X) cash to the cash pot in CASH, as the station
                        \ already took the money for this item in the JSR eq
                        \ instruction above, but we can't fit the item, so need
                        \ our money back

 LDA K                  \ Print the recursive token in K (the item's name)
 JSR spc                \ followed by a space

 LDA #31                \ Print recursive token 145 ("PRESENT")
 JSR TT27

.^err

 JSR dn2                \ Call dn2 to make a short, high beep and delay for 1
                        \ second

 JMP BAY                \ Jump to BAY to go to the docking bay (i.e. show the
                        \ Status Mode screen)

.ed9

 DEC BST                \ We just bought a shiny new fuel scoop, so set BST to
                        \ &FF (as BST was 0 before the jump to ed9 above)

.et6

 INY                    \ Increment Y to recursive token 112 ("E.C.M.SYSTEM")

 CMP #7                 \ If A is not 7 (i.e. the item we've just bought is not
 BNE et7                \ an escape pod), skip to et7

 LDX ESCP               \ If we already have an escape pod fitted (i.e. ESCP is
 BNE pres               \ non-zero), jump to pres to show the error "Escape Pod
                        \ Present", beep and exit to the docking bay (i.e. show
                        \ the Status Mode screen)

 DEC ESCP               \ Otherwise we just bought an escape pod, so set ESCP
                        \ to &FF (as ESCP was 0 before the DEC instruction)

.et7

 INY                    \ Increment Y to recursive token 113 ("ENERGY BOMB")

 CMP #8                 \ If A is not 8 (i.e. the item we've just bought is not
 BNE et8                \ an energy bomb), skip to et8

 LDX BOMB               \ If we already have an energy bomb fitted (i.e. BOMB
 BNE pres               \ is non-zero), jump to pres to show the error "Energy
                        \ Bomb Present", beep and exit to the docking bay (i.e.
                        \ show the Status Mode screen)

 LDX #&7F               \ Otherwise we just bought an energy bomb, so set BOMB
 STX BOMB               \ to &7F

.et8

 INY                    \ Increment Y to recursive token 114 ("ENERGY UNIT")

 CMP #9                 \ If A is not 9 (i.e. the item we've just bought is not
 BNE etA                \ an energy unit), skip to etA

 LDX ENGY               \ If we already have an energy unit fitted (i.e. ENGY is
 BNE pres               \ non-zero), jump to pres to show the error "Energy Unit
                        \ Present", beep and exit to the docking bay (i.e. show
                        \ the Status Mode screen)

 INC ENGY               \ Otherwise we just picked up an energy unit, so set
                        \ ENGY to 1 (as ENGY was 0 before the INC instruction)

.etA

 INY                    \ Increment Y to recursive token 115 ("DOCKING
                        \ COMPUTERS")

 CMP #10                \ If A is not 10 (i.e. the item we've just bought is not
 BNE etB                \ a docking computer), skip to etB

 LDX DKCMP              \ If we already have a docking computer fitted (i.e.
 BNE pres               \ DKCMP is non-zero), jump to pres to show the error
                        \ "Docking Computer Present", beep and exit to the
                        \ docking bay (i.e. show the Status Mode screen)

 DEC DKCMP              \ Otherwise we just got hold of a docking computer, so
                        \ set DKCMP to &FF (as DKCMP was 0 before the DEC
                        \ instruction)

.etB

 INY                    \ Increment Y to recursive token 116 ("GALACTIC
                        \ HYPERSPACE ")

 CMP #11                \ If A is not 11 (i.e. the item we've just bought is not
 BNE et9                \ a galactic hyperdrive), skip to et9

 LDX GHYP               \ If we already have a galactic hyperdrive fitted (i.e.
 BNE pres               \ GHYP is non-zero), jump to pres to show the error
                        \ "Galactic Hyperspace Present", beep and exit to the
                        \ docking bay (i.e. show the Status Mode screen)

 DEC GHYP               \ Otherwise we just splashed out on a galactic
                        \ hyperdrive, so set GHYP to &FF (as GHYP was 0 before
                        \ the DEC instruction)

.et9

 JSR dn                 \ We are done buying equipment, so print the amount of
                        \ cash left in the cash pot, then make a short, high
                        \ beep to confirm the purchase, and delay for 1 second

 JMP EQSHP              \ Jump back up to EQSHP to show the Equip Ship screen
                        \ again and see if we can't track down another bargain
}

\ ******************************************************************************
\
\ Subroutine: dn
\
\ Print the amount of money in the cash pot, then make a short, high beep and
\ delay for 1 second.
\
\ ******************************************************************************

.dn
{
 JSR TT162              \ Print a space

 LDA #119               \ Print recursive token 119 ("CASH:{cash right-aligned
 JSR spc                \ to width 9} CR{crlf}") followed by a space

                        \ Fall through into dn2 to make a beep and delay for
                        \ 1 second before returning from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: dn2
\
\ Make a short, high beep and delay for 1 second.
\
\ ******************************************************************************

.dn2
{
 JSR BEEP               \ Call the BEEP subroutine to make a short, high beep

 LDY #50                \ Delay for 50 vertical syncs (50/50 = 1 second) and
 JMP DELAY              \ return from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: eq
\
\ If we have enough cash, subtract the price of a specified piece of equipment
\ from our cash pot and return from the subroutine. If we don't have enough
\ cash, exit to the docking bay (i.e. show the Status Mode screen).
\
\ Arguments:
\
\   A                   The item number of the piece of equipment (0-11) as
\                       shown in the table at PRXS
\
\ ******************************************************************************

.eq
{
 JSR prx                \ Call prx to set (Y X) to the price of equipment item
                        \ number A

 JSR LCASH              \ Subtract (Y X) cash from the cash pot, but only if
                        \ we have enough cash

 BCS c                  \ If the C flag is set then we did have enough cash for
                        \ the transaction, so jump to c to return from the
                        \ subroutine (as c contains an RTS)

 LDA #197               \ Otherwise we don't have enough cash to but this piece
 JSR prq                \ of equipment, so print recursive token 37 ("CASH")
                        \ followed by a question mark

 JMP err                \ Jump to err to beep, pause and go to the docking bay
                        \ (i.e. show the Status Mode screen)
}

\ ******************************************************************************
\
\ Subroutine: prx
\
\ Return the price of a piece of equipment, as listed in the table at PRXS.
\
\ Arguments:
\
\   A                   The item number of the piece of equipment (0-11) as
\                       shown in the table at PRXS
\
\ Returns:
\
\   (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
\
\ Other entry points:
\
\   prx-3               Return the price of the item with number A - 1
\
\ ******************************************************************************

{
 SEC                    \ Decrement A (for when this routine is called via
 SBC #1                 \ prx-3)

.^prx

 ASL A                  \ Set Y = A * 2, so it can act as an index into the
 TAY                    \ PRXS table, which has two bytes per entry

 LDX PRXS,Y             \ Fetch the low byte of the price into X

 LDA PRXS+1,Y           \ Fetch the low byte of the price into A and transfer
 TAY                    \ it to X, so the price is now in (Y X)

.^c

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: qv
\
\ Print a menu in the bottom-middle of the screen, at row 16, column 12, that
\ lists the four available laser mounts, like this:
\
\                 0 Front
\                 1 Rear
\                 2 Left
\                 3 Right
\
\ Also print a "View ?" prompt and ask for a view number. The menu is shown
\ when we choose to buy a new laser in the Equip Ship screen.
\
\ Returns:
\
\   X                   The chosen view number (0-3)
\
\ ******************************************************************************

.qv
{
 LDY #16                \ Move the text cursor to row 16, and at the same time
 STY YC                 \ set Y to a counter going from 16-20 in the loop below

.qv1

 LDX #12                \ Move the text cursor to column 12
 STX XC

 TYA                    \ Transfer the counter value from Y to A

 CLC                    \ Print ASCII character "0" - 16 + A, so as A goes from
 ADC #'0'-16            \ 16 to 20, this prints "0" through "3" followed by a
 JSR spc                \ space

 LDA YC                 \ Print recursive text token 80 + YC, so as YC goes from
 CLC                    \ 16 to 20, this prints "FRONT", "REAR", "LEFT" and
 ADC #80                \ "RIGHT"
 JSR TT27

 INC YC                 \ Move the text cursor down a row)

 LDY YC                 \ Update Y with the incremented counter in YC

 CPY #20                \ If Y < 20 then loop back up to qv1 to print the next
 BCC qv1                \ view in the menu

.qv3

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows

.qv2

 LDA #175               \ Print recursive text token 15 ("VIEW ") followed by
 JSR prq                \ a question mark

 JSR TT217              \ Scan the keyboard until a key is pressed, and return
                        \ the key's ASCII code in A (and X)

 SEC                    \ Subtract ASCII '0' from the key pressed, to leave the
 SBC #'0'               \ numeric value of the key in A (if it was a number key)

 CMP #4                 \ If the number entered in A >= 4, then it is not a
 BCS qv3                \ valid view number, so jump back to qv3 to try again

 TAX                    \ We have a valid view number, so transfer it to X

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Save output/ELTD.bin
\
\ ******************************************************************************

PRINT "ELITE D"
PRINT "Assembled at ", ~CODE_D%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_D%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_D%

PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
SAVE "output/ELTD.bin", CODE_D%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE E
\
\ Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_E% = P%
LOAD_E% = LOAD% + P% - CODE%

MAPCHAR '(', '('EOR&A4
MAPCHAR 'C', 'C'EOR&A4
MAPCHAR ')', ')'EOR&A4
MAPCHAR 'B', 'B'EOR&A4
MAPCHAR 'e', 'e'EOR&A4
MAPCHAR 'l', 'l'EOR&A4
MAPCHAR '/', '/'EOR&A4
MAPCHAR 'r', 'r'EOR&A4
MAPCHAR 'a', 'a'EOR&A4
MAPCHAR 'b', 'b'EOR&A4
MAPCHAR 'n', 'n'EOR&A4
MAPCHAR '1', '1'EOR&A4
MAPCHAR '9', '9'EOR&A4
MAPCHAR '8', '8'EOR&A4
MAPCHAR '4', '4'EOR&A4

.BDOLLAR
 EQUS  "(C)Bell/Braben1984"

MAPCHAR '(', '('
MAPCHAR 'C', 'C'
MAPCHAR ')', ')'
MAPCHAR 'B', 'B'
MAPCHAR 'e', 'e'
MAPCHAR 'l', 'l'
MAPCHAR '/', '/'
MAPCHAR 'r', 'r'
MAPCHAR 'a', 'a'
MAPCHAR 'b', 'b'
MAPCHAR 'n', 'n'
MAPCHAR '1', '1'
MAPCHAR '9', '9'
MAPCHAR '8', '8'
MAPCHAR '4', '4'

\ ******************************************************************************
\
\ Subroutine: cpl
\
\ Print control code 3 (the selected system name, i.e. the one in the crosshairs
\ in the short range chart).
\
\ ******************************************************************************
\
\ Deep dive: Generating system names
\ ----------------------------------
\ System names are generated from the three 16-bit seeds for that system. In
\ the case of the selected system, those seeds live at QQ15. The process works
\ as follows, where w0, w1, w2 are the seeds for the system in question
\
\   1. Check bit 6 of w0_lo. If it is set then we will generate four two-letter
\      pairs for the name (8 characters in total), otherwise we will generate
\      three pairs (6 characters).
\
\   2. Generate the first two letters by taking bits 0-4 of w2_hi. If this is
\      zero, jump to the next step, otherwise we have a number in the range
\      1-31. Add 128 to get a number in the range 129-159, and convert this to
\      a two-letter token (see variable QQ18 for more on two-letter tokens).
\
\   3. Twist the seeds by calling TT54 and repeat the previous step, until we
\      have processed three or four pairs, depending on step 1.
\
\ One final note. As the process above involves twisting the seeds three or
\ four times, they will be changed, so we also need to back up the original
\ seeds before starting the above process, and restore them afterwards.
\
\ ******************************************************************************

.cpl
{
 LDX #5                 \ First we need to backup the seeds in QQ15, so set up
                        \ a counter in X to cover three 16-bit seeds (i.e.
                        \ 6 bytes)

.TT53

 LDA QQ15,X             \ Copy byte X from QQ15 to QQ19
 STA QQ19,X

 DEX                    \ Decrement the loop counter

 BPL TT53               \ Loop back for the next byte to backup

 LDY #3                 \ Step 1: Now that the seeds are backed up, we can
                        \ start the name-generation process. We will either
                        \ need to loop three or four times, so for now set
                        \ up a counter in Y to loop four times

 BIT QQ15               \ Check bit 6 of w0_lo, which is stored in QQ15

 BVS P%+3               \ If bit 6 is set then skip over the next instruction

 DEY                    \ Bit 6 is clear, so we only want to loop three times,
                        \ so decrement the loop counter in Y

 STY T                  \ Store the loop counter in T

.TT55

 LDA QQ15+5             \ Step 2: Load w2_hi, which is stored in QQ15+5, and
 AND #%00011111         \ extract bits 0-4 by AND-ing with %11111

 BEQ P%+7               \ If all those bits are zero, then skip the following
                        \ 2 instructions to go to step 3

 ORA #%10000000         \ We now have a number in the range 1-31, which we can
                        \ easily convert into a two-letter token, but first we
                        \ need to add 128 (or set bit 7) to get a range of
                        \ 129-159

 JSR TT27               \ Print the two-letter token in A

 JSR TT54               \ Step 3: twist the seeds in QQ15

 DEC T                  \ Decrement the loop counter

 BPL TT55               \ Loop back for the next two letters

 LDX #5                 \ We have printed the system name, so we can now
                        \ restore the seeds we backed up earlier. Set up a
                        \ counter in X to cover three 16-bit seeds (i.e. 6
                        \ bytes)

.TT56

 LDA QQ19,X             \ Copy byte X from QQ19 to QQ15
 STA QQ15,X

 DEX                    \ Decrement the loop counter

 BPL TT56               \ Loop back for the next byte to restore

 RTS                    \ Once all the seeds are restored, return from the
                        \ subroutine
}

\ ******************************************************************************
\
\ Subroutine: cmn
\
\ Print control code 4 (the commander's name).
\
\ ******************************************************************************

.cmn
{
 LDY #0                 \ Set up a counter in Y, starting from 0

.QUL4

 LDA NA%,Y              \ The commander's name is stored at NA%, so load the
                        \ Y-th character from NA%

 CMP #13                \ If we have reached the end of the name, return from
 BEQ ypl-1              \ the subroutine (ypl-1 points to the RTS below)

 JSR TT26               \ Print the character we just loaded

 INY                    \ Increment the loop counter

 BNE QUL4               \ Loop back for the next character

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: ypl
\
\ Print control code 2 (the current system name).
\
\ ******************************************************************************

.ypl
{
 LDA MJ                 \ Check the mis-jump flag at MJ, and if it is non-zero
 BNE cmn-1              \ then return from the subroutine, as we are in
                        \ witchspace, and witchspace doesn't have a system name

 JSR TT62               \ Call TT62 below to swap the three 16-bit seeds in
                        \ QQ2 and QQ15 (before the swap, QQ2 contains the seeds
                        \ for the current system, while QQ15 contains the seeds
                        \ for the selected system)

 JSR cpl                \ Call cpl to print out the system name for the seeds
                        \ in QQ15 (which now contains the seeds for the current
                        \ system)

                        \ Now we fall through into the TT62 subroutine, which
                        \ will swap QQ2 and QQ15 once again, so everything goes
                        \ back into the right place, and the RTS at the end of
                        \ TT62 will return from the subroutine

.TT62

 LDX #5                 \ Set up a counter in X for the three 16-bit seeds we
                        \ want to swap (i.e. 6 bytes)

.TT78

 LDA QQ15,X             \ Swap byte X between QQ2 and QQ15
 LDY QQ2,X
 STA QQ2,X
 STY QQ15,X

 DEX                    \ Decrement the loop counter

 BPL TT78               \ Loop back for the next byte to swap

 RTS                    \ Once all bytes are swapped, return from the
                        \ subroutine
}

\ ******************************************************************************
\
\ Subroutine: tal
\
\ Print control code 1 (the current galaxy number, right-aligned to width 3).
\
\ ******************************************************************************

.tal
{
 CLC                    \ We don't want to print the galaxy number with a
                        \ decimal point, so clear the carry flag for pr2 to
                        \ take as an argument

 LDX GCNT               \ Load the current galaxy number from GCNT into X

 INX                    \ Add 1 to the galaxy number, as the galaxy numbers
                        \ are 0-7 internally, but we want to display them as
                        \ galaxy 1 through 8

 JMP pr2                \ Jump to pr2, which prints the number in X to a width
                        \ of 3 figures, left-padding with spaces to a width of
                        \ 3, and once done, return from the subroutine (as pr2
                        \ ends with an RTS)
}

\ ******************************************************************************
\
\ Subroutine: fwl
\
\ Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
\ control code 0).
\
\ ******************************************************************************

.fwl
{
 LDA #105               \ Print recursive token 105 ("FUEL") followed by a
 JSR TT68               \ colon

 LDX QQ14               \ Load the current fuel level from QQ14

 SEC                    \ We want to print the fuel level with a decimal point,
                        \ so set the carry flag for pr2 to take as an argument

 JSR pr2                \ Call pr2, which prints the number in X to a width of
                        \ 3 figures (i.e. in the format x.x, which will always
                        \ be exactly 3 characters as the maximum fuel is 7.0)

 LDA #195               \ Print recursive token 35 ("LIGHT YEARS") followed by
 JSR plf                \ a newline

.PCASH                  \ This label is not used but is in the original source

 LDA #119               \ Print recursive token 119 ("CASH:" then control code
 BNE TT27               \ 0, which prints cash levels, then " CR" and newline)
}

\ ******************************************************************************
\
\ Subroutine: csh
\
\ Print control code 0 (the current amount of cash, right-aligned to width 9,
\ followed by " CR" and a newline).
\
\ ******************************************************************************

.csh
{
 LDX #3                 \ We are going to use the BPRNT routine to print out
                        \ the current amount of cash, which is stored as a
                        \ 32-bit number at location CASH. BPRNT prints out
                        \ the 32-bit number stored in K, so before we call
                        \ BPRNT, we need to copy the four bytes from CASH into
                        \ K, so first we set up a counter in X for the 4 bytes

.pc1

 LDA CASH,X             \ Copy byte X from CASH to K
 STA K,X

 DEX                    \ Decrement the loop counter

 BPL pc1                \ Loop back for the next byte to copy

 LDA #9                 \ We want to print the cash using up to 9 digits
 STA U                  \ (including the decimal point), so store this in U
                        \ for BRPNT to take as an argument

 SEC                    \ We want to print the fuel level with a decimal point,
                        \ so set the carry flag for BRPNT to take as an
                        \ argument

 JSR BPRNT              \ Print the amount of cash to 9 digits with a decimal
                        \ point

 LDA #226               \ Print recursive token 66 (" CR") followed by a
                        \ newline by falling through into plf
}

\ ******************************************************************************
\
\ Subroutine: plf
\
\ Print a text token followed by a newline.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.plf
{
 JSR TT27               \ Print the text token in A

 JMP TT67               \ Jump to TT67 to print a newline and return from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: TT68
\
\ Print a text token followed by a colon.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.TT68
{
 JSR TT27               \ Print the text token in A and fall through into TT73
                        \ to print a colon
}

\ ******************************************************************************
\
\ Subroutine: TT73
\
\ Print a colon.
\
\ ******************************************************************************

.TT73
{
 LDA #':'               \ Set A to ASCII ":" and fall through into TT27 to
                        \ actually print the colon
}

\ ******************************************************************************
\
\ Subroutine: TT27
\
\ Print a text token (i.e. a character, control code, two-letter token or
\ recursive token). See variable QQ18 for a discussion of the token system
\ used in Elite.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.TT27
{
 TAX                    \ Copy the token number from A to X. We can then keep
                        \ decrementing X and testing it against zero, while
                        \ keeping the original token number intact in A; this
                        \ effectively implements a switch statement on the
                        \ value of the token

 BEQ csh                \ If token = 0, this is control code 0 (current amount
                        \ of cash and newline), so jump to csh

 BMI TT43               \ If token > 127, this is either a two-letter token
                        \ (128-159) or a recursive token (160-255), so jump
                        \ to .TT43 to process tokens

 DEX                    \ If token = 1, this is control code 1 (current
 BEQ tal                \ galaxy number), so jump to tal

 DEX                    \ If token = 2, this is control code 2 (current system
 BEQ ypl                \ name), so jump to ypl

 DEX                    \ If token > 3, skip the following instruction
 BNE P%+5

 JMP cpl                \ This token is control code 3 (selected system name)
                        \ so jump to cpl

 DEX                    \ If token = 4, this is control code 4 (commander
 BEQ cmn                \ name), so jump to cmm

 DEX                    \ If token = 5, this is control code 5 (fuel, newline,
 BEQ fwl                \ cash, newline), so jump to fwl

 DEX                    \ If token > 6, skip the following 3 instructions
 BNE P%+7

 LDA #128               \ This token is control code 6 (switch to sentence
 STA QQ17               \ case), so store 128 (bit 7 set, bit 6 clear) in QQ17,
 RTS                    \ which controls letter case, and return from the
                        \ subroutine as we are done

 DEX                    \ If token > 8, skip the following 2 instructions
 DEX
 BNE P%+5

 STX QQ17               \ This token is control code 8 (switch to ALL CAPS)
 RTS                    \ so store 0 in QQ17, which controls letter case, and
                        \ return from the subroutine as we are done

 DEX                    \ If token = 9, this is control code 9 (tab to column
 BEQ crlf               \ 21 and print a colon), so jump to crlf

 CMP #96                \ By this point, token is either 7, or in 10-127.
 BCS ex                 \ Check token number in A and if token >= 96, then the
                        \ token is in 96-127, which is a recursive token, so
                        \ jump to ex, which prints recursive tokens in this
                        \ range (i.e. where the recursive token number is
                        \ correct and doesn't need correcting)

 CMP #14                \ If token < 14, skip the following 2 instructions
 BCC P%+6

 CMP #32                \ If token < 32, then this means token is in 14-31, so
 BCC qw                 \ this is a recursive token that needs 114 adding to it
                        \ to get the recursive token number, so jump to qw
                        \ which will do this

                        \ By this point, token is either 7 (beep) or in 10-13
                        \ (line feeds and carriage returns), or in 32-95
                        \ (ASCII letters, numbers and punctuation)

 LDX QQ17               \ Fetch QQ17, which controls letter case, into X

 BEQ TT74               \ If QQ17 = 0, then ALL CAPS is set, so jump to TT27
                        \ to print this character as is (i.e. as a capital)

 BMI TT41               \ If QQ17 has bit 7 set, then we are using Sentence
                        \ Case, so jump to TT41, which will print the
                        \ character in upper or lower case, depending on
                        \ whether this is the first letter in a word

 BIT QQ17               \ If we get here, QQ17 is not 0 and bit 7 is clear, so
 BVS TT46               \ either it is bit 6 that is set, or some other flag in
                        \ QQ17 is set (bits 0-5). So check whether bit 6 is set.
                        \ If it is, then ALL CAPS has been set (as bit 7 is
                        \ clear) but bit 6 is still indicating that the next
                        \ character should be printed in lower case, so we need
                        \ to fix this. We do this with a jump to TT46, which
                        \ will print this character in upper case and clear bit
                        \ 6, so the flags are consistent with ALL CAPS going
                        \ forward

                        \ If we get here, some other flag is set in QQ17 (one
                        \ of bits 0-5 is set), which shouldn't happen in this
                        \ version of Elite. If this were the case, then we
                        \ would fall through into TT42 to print in lower case,
                        \ which is how printing all words in lower case could
                        \ be supported (by setting QQ17 to 1, say)
}

\ ******************************************************************************
\
\ Subroutine: TT42
\
\ Print a letter in lower case.
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\ Other entry points:
\
\   TT44                Jumps to TT26 to print the character in A (used to
\                       enable us to use a branch instruction to jump to TT26)
\
\ ******************************************************************************

.TT42
{
 CMP #'A'               \ If A < ASCII "A", then this is punctuation, so jump
 BCC TT44               \ to TT26 (via TT44) to print the character as is, as
                        \ we don't care about the character's case

 CMP #'Z' + 1           \ If A >= (ASCII "Z" + 1), then this is also
 BCS TT44               \ punctuation, so jump to TT26 (via TT44) to print the
                        \ character as is, as we don't care about the
                        \ character's case

 ADC #32                \ Add 32 to the character, to convert it from upper to
                        \ to lower case

.^TT44

 JMP TT26               \ Print the character in A
}

\ ******************************************************************************
\
\ Subroutine: TT41
\
\ Print a letter according to Sentence Case. The rules are as follows:
\
\   * If QQ17 bit 6 is set, print lower case (via TT45)
\
\   * If QQ17 bit 6 clear, then:
\
\       * If character is punctuation, just print it
\
\       * If character is a letter, set QQ17 bit 6 and print letter as a capital
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\   X                   Contains the current value of QQ17
\
\   QQ17                Bit 7 is set
\
\ ******************************************************************************

.TT41                   \ If we get here, then QQ17 has bit 7 set, so we are in
{
                        \ Sentence Case

 BIT QQ17               \ If QQ17 also has bit 6 set, jump to TT45 to print
 BVS TT45               \ this character in lower case

                        \ If we get here, then QQ17 has bit 6 clear and bit 7
                        \ set, so we are in Sentence Case and we need to print
                        \ the next letter in upper case

 CMP #'A'               \ If A < ASCII "A", then this is punctuation, so jump
 BCC TT74               \ to TT26 (via TT44) to print the character as is, as
                        \ we don't care about the character's case

 PHA                    \ Otherwise this is a letter, so store the token number

 TXA                    \ Set bit 6 in QQ17 (X contains the current QQ17)
 ORA #%1000000          \ so the next letter after this one is printed in lower
 STA QQ17               \ case

 PLA                    \ Restore the token number into A

 BNE TT44               \ Jump to TT26 (via TT44) to print the character in A
                        \ (this BNE is effectively a JMP as A will never be
                        \ zero)
}

\ ******************************************************************************
\
\ Subroutine: qw
\
\ Print a recursive token where the token number is in 128-145 (so the value
\ passed to TT27 is in the range 14-31).
\
\ Arguments:
\
\   A                   A value from 128-145, which refers to a recursive token
\                       in the range 14-31
\
\ ******************************************************************************

.qw
{
 ADC #114               \ This is a recursive token in the range 0-95, so add
 BNE ex                 \ 114 to the argument to get the token number 128-145
                        \ and jump to ex to print it
}

\ ******************************************************************************
\
\ Subroutine: crlf
\
\ Print control code 9 (tab to column 21 and print a colon). The subroutine
\ name is pretty misleading, as it doesn't have anything to do with carriage
\ returns or line feeds.
\
\ ******************************************************************************

.crlf
{
 LDA #21                \ Set the X-column in XC to 21
 STA XC

 BNE TT73               \ Jump to TT73, which prints a colon (this BNE is
                        \ effectively a JMP as A will never be zero)
}

\ ******************************************************************************
\
\ Subroutine: TT45
\
\ Print a letter in lower case. Specifically:
\
\   * If QQ17 = &FF, abort printing this character
\
\   * If a letter then print in lower case
\
\   * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\   X                   Contains the current value of QQ17
\
\   QQ17                Bits 6 and 7 are set
\
\ ******************************************************************************

.TT45                   \ If we get here, then QQ17 has bit 6 and 7 set, so we
{
                        \ are in Sentence Case and we need to print the next
                        \ letter in lower case

 CPX #&FF               \ If QQ17 = #&FF then return from the subroutine (as
 BEQ TT48               \ TT48 contains an RTS)

 CMP #'A'               \ If A >= ASCII "A", then jump to TT42, which will
 BCS TT42               \ print the letter in lowercase

                        \ Otherwise this is not a letter, it's punctuation, so
                        \ this is effectively a word break. We therefore fall
                        \ through to TT46 to print the character and set QQ17
                        \ to ensure the next word starts with a capital letter
}

\ ******************************************************************************
\
\ Subroutine: TT46
\
\ Print character and clear bit 6 in QQ17, so that the next letter that gets
\ printed after this will start with a capital letter.
\
\ Arguments:
\
\   A                   The character to be printed. Can be one of the
\                       following:
\
\                         * 7 (beep)
\
\                         * 10-13 (line feeds and carriage returns)
\
\                         * 32-95 (ASCII capital letters, numbers and
\                           punctuation)
\
\   X                   Contains the current value of QQ17
\
\   QQ17                Bits 6 and 7 are set
\
\ ******************************************************************************

.TT46
{
 PHA                    \ Store the token number

 TXA                    \ Clear bit 6 in QQ17 (X contains the current QQ17)
 AND #191               \ so the next letter after this one is printed in upper
 STA QQ17               \ case

 PLA                    \ Restore the token number into A

                        \ Now fall through into TT74 to print the character
}

\ ******************************************************************************
\
\ Subroutine: TT74
\
\ Print a character.
\
\ Arguments:
\
\   A                   The character to be printed
\
\ ******************************************************************************

.TT74
{
 JMP TT26               \ Print the character in A
}

\ ******************************************************************************
\
\ Subroutine: TT43
\
\ Print a two-letter token, or a recursive token where the token number is in
\ 0-95 (so the value passed to TT27 is in the range 160-255).
\
\ Arguments:
\
\   A                   One of the following:
\
\                         * 128-159 (two-letter token)
\
\                         * 160-255 (the argument to TT27 that refers to a
\                           recursive token in the range 0-95)
\
\ ******************************************************************************

.TT43
{
 CMP #160               \ If token >= 160, then this is a recursive token, so
 BCS TT47               \ jump to TT47 below to process it

 AND #127               \ This is a two-letter token with number 128-159. The
 ASL A                  \ set of two-letter tokens is stored in a lookup table
                        \ at QQ16, with each token taking up two bytes, so to
                        \ convert this into the token's position in the table,
                        \ we subtract 128 (or just clear bit 7) and multiply
                        \ by 2 (or shift left)

 TAY                    \ Transfer the token's position into Y so we can look
                        \ up the token using absolute indexed mode

 LDA QQ16,Y             \ Get the first letter of the token and print it
 JSR TT27

 LDA QQ16+1,Y           \ Get the second letter of the token

 CMP #'?'               \ If the second letter of the token is a question mark
 BEQ TT48               \ then this is a one-letter token, so just return from
                        \ the subroutine without printing (as TT48 contains an
                        \ RTS)

 JMP TT27               \ Print the second letter and return from the
                        \ subroutine

.TT47

 SBC #160               \ This is a recursive token in the range 160-255, so
                        \ subtract 160 from the argument to get the token
                        \ number 0-95 and fall through into ex to print it
}

\ ******************************************************************************
\
\ Subroutine: ex
\
\ Print a recursive token.
\
\ This routine works its way through the recursive tokens that are stored in
\ tokenised form in memory at &0400 - &06FF, and when it finds token number A,
\ it prints it. Tokens are null-terminated in memory and fill three pages,
\ but there is no lookup table as that would consume too much memory, so the
\ only way to find the correct token is to start at the beginning and look
\ through the table byte by byte, counting tokens as we go until we are in the
\ right place. This approach might not be terribly speed efficient, but it is
\ certainly memory-efficient.
\
\ For details of the tokenisation system, see variable QQ18.
\
\ Arguments:
\
\   A                   The recursive token to be printed, in the range 0-148
\
\ Other entry points:
\
\   TT148               Contains an RTS
\
\ ******************************************************************************

.ex
{
 TAX                    \ Copy the token number into X

 LDA #LO(QQ18)          \ Set V, V+1 to point to the recursive token table at
 STA V                  \ location QQ18
 LDA #HI(QQ18)
 STA V+1

 LDY #0                 \ Set a counter Y to point to the character offset
                        \ as we scan through the table

 TXA                    \ Copy the token number back into A, so both A and X
                        \ now contain the token number we want to print

 BEQ TT50               \ If the token number we want is 0, then we have
                        \ already found the token we are looking for, so jump
                        \ to TT50, otherwise start working our way through the
                        \ null-terminated token table until we find the X-th
                        \ token

.TT51

 LDA (V),Y              \ Fetch the Y-th character from the token table page
                        \ we are currently scanning

 BEQ TT49               \ If the character is null, we've reached the end of
                        \ this token, so jump to TT49

 INY                    \ Increment character pointer and loop back round for
 BNE TT51               \ the next character in this token, assuming Y hasn't
                        \ yet wrapped around to 0

 INC V+1                \ If it has wrapped round to 0, we have just crossed
 BNE TT51               \ into a new page, so increment V+1 so that V points
                        \ to the start of the new page

.TT49

 INY                    \ Increment the character pointer

 BNE TT59               \ If Y hasn't just wrapped around to 0, skip the next
                        \ instruction

 INC V+1                \ We have just crossed into a new page, so increment
                        \ V+1 so that V points to the start of the new page

.TT59

 DEX                    \ We have just reached a new token, so decrement the
                        \ token number we are looking for

 BNE TT51               \ Assuming we haven't yet reached the token number in
                        \ X, look back up to keep fetching characters

.TT50                   \ We have now reached the correct token in the token
                        \ table, with Y pointing to the start of the token as
                        \ an offset within the page pointed to by V, so let's
                        \ print the recursive token. Because recursive tokens
                        \ can contain other recursive tokens, we need to store
                        \ our current state on the stack, so we can retrieve
                        \ it after printing each character in this token

 TYA                    \ Store the offset in Y on the stack
 PHA

 LDA V+1                \ Store the high byte of V (the page containing the
 PHA                    \ token we have found) on the stack, so the stack now
                        \ contains the address of the start of this token

 LDA (V),Y              \ Load the character at offset Y in the token table,
                        \ which is the next character of this token that we
                        \ want to print

 EOR #35                \ Tokens are stored in memory having been EOR'd with 35
                        \ (see variable QQ18 for details), so we repeat the
                        \ EOR to get the actual character to print

 JSR TT27               \ Print the text token in A, which could be a letter,
                        \ number, control code, two-letter token or another
                        \ recursive token

 PLA                    \ Restore the high byte of V (the page containing the
 STA V+1                \ token we have found) into V+1

 PLA                    \ Restore the offset into Y
 TAY

 INY                    \ Increment Y to point to the next character in the
                        \ token we are printing

 BNE P%+4               \ If Y is zero then we have just crossed into a new
 INC V+1                \ page, so increment V+1 so that V points to the start
                        \ of the new page

 LDA (V),Y              \ Load the next character we want to print into A

 BNE TT50               \ If this is not the null character at the end of the
                        \ token, jump back up to TT50 to print the next
                        \ character, otherwise we are done printing

.^TT48

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: EX2
\
\ ready to remove - Explosion Code
\
\ ******************************************************************************

.EX2                    \ ready to remove - Explosion Code
{
 LDA INWK+31            \ exploding/display state|missiles
 ORA #&A0               \ bit7 to kill it, bit5 finished exploding
 STA INWK+31
 RTS
}

\ ******************************************************************************
\
\ Subroutine: DOEXP
\
\ Do Explosion as bit5 set by LL9
\
\ ******************************************************************************

.DOEXP                  \ Do Explosion as bit5 set by LL9
{
 LDA INWK+31
 AND #64                \ display state keep bit6
 BEQ P%+5               \ exploding not started, skip ptcls
 JSR PTCLS              \ else exploding has started, remove old plot Cloud
 LDA INWK+6             \ zlo. All do a round of cloud counter
 STA T
 LDA INWK+7
 CMP #&20               \ zhi < 32,  boost*8
 BCC P%+6               \ skip default
 LDA #&FE               \ furthest cloud distance
 BNE yy                 \ guaranteed Cloud
 ASL T                  \ else use zlo
 ROL A                  \ *=2
 ASL T
 ROL A                  \ z lo.hi*=4
 SEC                    \ ensure cloud distance not 0
 ROL A

.yy                     \ Cloud

 STA Q                  \ cloud distance
 LDY #1                 \ get ship heap byte1, which started at #18
 LDA (XX19),Y
 ADC #4                 \ +=4 Cloud counter
 BCS EX2                \ until overflow and ready to removed, up

 STA (XX19),Y           \ else update Cloud counter
 JSR DVID4              \ P.R = cloud counter/cloud distance
 LDA P
 CMP #&1C               \ hi < #28 ?
 BCC P%+6               \ cloud radius < 28 skip max
 LDA #&FE               \ else max radius
 BNE LABEL_1            \ guaranteed  Acc = Cloud radius
 ASL R
 ROL A                  \ *=2
 ASL R
 ROL A                  \ *=4
 ASL R
 ROL A                  \ *=8

.LABEL_1                \ Acc = Cloud radius

 DEY                    \ Y = 0, save ship heap byte0 = Cloud radius
 STA (XX19),Y
 LDA INWK+31            \ display explosion state|missiles
 AND #&BF               \ clear bit6 in case can't start
 STA INWK+31
 AND #8                 \ keep bit3 of display state, something to erase?
 BEQ TT48               \ rts, up

 LDY #2                 \ else ship heap byte2 = hull byte#7 dust
 LDA (XX19),Y
 TAY                    \ Y counter multiples of 4, greater than 6

.EXL1                   \ counter Y

 LDA XX3-7,Y            \ from (all visible) vertex heap
 STA (XX19),Y           \ to ship heap
 DEY                    \ next vertex
 CPY #6                 \ until down to 7
 BNE EXL1               \ loop Y
 LDA INWK+31
 ORA #64                \ set bit6 so this dust will be erased
 STA INWK+31

.PTCLS                  \ plot Cloud

 LDY #0                 \ ship heap byte0 = Cloud radius
 LDA (XX19),Y
 STA Q                  \ Cloud radius
 INY                    \ ship byte1 = Cloud counter
 LDA (XX19),Y
 BPL P%+4               \ Cloud counter not half way, skip flip
 EOR #&FF               \ else more than half way through cloud counter
 LSR A
 LSR A
 LSR A                  \ cloud counter/8 max = 15 pixels
                        \ pixel count set
 ORA #1                 \ 1 min
 STA U                  \ number of pixels per vertex
 INY                    \ ship byte2 = dust = counter target
 LDA (XX19),Y
 STA TGT                \ = hull byte#7 dust = counter target
 LDA RAND+1
 PHA                    \ restrict random

 LDY #6                 \ ship heap index at vertex-1

.EXL5                   \ counter Y=CNT Outer loop +=4 for each vertex on ship heap

 LDX #3

.EXL3                   \ counter X, K3 loaded with reversed vertex from heap

 INY                    \ Y++ = 7 start is a vertex on ship heap
 LDA (XX19),Y
 STA K3,X               \ Yorg hi,lo, Xorg hi,lo
 DEX                    \ next coord
 BPL EXL3               \ loop X
 STY CNT                \ store index for vertex on ship heap
 LDY #2

.EXL2                   \ inner counter Y to set rnd for each vertex

 INY                    \ Y++ = 3 start, the 4 randoms on ship heap
 LDA (XX19),Y
 EOR CNT                \ rnd seeded for each vertex CNT
 STA &FFFD,Y            \ using bytes 3,4,5,6
 CPY #6                 \ 6 is last one
 BNE EXL2               \ loop next inner Y rnd seed
 LDY U                  \ number of pixels per vertex

.EXL4                   \ counter Y for pixels at each (reversed) vertex in K3

 JSR DORND2             \ leave bit0 of RAND+2 at 0
 STA ZZ                 \ restricted pixel depth
 LDA K3+1               \ Yorg lo
 STA R
 LDA K3                 \ Yorg hi
 JSR EXS1               \ Xlo.Ahi = Ylo+/-rnd*Cloud radius
 BNE EX11               \ Ahi too big, skip but new rnd
 CPX #2*Y-1             \ #2*Y-1 = Y screen range
 BCS EX11               \ too big, skip but new rnd
 STX Y1                 \ Y coord
 LDA K3+3               \ Xorg lo
 STA R
 LDA K3+2               \ Xorg hi
 JSR EXS1               \ Xlo.Ahi = Xlo+/-rnd*Cloud radius
 BNE EX4                \ skip pixel
 LDA Y1                 \ reload Y coord
 JSR PIXEL              \ at (X,Y1) ZZ away

.EX4                    \ skipped pixel

 DEY                    \ loop Y
 BPL EXL4               \ next pixel at vertex
 LDY CNT                \ reload index for vertex on ship heap
 CPY TGT                \ counter target
 BCC EXL5               \ Outer loop, next vertex on ship heap

 PLA                    \ restore random
 STA RAND+1
 LDA K%+6               \ planet zlo seed
 STA RAND+3
 RTS

.EX11                   \ skipped pixel as Y too big, but new rnd

 JSR DORND2             \ new restricted rnd
 JMP EX4                \ skipped pixel, up

.EXS1                   \ Xlo.Ahi = Rlo.Ahi+/-rnd*Q

 STA S                  \ store origin hi
 JSR DORND2             \ restricted rnd, carry
 ROL A                  \ rnd hi
 BCS EX5                \ negative
 JSR FMLTU              \ Xlo = Arnd*Q=Cloud radius/256
 ADC R
 TAX                    \ Xlo = R+Arnd*Cloud radius/256
 LDA S
 ADC #0                 \ Ahi = S
 RTS

.EX5                    \ rnd hi negative

 JSR FMLTU              \ A=A*Q/256unsg
 STA T
 LDA R
 SBC T                  \ Arnd*Q=Cloud radius/256
 TAX                    \ Xlo = Rlo-T
 LDA S
 SBC #0                 \ Ahi = S
 RTS                    \ end of explosion code
}

\ ******************************************************************************
\
\ Subroutine: SOS1
\
\ Update the missile indicators, and set up a data block for the planet, but
\ only setting the roll and pitch counters to 127 (no damping).
\
\ ******************************************************************************

.SOS1
{
 JSR msblob             \ Update the dashboard's missile indicators to all be
                        \ green/cyan

 LDA #127               \ Set the roll and pitch counters to 127 (no damping
 STA INWK+29            \ so the planet's rotation doesn't slow down)
 STA INWK+30

 LDA tek                \ Set A = 128 or 130 depending on bit 1 of the system's
 AND #%00000010         \ tech level in tek
 ORA #%10000000

 JMP NWSHP              \ Add a new planet to our little bubble of universe,
                        \ with the planet type defined by A (128 is a planet
                        \ with an equator and meridian, 130 is a planet with
                        \ a crater)
}

\ ******************************************************************************
\
\ Subroutine: SOLAR
\
\ Halve our legal status, update the missile indicators, and set up data blocks
\ and slots for the planet and sun.
\
\ ******************************************************************************

.SOLAR
{
 LSR FIST               \ Halve our legal status in FIST, making us less bad
                        \ moving bit 0 into the C flag (so every time we arrive
                        \ in a new system, our legal status improves a bit)

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace, which
                        \ doesn't affect the C flag

 LDA QQ15+1             \ Fetch w0_hi, extract bits 0-2 (which also happen to
 AND #%00000111         \ determine the economy), add 6 + C, divide by 2, and
 ADC #6                 \ store the result - which will be between 3 and 7 - in
 LSR A                  \ z_sign in INWK+6
 STA INWK+8

 ROR A                  \ Halve A, rotating in the C flag, which was previously
 STA INWK+2             \ bit 0 of w0_hi + 6 + C, so when this is stored in both
 STA INWK+5             \ x_sign and y_sign, it moves the planet to the upper
                        \ right or lower left

 JSR SOS1               \ Call SOS1 to set up the planet's data block and add it
                        \ to FRIN, where it will get put in the first slot as
                        \ it's the first one to be added to our little bubble of
                        \ this new system's universe

 LDA QQ15+3             \ Fetch w1_hi, extract bits 0-2, set bits 0 and 7 and
 AND #%00000111         \ store in z_sign, so the sun is behind us at a distance
 ORA #%10000001         \ of 1 to 7
 STA INWK+8

 LDA QQ15+5             \ Fetch w2_hi, extract bits 0-1 and store in x_sign and
 AND #%00000011         \ y_sign, so the sun is either dead in our rear laser
 STA INWK+2             \ crosshairs, or off to the top left by a distance of 1
 STA INWK+1             \ or 2 when we look out the back

 LDA #0                 \ Set the roll and pitch counters to 0 (no rotation)
 STA INWK+29
 STA INWK+30

 LDA #129               \ Set A = 129, the "ship" type for the sun

 JSR NWSHP              \ Call NWSHP to set up the sun's data block and add it
                        \ to FRIN, where it will get put in the second slot as
                        \ it's the second one to be added to our little bubble
                        \ of this new system's universe
}

\ ******************************************************************************
\
\ Subroutine: NWSTARS
\
\ New dust field
\
\ ******************************************************************************

.NWSTARS                \ New dust field
{
 LDA QQ11               \ menu i.d. QQ11 == 0 is space view
\ORA MJ
 BNE WPSHPS             \ if not space view skip over to Wipe Ships
}

\ ******************************************************************************
\
\ Subroutine: nWq
\
\ Create a cloud of stardust containing the maximum number of dust particles
\ (i.e. NOSTM of them).
\
\ ******************************************************************************

.nWq
{
 LDY NOSTM              \ number of dust particles

.SAL4                   \ counter Y

 JSR DORND              \ Set A and X to random numbers
 ORA #8                 \ flick out in z
 STA SZ,Y               \ dustz
 STA ZZ                 \ distance
 JSR DORND              \ Set A and X to random numbers
 STA SX,Y               \ dustx
 STA X1
 JSR DORND              \ Set A and X to random numbers
 STA SY,Y               \ dusty
 STA Y1
 JSR PIXEL2             \ dust (X1,Y1) from middle
 DEY                    \ next dust
 BNE SAL4               \ loop Y
}

\ ******************************************************************************
\
\ Subroutine: WPSHPS
\
\ Remove all ships from the scanner and reset the LSO block and variables.
\
\ ******************************************************************************

.WPSHPS
{
 LDX #0                 \ Set up a counter in X to work our way through all the
                        \ ship slots in FRIN

.WSL1

 LDA FRIN,X             \ Fetch the ship type in slot X

 BEQ WS2                \ If the slot contains 0 then it is empty and we have
                        \ checked all ths slots (as they are always shuffled
                        \ down in the main loop to close up and gaps), so jump
                        \ to WS2 as we are done

 BMI WS1                \ If the slot contains a ship type with bit 7 set, then
                        \ it contains the planet or the sun, so jump down to WS1
                        \ to skip this slot, as the planet and sun don't appear
                        \ on the scanner

 STA TYPE               \ Store the ship type in TYPE

 JSR GINF               \ Call GINF to get the address of the data block for
                        \ ship slot X and store it in INF

 LDY #31                \ We now want to copy the first 32 bytes from the ship's
                        \ data block into INWK, so set a counter in Y

.WSL2

 LDA (INF),Y            \ Copy the Y-th byte from the data block pointed to by
 STA INWK,Y             \ INF into the Y-th byte of INWK workspace

 DEY                    \ Decrement the counter to point at the next byte

 BPL WSL2               \ Loop back to WSL2 until we have copied all 32 bytes

 STX XSAV               \ Store the ship slot number in XSAV while we call SCAN

 JSR SCAN               \ Call SCAN to plot this ship on the scanner, which will
                        \ remove it as it's plotted with EOR logic

 LDX XSAV               \ Restore the ship slot number from XSAV into X

 LDY #31                \ Clear bits 3, 4 and 6 in the ship's byte #31, which
 LDA (INF),Y            \ stops drawing the explosion cloud (bit 3), hides it
 AND #%10100111         \ from the scanner (bit 4) and stops any lasers firing
 STA (INF),Y            \ at it (bit 6)

.WS1

 INX                    \ Increment X to point to the next ship slot

 BNE WSL1               \ Loop back up to process the next slot (this BNE is
                        \ effectively a JMP as X will never be zero)

.WS2

 LDX #&FF               \ Set LSX2 = LSY2 = &FF to clear the line buffers
 STX LSX2
 STX LSY2

                        \ Fall through into FLFLLS to reset the LSO block
}

\ ******************************************************************************
\
\ Subroutine: FLFLLS
\
\ Reset the LSO block by zero-filling it and setting LSO to &FF.
\
\ Returns:
\
\   A                   Set to 0
\
\ ******************************************************************************

.FLFLLS
{
 LDY #2*Y-1             \ #Y is the y-coordinate of the centre of the mode 4
                        \ space view, so this sets Y as a counter for the number
                        \ of lines in the space view (i.e. 191), which is also
                        \ the number of lines in the LSO block

 LDA #0                 \ Set A to 0 so we can zero-fill the LSO block

.SAL6

 STA LSO,Y              \ Set the Y-th byte of the LSO block to 0

 DEY                    \ Decrement the counter

 BNE SAL6               \ Loop back until we have filled all the way to LSO+1

 DEY                    \ Decrement Y to value of &FF (as we exit the above loop
                        \ with Y = 0)

 STY LSX                \ Set the first byte of the LSO block, which shares its
                        \ location with LSX, to &FF (this could also be written
                        \ STY LSO, which would be clearer, but for some reason
                        \ it isn't)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DET1
\
\ Set the screen to show the number of text rows given in X. This is used when
\ we are killed, as reducing the number of rows from the usual 31 to 24 has the
\ effect of hiding the dashboard, leaving a monochrome image of ship debris and
\ explosion clouds. Increasing the rows back up to 31 makes the dashboard
\ reappear, as the dashboard's screen memory doesn't get touched by this
\ process.
\
\ Arguments:
\
\   X                   The number of text rows to display on screen (24 will
\                       hide the dashboard, 31 will make it reappear)
\
\ Returns
\
\   A                   A is set to 6
\
\ ******************************************************************************

.DET1
{
 LDA #6                 \ Set A to 6 so we can update 6845 register R6 below

 SEI                    \ Disable interrupts so we can update the 6845

 STA SHEILA+&00         \ Set 6845 register R6 to the value in X. Register R6
 STX SHEILA+&01         \ is the "vertical displayed" register, which sets the
                        \ number of rows shown on screen

 CLI                    \ Re-enable interrupts

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: SHD
\
\ Charge up a shield, and if it needs charging, drain some energy from the
\ energy banks.
\
\ Arguments:
\
\   X                   The value of the shield to recharge
\
\ ******************************************************************************

{
 DEX                    \ Increment the shield value so that it doesn't go past
                        \ a maximum of 255

 RTS                    \ Return from the subroutine

.^SHD

 INX                    \ Increment the shield value

 BEQ SHD-2              \ If the shield value is 0 then this means it was 255
                        \ before, which is the maximum value, so jump to SHD-2
                        \ to bring it back down to 258 and return

                        \ Otherwise fall through into DENGY to drain our energy
                        \ to pay for all this shield charging
}

\ ******************************************************************************
\
\ Subroutine: DENGY
\
\ Drain some energy from the energy banks.
\
\ Returns:
\
\   Z flag              Set if we have no energy left, clear otherwise
\
\ ******************************************************************************

.DENGY
{
 DEC ENERGY             \ Decrement the energy banks in ENERGY

 PHP                    \ Save the flags on the stack

 BNE P%+5               \ If the energy levels are not yet zero, skip the
                        \ following instruction

 INC ENERGY             \ The minimum allowed energy level is 1, amd we just
                        \ reached 0, so increment ENERGY back to 1

 PLP                    \ Restore the flags from the stack, so we return with
                        \ the zero flag from the DEC instruction above

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: COMPAS
\
\ Update the compass.
\
\ ******************************************************************************

.COMPAS
{
 JSR DOT                \ Call DOT to redraw (i.e. remove) the current compass
                        \ dot

 LDA SSPR               \ If we are inside the space station safe zone, jump to
 BNE SP1                \ SP1 to draw the space station on the compass

 JSR SPS1               \ Otherwise we need to draw the planet on the compass,
                        \ so first call SPS1 to calculate the vector to the
                        \ planet and store it in XX15

 JMP SP2                \ Jump to SP2 to draw XX15 on the compass, returning
                        \ from the subroutine with a tail call
}

\ ******************************************************************************
\
\ Subroutine: SPS2
\
\ Calculate the following, where A is a signed 8-bit integer and the result is a
\ signed 16-bit integer:
\
\   (Y X) = A / 10
\
\ Returns:
\
\   C flag              The C flag is cleared
\
\ ******************************************************************************

.SPS2
{
 ASL A                  \ Set X = |A| * 2, and set the C flag to the sign bit of
 TAX                    \ A

 LDA #0                 \ Set Y to have the sign bit from A in bit 7, with the
 ROR A                  \ rest of its bits zeroed, so Y now contains the sign of
 TAY                    \ the original argument

 LDA #20                \ Set Q = 20
 STA Q

 TXA                    \ Copy X into A, so A now contains the argument A * 2

 JSR DVID4              \ Calculate the following:
                        \
                        \ (R P) = A / Q
                        \       = |argument A| * 2 / 20
                        \       = |argument A| / 10

 LDX P                  \ Set X to P, the low byte of the result

 TYA                    \ If the sign of the original argument A is negative,
 BMI LL163              \ jump to LL163 to flip the sign of the result

 LDY #0                 \ Set the high byte of the result to 0, as the result is
                        \ positive

 RTS                    \ Return from the subroutine

.LL163

 LDY #&FF               \ The result is negative, so set the high byte to &FF

 TXA                    \ Flip the the low byte and add 1 to get the negated
 EOR #&FF               \ low byte, using two's complement
 TAX
 INX

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: SPS4
\
\ Calculate the vector to the space station and store it in XX15.
\
\ ******************************************************************************

.SPS4
{
 LDX #8                 \ First we need to copy the space station's coordinates
                        \ into K3, so set a counter to copy the first 9 bytes
                        \ (the 3-byte x, y and z coordinates) from the station's
                        \ data block at K% + NI% into K3

.SPL1

 LDA K%+NI%,X           \ Copy the X-th byte from the station's data block at
 STA K3,X               \ K% + NI% to the X-th byte of K3

 DEX                    \ Decrement the loop countr

 BPL SPL1               \ Loop back to SPL1 until we have copied all 9 bytes

 JMP TAS2               \ Call TAS2 to build XX15 from K3, returning from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: SP1
\
\ Draw the space station on the compass.
\
\ ******************************************************************************

.SP1
{
 JSR SPS4               \ Call SPS4 to calculate the vector to the space station
                        \ and store it in XX15

                        \ Fall through into SP2 to draw XX15 on the compass
}

\ ******************************************************************************
\
\ Subroutine: SP2
\
\ Draw a dot on the compass to represent the planet or station, whose normalised
\ vector is in XX15.
\
\   XX15 to XX15+2      The normalised vector to the planet or space station,
\                       stored as x in XX15, y in XX15+1 and z in XX15+2
\
\ ******************************************************************************

.SP2
{
 LDA XX15               \ Set A to the x-coordinate of the planet or station to
                        \ show on the compass, which will be in the range -96 to
                        \ +96 as the vector has been normalised

 JSR SPS2               \ Set (Y X) = A / 10, so X will be from -9 to +9, which
                        \ is the x-offset from the centre of the compass of the
                        \ dot we want to draw. Returns with the C flag clear

 TXA                    \ Set COMX = 195 + X, as 186 is the pixel x-coordinate
 ADC #195               \ of the leftmost dot possible on the compass, and X can
 STA COMX               \ be -9, which would be 195 - 9 = 186. This also means
                        \ that the highest value for COMX is 195 + 9 = 204,
                        \ which is the pixel x-coordinate of the rightmost dot
                        \ in the compass... but the compass dot is actually two
                        \ pixels wide, so the compass dot can overlap the right
                        \ edge of the compass, but not the left edge

 LDA XX15+1             \ Set A to the y-coordinate of the planet or station to
                        \ show on the compass, which will be in the range -96 to
                        \ +96 as the vector has been normalised

 JSR SPS2               \ Set (Y X) = A / 10, so X will be from -9 to +9, which
                        \ is the y-offset from the centre of the compass of the
                        \ dot we want to draw. Returns with the C flag clear

 STX T                  \ Set COMY = 204 - X, as 203 is the pixel y-coordinate
 LDA #204               \ of the centre of the compass, the C flag is clear,
 SBC T                  \ and the y-axis needs to be flipped around (because
 STA COMY               \ when the planet or station is above us, and the
                        \ vector is therefore positive, we want to show the dot
                        \ higher up on the compass, which has a smaller pixel
                        \ y-coordinate). So this calculation does this:
                        \
                        \ COMY = 204 - X - (1 - 0) = 203 - X

 LDA #&F0               \ Set A to a 4-pixel mode 5 byte row in colour 2
                        \ (yellow/white), the colour for when the planet or
                        \ station in the compass is in front of us

 LDX XX15+2             \ If the z-coordinate of the XX15 vector is positive,
 BPL P%+4               \ skip the following instruction

 LDA #&FF               \ The z-coordinate of XX15 is negative, so the planet or
                        \ station is behind us and the compass dot should be in
                        \ green/cyan, so set A to a 4-pixel mode 5 byte row in
                        \ colour 3

 STA COMC               \ Store the compass colour in COMC

                        \ Fall through into DOT to draw the dot on the compass
}

\ ******************************************************************************
\
\ Subroutine: DOT
\
\ Draw a dot on the compass.
\
\ Arguments:
\
\   COMX                The screen pixel x-coordinate of the dot
\
\   COMY                The screen pixel y-coordinate of the dot
\
\   COMC                The colour and thickness of the dot:
\
\                         * &F0 = a double-height dot in yellow/white, for when
\                           the object in the compass is in front of us
\
\                         * &FF = a single-height dot in green/cyan, for when
\                           the object in the compass is behind us
\
\ ******************************************************************************

.DOT
{
 LDA COMY               \ Set Y1 = COMY, the y-coordinate of the dot
 STA Y1

 LDA COMX               \ Set X1 = COMX, the x-coordinate of the dot
 STA X1
 
 LDA COMC               \ Set COL = COMC, the mode 5 colour byte for the dot
 STA COL

 CMP #&F0               \ If COL is &F0 then the dot is in front of us and we
 BNE CPIX2              \ want to draw a double-height dot, so if it isn't &F0
                        \ jump to CPIX2 to draw a single-height dot

                        \ Otherwise fall through into CPIX4 to draw a double-
                        \ height dot
}

\ ******************************************************************************
\
\ Subroutine: CPIX4
\
\ Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
\
\ Arguments:
\
\   X1                  The screen pixel x-coordinate of the bottom-left corner
\                       of the dot
\
\   Y1                  The screen pixel y-coordinate of the bottom-left corner
\                       of the dot
\
\   COL                 The colour of the dot as a mode 5 character row byte
\
\ ******************************************************************************

.CPIX4
{
 JSR CPIX2              \ Call CPIX2 to draw a single-height dash at (X1, Y1)

 DEC Y1                 \ Decrement Y1

                        \ Fall through into CPIX2 to draw a second single-height
                        \ dash on the pixel row above the first one, to create a
                        \ double-height dot
}

\ ******************************************************************************
\
\ Subroutine: CPIX2
\
\ Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
\
\ Arguments:
\
\   X1                  The screen pixel x-coordinate of the dash
\
\   Y1                  The screen pixel y-coordinate of the dash
\
\   COL                 The colour of the dash as a mode 5 character row byte
\
\ ******************************************************************************
\
\ Deep dive: Drawing colour pixels in mode 5
\ ------------------------------------------
\ Drawing pixels in the four-colour mode 5 screen that Elite uses for the
\ dashboard is not as straightforward as you might think. It's slightly simpler
\ in the two-colour mode 4 screen that Elite uses for the space view, and I
\ highly recommend you first read the documentation in the PIXEL routine, where
\ we discuss screen addresses and plotting techniques for this simpler mode.
\ 
\ As with mode 4, the mode 5 screen is laid out in memory using character
\ blocks. Indeed, the character blocks are the same size and height in terms of
\ bits and bytes, and pixel coordinates are identical in both screen modes (both
\ screen modes are 256 coordinates wide), so as far as the end used is
\ concerned, the screen modes are really similar. At the screen memory level,
\ however, there are some key differences.
\ 
\ The main difference is that each pixel can be one of four colours rather than
\ two, so as a result each pixel takes up twice as much memory (2 bits as
\ opposed to 1 bit). If we look at the way character blocks are laid out in
\ terms of bits, it looks the same as for mode 4 - here's what two neighbouring
\ character blocks look like in both modes:
\ 
\   01234567 01234567
\   01234567 01234567
\   01234567 01234567
\   01234567 01234567
\   01234567 01234567
\   01234567 01234567
\   01234567 01234567
\   01234567 01234567
\ 
\ However, while in mode 4 each bit represents one pixel, so the above block
\ would be 16 pixels across and 8 pixels high, in mode 5 each pixel takes up two
\ bits, so the above block shows as 8 pixels across and 8 pixels high. Pixels in
\ mode 5 are stretched out so they appear twice as wide as they are high, so
\ everything still fits on screen in a sensible manner.
\ 
\ So we know that a character block row in mode 5 consists of four pixels in one
\ byte. The complicated part is how that byte stores those four pixels. If we
\ consider a character row byte like this:
\ 
\   01234567
\ 
\ then the first pixel is defined by bits 0 and 4, the second by bits 1 and 5,
\ and so on. If we split it up into nibbles:
\ 
\   0123 4567
\ 
\ then the first pixel is defined by the first bits of each nibble (0 and 4),
\ the second is defined by the second bits of each nibble (1 and 5), and so on
\ with bits 2 and 6, and bits 3 and 7. So consider this character row byte:
\ 
\   1111 0000
\ 
\ Each of the four bits has a 1 as the first bit and a 0 as the second bit,
\ giving %10, or 2, so this defines four pixels in a row of colour 2. And this
\ one:
\ 
\  1010 0011
\ 
\ contains the following pixels: %10, %00, %11 and %01, so this is a four-pixel
\ row consisting of pixel colours 2, 0, 3 and 1.
\ 
\ That aside, modes 4 and 5 work in the same way. Each character row takes up
\ 256 bytes, or exactly one page, so we can convert from screen coordinates to
\ character blocks using the same code. We can even work out the correct row in
\ the relevant character block in the same way, as the screen x- and
\ y-coordinate systems are identical. The only differences are:
\ 
\   * How we manipulate the individual character row bytes to support the nibble
\     system for four colours
\ 
\   * The fact that the y-coordinate still ranges from 0 to 256, but this time
\     there are only 128 pixels across the screen, so each pixel effectively has
\     two different screen coordinates (though we can easily cater for this by
\     ignoring the last bit of the y-coordinate)
\ 
\ We can even use a similar system to the TWOS table that we use in PIXEL, but
\ this time it's set up for the nibble system above. As a reminder, the TWOS
\ table provides ready-made bytes for plotting single pixels, such as this one
\ for plotting the third pixel in the row (out of 8):
\ 
\   TWOS+2  = %00100000
\ 
\ We can do the same for mode 5, but for the third pixel in the row (out of 4),
\ the table returns this value instead:
\ 
\   CTWOS+2  = %00100010
\ 
\ which breaks up into 0010 0010, or %11 in the third pixel. As with TWOS, we
\ can use this byte as a mask onto a 4-pixel colour byte to work out what to
\ poke into screen memory.
\ 
\ On the subject of 4-pixel colour bytes, this is what they look like for the
\ four colours used in the dashboard:
\ 
\   * Colour 0: %00000000 = &00 (black)
\ 
\   * Colour 1: %00001111 = &0F (red)
\ 
\   * Colour 2: %11110000 = &F0 (yellow/white)
\ 
\   * Colour 3: %11111111 = &FF (green/cyan)
\ 
\ So aside from having two bits per pixel and four pixels per character row,
\ mode 5 is pretty similar to the monochrome mode 4.
\
\ ******************************************************************************

.CPIX2
{
 LDA Y1                 \ Fetch the y-coordinate into A

\.CPIX                  \ This label is commented out in the original source. It
                        \ would provide a new entry point with A specifying the
                        \ y-coordinate instead of Y1, but it isn't used anywhere

 TAY                    \ Store the y-coordinate in Y

 LSR A                  \ Set A = A / 8, so A now contains the character row we
 LSR A                  \ need to draw in (as each character row contains 8
 LSR A                  \ pixel rows)

 ORA #&60               \ Each character row in Elite's screen mode takes up one
                        \ page in memory (256 bytes), so we now OR with &60 to
                        \ get the page containing the dash (see the comments in
                        \ routine TT26 for more discussion about calculating
                        \ screen memory addresses

 STA SCH                \ Store the screen page in the high byte of SC(1 0)

 LDA X1                 \ Each character block covers 8 screen x-coordinates, so 
 AND #%11111000         \ to get the address of the first byte in the character
                        \ block that we need to draw into, as an offset from the
                        \ start of the row we clear bits 0-2

 STA SC                 \ Store the address of the character block in the low
                        \ byte of SC(1 0), so now SC(1 0) points to the
                        \ character block we need to draw into

 TYA                    \ Set Y to just bits 0-2 of the y-coordinate, which will
 AND #%00000111         \ be the number of the pixel row we need to draw into
 TAY                    \ within the character block

 LDA X1                 \ Copy bits 0-1 of X to bits 1-2 of X1, and clear the C
 AND #%00000110         \ flag in the process (using the LSR). X will now be
 LSR A                  \ a value between 0 and 3, and will be the pixel number
 TAX                    \ in the character row for the left pixel in the dash.
                        \ This is because each character row is one byte that
                        \ contains 4 pixels, but covers 8 screen coordinates, so
                        \ this effectively does the division by 2 that we need

 LDA CTWOS,X            \ Fetch a mode 5 1-pixel byte with the pixel position
 AND COL                \ at X, and AND with the colour byte so that pixel takes
                        \ on the colour we want to draw (i.e. A is acting as a
                        \ mask on the colour byte)

 EOR (SC),Y             \ Draw the pixel on screen using EOR logic, so we can
 STA (SC),Y             \ remove it later without ruining the background that's
                        \ already on screen

 LDA CTWOS+1,X          \ Fetch a mode 5 1-pixel byte with the pixel position
                        \ at X+1, so we can draw the right pixel of the dash

 BPL CP1                \ The CTWOS table has an extra row at the end of it that
                        \ repeats the first value, %10001000, so if we have not
                        \ fetched that value, then the right pixel of the dash
                        \ is in the same character block as the left pixel, so
                        \ jump to CP1 to draw it

 LDA SC                 \ Otherwise the left pixel we drew was at the last
 ADC #8                 \ position of four in this character block, so we add
 STA SC                 \ 8 to the screen address to move onto the next block
                        \ along (as there are 8 bytes in a character block).
                        \ The C flag was cleared above, so this ADC is correct

 LDA CTWOS+1,X          \ Refetch the mode 5 1-pixel byte, as we just overwrote
                        \ A (the byte will still be the fifth byte from the
                        \ table, which is correct as we want to draw the
                        \ leftmost pixel in the next character along as the
                        \ dash's right pixel)

.CP1

 AND COL                \ Draw the dash's right pixel according to the mask in
 EOR (SC),Y             \ A, with the colour in COL, using EOR logic, just as
 STA (SC),Y             \ above

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: OOPS
\
\ We just took some damage, so reduce the shields if we have any, or reduce the
\ energy levels and potentially take some damage to the cargo if we don't.
\
\ Arguments:
\
\   A                   The amount of damage to take
\
\   INF                 The address of the ship block for the ship that attacked
\                       us, or the ship that we just ran into
\
\ ******************************************************************************

.OOPS
{
 STA T                  \ Store the amount of damage in T

 LDY #8                 \ Fetch byte #8 (z_sign) for the ship attacking us, and
 LDX #0                 \ set X = 0
 LDA (INF),Y

 BMI OO1                \ If A is negative, then we got hit in the rear, so jump
                        \ to OO1 to process damage to the aft shield

 LDA FSH                \ Otherwise the forward shield was damaged, so fetch the
 SBC T                  \ shield strength from FSH and subtract the damage in T

 BCC OO2                \ If the C flag is clear then this amount of damage was
                        \ too much for the shields, so jump to OO2 to set the
                        \ shield level to 0 and start taking damage directly
                        \ from the energy banks

 STA FSH                \ Store the new value of the forward shield in FSH

 RTS                    \ Return from the subroutine

.OO2

\LDX #0                 \ This instruction is commented out in the original
                        \ source, and isn't required as X is set to 0 above

 STX FSH                \ Set the forward shield to 0

 BCC OO3                \ Jump to OO3 to start taking damage directly from the
                        \ energy banks (this BCC is effectively a JMP as the C
                        \ flag is clear, as we jumped to OO2 with a BCC)

.OO1                    \ Aft shield hit

 LDA ASH                \ The aft shield was damaged, so fetch the shield
 SBC T                  \ strength from ASH and subtract the damage in T

 BCC OO5                \ If the C flag is clear then this amount of damage was
                        \ too much for the shields, so jump to OO5 to set the
                        \ shield level to 0 and start taking damage directly
                        \ from the energy banks

 STA ASH                \ Store the new value of the aft shield in ASH

 RTS                    \ Return from the subroutine

.OO5

\LDX #0                 \ This instruction is commented out in the original
                        \ source, and isn't required as X is set to 0 above

 STX ASH                \ Set the aft shield to 0

.OO3

 ADC ENERGY             \ A is negative and contains the amount by which the
 STA ENERGY             \ damage overwhelmed the shields, so this drains the
                        \ energy banks by that amount (and because the energy
                        \ banks are shown over four indicators rather than one,
                        \ but with the same value range of 0-255, energy will
                        \ appear to drain away four times faster than the
                        \ shields did)

 BEQ P%+4               \ If we have just run out of energy, skip the next
                        \ instruction to jump straight to our death

 BCS P%+5               \ If the C flag is set, then subtracting the damage from
                        \ the energy banks didn't underflow, so we had enough
                        \ energy to survive, and we can skip the next
                        \ instruction to make a sound and take some damage

 JMP DEATH              \ Otherwise our energy levels are either 0 or negative,
                        \ and in either case that means we jump to our DEATH,
                        \ returning from the subroutine using a tail call

 JSR EXNO3              \ We didn't die, so call EXNO3 to make the sound of a
                        \ collision

 JMP OUCH               \ And jump to OUCH to take damage and return from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: SPS3
\
\ Copy one of the the planet's coordinates into the corresponding location in
\ the temporary variable K3. The high byte and absolute value of the sign byte
\ are copied into the first two K3 bytes, and the sign of the sign byte is
\ copied into the highest K3 byte.
\
\ The comments below are written for the x-coordinate.
\
\ Arguments:
\
\   X                   Determines which coordinate to copy, and to where:
\
\                         * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
\
\                         * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
\
\                         * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
\
\ ******************************************************************************

.SPS3
{
 LDA K%+1,X             \ Copy x_hi into K3+X
 STA K3,X

 LDA K%+2,X             \ Set A = Y = x_sign
 TAY

 AND #%01111111         \ Set K3+1 = |x_sign|
 STA K3+1,X

 TYA                    \ Set K3+2 = the sign of x_sign
 AND #%10000000
 STA K3+2,X

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: GINF
\
\ Get the address of the data block for ship slot X and store it in INF. This
\ address is fetched from the UNIV table, which stores the addresses of the 13
\ ship data blocks in workspace K%.
\
\ Arguments:
\
\   X                   The ship slot number for which we want the data block
\                       address
\
\ ******************************************************************************

.GINF
{
 TXA                    \ Set Y = X * 2
 ASL A
 TAY

 LDA UNIV,Y             \ Get the high byte of the address of the X-th ship
 STA INF                \ from UNIV and store it in INF

 LDA UNIV+1,Y           \ Get the low byte of the address of the X-th ship
 STA INF+1              \ from UNIV and store it in INF

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: NWSPS
\
\ Add a new space station to our little bubble of universe.
\
\ ******************************************************************************

.NWSPS
{
 JSR SPBLB              \ Light up the space station bulb on the dashboard

 LDX #1                 \ Set the AI flag in INWK+32 to 1 (friendly, no AI, has
 STX INWK+32            \ E.C.M.)

 DEX                    \ Set pitch counter to 0 (no pitch, roll only)
 STX INWK+30

\STX INWK+31            \ This instruction is commented out in the original
                        \ source. It would set the exploding state and missile
                        \ count to 0

 STX FRIN+1             \ Set the sun/space station slot at FRIN+1 to 0, to
                        \ indicate we should show the space station rather than
                        \ the sun

 DEX                    \ Set roll counter to 255 (maximum roll with no
 STX INWK+29            \ damping)

 LDX #10                \ Call NwS1 to flip the sign of nosev_x_hi (INWK+10)
 JSR NwS1

 JSR NwS1               \ And again to flip the sign of nosev_y_hi (INWK+12)

 JSR NwS1               \ And again to flip the sign of nosev_z_hi (INWK+14)

 LDA #LO(LSO)           \ Set INWK+33 and INWK+34 to point to LSO for the ship
 STA INWK+33            \ lines heap space for the space station
 LDA #HI(LSO)
 STA INWK+34

 LDA #SST               \ Set A to the space station type, and fall through
                        \ into NWSHP to finish adding the space station to the
                        \ universe
}

\ ******************************************************************************
\
\ Subroutine: NWSHP
\
\ Add a new ship to our local bubble of universe. This creates a new block of
\ ship data in the workspace at K%, allocates a new block in the ship lines heap
\ space at WP, adds the new ship's type into the first empty slot in FRIN, and
\ adds a pointer to the ship data into UNIV. If there isn't enough free memory
\ for the new ship, it isn't added.
\
\ Arguments:
\
\   A                   The type of the ship to add (see variable XX21 for a
\                       list of ship types)
\
\ Returns:
\
\   C flag              Set if the ship was successfully added, clear if it
\                       wasn't (as there wasn't enough free memory)
\
\ ******************************************************************************

.NWSHP
{
 STA T                  \ Store the ship type in location T

 LDX #0                 \ Before we can add a new ship, we need to check
                        \ whether we have an empty slot we can put it in. To do
                        \ this, we need to loop through all the slots to look
                        \ for an empty one, so set a counter in X that starts
                        \ from the first slot at 0. When ships are killed, then
                        \ the slots are shuffled down by the KILLSHP routine, so
                        \ the first empty slot will always come after the last
                        \ filled slot. This allows us to tack the new ship's
                        \ data block and ship lines heap onto the end of the
                        \ existing ship data and heap, as shown in the memory
                        \ map below

.NWL1

 LDA FRIN,X             \ Load the ship type for the X-th slot

 BEQ NW1                \ If it is zero, then this slot is empty and we can use
                        \ it for our new ship, so jump down to NW1

 INX                    \ Otherwise increment X to point to the next slot

 CPX #NOSH              \ If we haven't reached the last slot yet, loop back up
 BCC NWL1               \ to NWL1 to check the next slot

.NW3

 CLC                    \ Otherwise we don't have an empty slot, so we can't
 RTS                    \ add a new ship, so clear the carry flag to indicate
                        \ that we have not managed to create the new ship, and
                        \ return from the subroutine

.NW1                    \ If we get here, then we have found an empty slot at
                        \ index X, so we can go ahead and create our new ship.
                        \ We do that by creating a ship data block at INWK and,
                        \ when we are done, copying the block from INWK into
                        \ the workspace at K% (specifically, to INF)

 JSR GINF               \ Get the address of the data block for ship slot X
                        \ (which is in workspace K%) and store it in INF

 LDA T                  \ If the type of ship that we want to create is
 BMI NW2                \ negative, then this indicates a planet or sun, so
                        \ jump down to NW2, as the next section sets up a ship
                        \ data block, which doesn't apply to planets and suns,
                        \ as they don't have things like shields, missiles,
                        \ vertices and edges

                        \ This is a ship, so first we need to set up various
                        \ pointers to the ship blueprint we will need. The
                        \ blueprints for each ship type in Elite are stored
                        \ in a table at location XX21, so refer to the comments
                        \ on that variable for more details on the data we're
                        \ about to access

 ASL A                  \ Set Y = ship type * 2
 TAY

 LDA XX21-2,Y           \ The ship blueprints at XX21 start with a lookup
 STA XX0                \ table that points to the individual ship blueprints,
                        \ so this fetches the low byte of this particular ship
                        \ type's blueprint and stores it in XX0

 LDA XX21-1,Y           \ Fetch the high byte of this particular ship type's
 STA XX0+1              \ blueprint and store it in XX0+1

 CPY #2*SST             \ If the ship type is a space station (SST), then jump
 BEQ NW6                \ to NW6, skipping the heap space steps below

                        \ We now want to allocate a heap space that we can use
                        \ while drawing our new ship - the ship lines heap
                        \ space. SLSP points to the start of the current
                        \ heap space, and we can extend it downwards with the
                        \ heap for our new ship (as the heap space always ends
                        \ just before the workspace at WP)

 LDY #5                 \ Fetch ship blueprint byte #5, which contains the
 LDA (XX0),Y            \ maximum heap size required for plotting the new ship,
 STA T1                 \ and store it in T1

 LDA SLSP               \ Take the 16-bit address in SLSP and subtract T1,
 SEC                    \ storing the 16-bit result in (INWK+34 INWK+33),
 SBC T1                 \ so this now points to the start of the heap space
 STA INWK+33            \ for our new ship
 LDA SLSP+1
 SBC #0
 STA INWK+34

                        \ We now need to check that there is enough free space
                        \ for both this new heap space and the new data block
                        \ for our ship. In memory, this is the layout of the
                        \ ship data and heap space:
                        \
                        \   High address
                        \
                        \   +-----------------------------------+   &0F34
                        \   |                                   |
                        \   | WP workspace                      |
                        \   |                                   |
                        \   +-----------------------------------+   &0D40 = WP
                        \   |                                   |
                        \   | Current ship lines heap           |
                        \   |                                   |
                        \   +-----------------------------------+   SLSP
                        \   |                                   |
                        \   | Proposed heap for new ship        |
                        \   |                                   |
                        \   +-----------------------------------+   INWK+33
                        \   |                                   |
                        \   .                                   .
                        \   .                                   .
                        \   .                                   .
                        \   .                                   .
                        \   .                                   .
                        \   |                                   |
                        \   +-----------------------------------+   INF+NI%
                        \   |                                   |
                        \   | Proposed data block for new ship  |
                        \   |                                   |
                        \   +-----------------------------------+   INF
                        \   |                                   |
                        \   | Existing ship data blocks         |
                        \   |                                   |
                        \   +-----------------------------------+   &0900 = K%
                        \
                        \   Low address
                        \
                        \ So, to work out if we have enough space, we have to
                        \ make sure there is room between the end of our new
                        \ ship data block at INF+NI%, and the start of the
                        \ proposed heap for our new ship at INWK+33. Or, to
                        \ put it another way, we need to make sure that:
                        \
                        \   INWK+33 > INF+NI%
                        \
                        \ which is the same as saying:
                        \
                        \   INWK+33 - INF > NI%

 LDA INWK+33            \ Calculate INWK+33 - INF, again using 16-bit
\SEC                    \ arithmetic, and put the result in (A Y), so the high
 SBC INF                \ byte is in A and the low byte in Y. The SEC
 TAY                    \ instruction is commented out in the original source;
 LDA INWK+34            \ as the previous subtraction will never underflow, it
 SBC INF+1              \ is superfluous

 BCC NW3+1              \ If we have an underflow from the subtraction, then
                        \ INF > INWK+33 and we definitely don't have enough
                        \ room for this ship, so jump to NW3+1, which clears
                        \ the carry flag and returns from the subroutine

 BNE NW4                \ If the subtraction of the high bytes in A is not
                        \ zero, and we don't have underflow, then we definitely
                        \ have enough space, so jump to NW4 to continue setting
                        \ up the new ship

 CPY #NI%               \ Otherwise the high bytes are the same in our
 BCC NW3+1              \ subtraction, so now we compare the low byte of the
                        \ result (which is in Y) with NI%. This is the same as
                        \ doing INWK+33 - INF > NI% (see above). If this isn't
                        \ true, the carry flag will be clear and we don't have
                        \ enough space, so we jump to NW3+1, which clears the
                        \ carry flag and returns from the subroutine

.NW4

 LDA INWK+33            \ If we get here then we do have enough space for our
 STA SLSP               \ new ship, so store the new bottom of the ship lines
 LDA INWK+34            \ heap space (i.e. INWK+33) in SLSP, doing both the
 STA SLSP+1             \ high and low bytes

.NW6

 LDY #14                \ Fetch ship blueprint byte #14, which contains the
 LDA (XX0),Y            \ ship's energy, and store it in INWK+35
 STA INWK+35

 LDY #19                \ Fetch ship blueprint byte #19, which contains the
 LDA (XX0),Y            \ number of missiles and laser power, and AND with %111
 AND #%00000111         \ to extract the number of missiles before storing in
 STA INWK+31            \ INWK+31

 LDA T                  \ Restore the ship type we stored above

.NW2

 STA FRIN,X             \ Store the ship type in the X-th byte of FRIN, so the
                        \ this slot is now shown as occupied in the index table

 TAX                    \ Copy the ship type into X

 BMI P%+5               \ If the ship type is negative (planet or sun), then
                        \ skip the following instruction

 INC MANY,X             \ Increment the total number of ships of type X

 LDY #(NI%-1)           \ The final step is to copy the new ship's data block
                        \ from INWK to INF, so set up a counter for NI% bytes
                        \ in Y

.NWL3

 LDA INWK,Y             \ Load the Y-th byte of INWK and store in the Y-th byte
 STA (INF),Y            \ of the workspace pointed to by INF

 DEY                    \ Decrement the loop counter

 BPL NWL3               \ Loop back for the next byte until we have copied them
                        \ all over

 SEC                    \ We have successfuly created our new ship, so set the
                        \ carry flag to indicate success

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: NwS1
\
\ Flip the sign of the INWK byte at offset X, and increment X by 2. This is
\ is used by the space station creation routine at NWSPS.
\
\ Arguments:
\
\   X                   The offset of the INWK byte to be flipped
\
\ Returns:
\
\   X                   X is incremented by 2
\
\ ******************************************************************************

.NwS1
{
 LDA INWK,X             \ Load the X-th byte of INWK into A and flip bit 7,
 EOR #%10000000         \ storing the result back in the X-th byte of INWK
 STA INWK,X

 INX                    \ Add 2 to X
 INX

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: ABORT
\
\ Disarm missiles and update the dashboard.
\
\ ******************************************************************************

.ABORT
{
 LDX #&FF               \ Set X to &FF, which is the value in MSTG when we have
                        \ no target lock for our missile

                        \ Fall through into ABORT2 to set the missile lock to
                        \ the value in X, which effectively disarms the missile
}

\ ******************************************************************************
\
\ Subroutine: ABORT2
\
\ Set the lock target for the leftmost missile and update the dashboard.
\
\ Arguments:
\
\   X                   The slot number of the ship in our missile lock, or &FF
\                       to remove missile lock
\
\   Y                   The new colour of the missile indicator:
\
\                         * &00 = black (no missile)
\
\                         * &0E = red (armed and locked)
\
\                         * &E0 = yellow/white (armed)
\
\                         * &EE = green/cyan (disarmed)
\
\ ******************************************************************************

.ABORT2
{
 STX MSTG               \ Store the target of our missile lock in MSTG

 LDX NOMSL              \ Update the leftmost indicator in the dashboards's
 JSR MSBAR              \ missile bar, returns with Y = 0

 STY MSAR               \ Set MSAR = 0 to indicate that the leftmost missile
                        \ is no longer seeking a target lock

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: ECBLB2
\
\ Light up the E.C.M. indicator bulb on the dashboard, set the E.C.M. countdown
\ timer to 32, and start making the E.C.M. sound.
\
\ ******************************************************************************

.ECBLB2
{
 LDA #32                \ Set the E.C.M. countdown timer in ECMA to 32
 STA ECMA

 ASL A                  \ Call the NOISE routine with A = 64 to make the sound
 JSR NOISE              \ of the E.C.M. being switched on

                        \ Fall through into ECBLB to light up the E.C.M. bulb
}

\ ******************************************************************************
\
\ Subroutine: ECBLB
\
\ Light up the E.C.M. indicator bulb ("E") on the dashboard.
\
\ ******************************************************************************

.ECBLB
{
 LDA #7*8               \ The E.C.M. bulb is in character block number 7
                        \ with each character taking 8 bytes, so this sets the
                        \ low byte of the screen address of the character block
                        \ we want to draw to

 LDX #LO(ECBT)          \ Set (Y X) to point to the character definition in
 LDY #HI(ECBT)          \ ECBT. The LDY has no effect, as we overwrite Y with
                        \ the jump to BULB-2, which writes the high byte of SPBT
                        \ into Y. This works as long as ECBT and SPBT are in
                        \ the same page of memory, so perhaps the BNE below got
                        \ changed from BULB to BULB-2 so they could remove the
                        \ LDY, but for some reason it didn't get culled? Who
                        \ knows...

 BNE BULB-2             \ Jump down to BULB-2 (this BNE is effectively a JMP as
                        \ A will never be zero)
}

\ ******************************************************************************
\
\ Subroutine: SPBLB
\
\ Draw (or erase) the space station indicator bulb ("S") on the dashboard.
\
\ Other entry points:
\
\   BULB-2              Set the Y screen address
\
\ ******************************************************************************

.SPBLB                  \ Space Station bulb
{
 LDA #24*8              \ The space station bulb is in character block number 24
                        \ with each character taking 8 bytes, so this sets the
                        \ low byte of the screen address of the character block
                        \ we want to draw to

 LDX #LO(SPBT)          \ Set (Y X) to point to the character definition in SPBT
 LDY #HI(SPBT)
}

\ ******************************************************************************
\
\ Subroutine: BULB
\
\ Draw an indicator bulb on the dashboard.
\
\ Arguments:
\
\   A                   The y-coordinate of the bulb as a low-byte screen
\                       address offset within screen page &7D (as both bulbs
\                       are on this character row in the dashboard)
\
\   (Y X)               The address of the character definition of the bulb to
\                       be drawn (i.e ECBT for the E.C.M. bulb, or SPBT for the
\                       space station bulb)
\
\ ******************************************************************************

.BULB
{
 STA SC                 \ Store the low byte of the screen address in SC

 STX P+1                \ Set P(2 1) = (Y X)
 STY P+2                \ font pointer hi

 LDA #&7D               \ Set A to the high byte of the screen address, which is
                        \ &7D as the bulbs are both in the character row from
                        \ &7D00 to &7DFF

 JMP RREN               \ Call RREN to print the character definition pointed to
                        \ by P(2 1) at the screen address pointed to by (A SC),
                        \ returning from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Variable: ECBT
\
\ The character definition for the E.C.M. indicator's "E" bulb that gets
\ displayed on the dashboard. The E.C.M. indicator uses the first 5 rows of the
\ space station's "S" bulb below, as the bottom 5 rows of the "E" match the top
\ 5 rows of the "S". Each pixel is in mode 5 colour 2 (%10), which is
\ yellow/white.
\
\ ******************************************************************************

.ECBT
{
 EQUB %11100000
 EQUB %11100000
 EQUB %10000000
}

\ ******************************************************************************
\
\ Variable: SPBT
\
\ The character definition for the space station indicator's "S" bulb that gets
\ displayed on the dashboard. Each pixel is in mode 5 colour 2 (%10), which is
\ yellow/white.
\
\ ******************************************************************************

.SPBT
{
 EQUB %11100000
 EQUB %11100000
 EQUB %10000000
 EQUB %11100000
 EQUB %11100000
 EQUB %00100000
 EQUB %11100000
 EQUB %11100000
}

\ ******************************************************************************
\
\ Subroutine: MSBAR
\
\ Draw a specific indicator in the dashboards's missile bar. Each indicator is
\ a rectangle that's 3 pixels wide and 5 pixels high. If the indicator is set to
\ black, this effectively removes a missile.
\
\ Arguments:
\
\   X                   The number of the missile indicator to update (counting
\                       from right to left, so indicator NOMSL is the leftmost
\                       indicator)
\
\   Y                   The colour of the missile indicator:
\
\                         * &00 = black (no missile)
\
\                         * &0E = red (armed and locked)
\
\                         * &E0 = yellow/white (armed)
\
\                         * &EE = green/cyan (disarmed)
\
\ Returns:
\
\   Y                   Y is set to 0
\
\ ******************************************************************************

.MSBAR
{
 TXA                    \ Set T = X * 8
 ASL A
 ASL A
 ASL A
 STA T

 LDA #49                \ Set SC = 49 - T
 SBC T                  \        = 48 + 1 - (X * 8)
 STA SC                 \
                        \ So the low byte of SC(1 0) contains the row address
                        \ for the rightmost missile indicator, made up as
                        \ follows:
                        \
                        \   * 48 (character block 7, or byte 7 * 8 = 48, which
                        \     is the character block of the rightmost missile
                        \
                        \   * 1 (so we start drawing on the second row of the
                        \     character block)
                        \
                        \   * Move right one character (8 bytes) for each count
                        \     of X, so when X = 0 we are drawing the rightmost
                        \     missile, for X = 1 we hop to the left by one
                        \     character, and so on

 LDA #&7E               \ Set the high byte of SC(1 0) to &7E, the character row
 STA SCH                \ that contains the missile indicators (i.e. the bottom
                        \ row of the screen)

 TYA                    \ Set A to the correct colour, which is a 3-pixel wide
                        \ mode 5 character row in the correct colour (for
                        \ example, a green block has Y = &EE, or %1110 1110, so
                        \ the missile blocks are 3 pixels wide, with the
                        \ fourth pixel on the character row being empty)

 LDY #5                 \ We now want to draw this line five times, so set a
                        \ counter in Y

.MBL1

 STA (SC),Y             \ Draw the 3-pixel row, as as we do not use EOR logic,
                        \ this will overwrite anything that is already there
                        \ (so drawing a black missile will delete what's there)

 DEY                    \ Decrement the counter for the next row

 BNE MBL1               \ Loop back to MBL1 if have more rows to draw

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: PROJ
\
\ Project K+INWK(x,y)/z to K3,K4 for center to screen
\
\ ******************************************************************************

.PROJ                   \ Project K+INWK(x,y)/z to K3,K4 for center to screen
{
 LDA INWK               \ xlo
 STA P
 LDA INWK+1             \ xhi
 STA P+1
 LDA INWK+2             \ xsg
 JSR PLS6               \ Klo.Xhi = P.A/INWK_z, C set if big
 BCS PL2-1              \ rts as x big
 LDA K
 ADC #X                 \ add xcenter
 STA K3
 TXA                    \ xhi
 ADC #0                 \ K3 is xcenter of planet
 STA K3+1

 LDA INWK+3             \ ylo
 STA P
 LDA INWK+4             \ yhi
 STA P+1
 LDA INWK+5             \ ysg
 EOR #128               \ flip yscreen
 JSR PLS6               \ Klo.Xhi = P.A/INWK_z, C set if big
 BCS PL2-1              \ rts as y big
 LDA K
 ADC #Y                 \ #Y for add ycenter
 STA K4
 TXA                    \ y hi
 ADC #0                 \ K4 is ycenter of planet
 STA K4+1
 CLC                    \ carry clear is center is on screen
 RTS                    \ PL2-1
}

\ ******************************************************************************
\
\ Subroutine: PL2
\
\ Wipe planet/sun
\
\ ******************************************************************************

.PL2                    \ planet/sun behind
{
 LDA TYPE               \ ship type
 LSR A                  \ bit0
 BCS P%+5               \ sun has bit0 set
 JMP WPLS2              \ bit0 clear Wipe Planet
 JMP WPLS               \ Wipe Sun
}

\ ******************************************************************************
\
\ Subroutine: PLANET
\
\ Planet or Sun type to screen
\
\ ******************************************************************************

.PLANET                 \ Planet or Sun type to screen
{
 LDA INWK+8             \ zsg if behind
 BMI PL2                \ wipe planet/sun
 CMP #48                \ very far away?
 BCS PL2                \ wipe planet/sun
 ORA INWK+7             \ zhi
 BEQ PL2                \ else too close, wipe planet/sun
 JSR PROJ               \ Project K+INWK(x,y)/z to K3,K4 for center to screen
 BCS PL2                \ if center large offset wipe planet/sun

 LDA #96                \ default radius hi
 STA P+1
 LDA #0                 \ radius lo
 STA P
 JSR DVID3B2            \ divide 3bytes by 2, K = P(2).A/INWK_z
 LDA K+1                \ radius hi
 BEQ PL82               \ radius hi fits
 LDA #&F8               \ else too big
 STA K                  \ radius

.PL82                   \ radius fits

 LDA TYPE               \ ship type
 LSR A                  \ sun has bit0 set
 BCC PL9                \ planet radius K
 JMP SUN                \ else Sun #&81 #&83 .. with radius Ks

.PL9                    \ Planet radius K

 JSR WPLS2              \ wipe planet
 JSR CIRCLE             \ for planet
 BCS PL20               \ rts, else circle done
 LDA K+1
 BEQ PL25               \ planet on screen

.PL20

 RTS

.PL25                   \ Planet on screen

 LDA TYPE               \ ship type
 CMP #&80               \ Lave 2-rings is #&80
 BNE PL26               \ Other planet #&82 is crater
 LDA K
 CMP #6                 \ very small radius ?
 BCC PL20               \ rts
 LDA INWK+14            \ nosev_z hi. Start first  meridian
 EOR #128               \ flipped nosev_z hi
 STA P                  \ meridian width
 LDA INWK+20            \ roofv_z hi, for meridian1
 JSR PLS4               \ CNT2 = angle of P_opp/A_adj for Lave
 LDX #9                 \ nosev.x for both meridians
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 STA K2                 \ mag  0.x   used in final x of arc
 STY XX16               \ sign 0.x
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 STA K2+1               \ mag  0.y   used in final y of arc
 STY XX16+1             \ sign 0.y
 LDX #15                \ roofv.x for first meridian
 JSR PLS5               \ mag K2+2,3 sign XX16+2,3 = NWK(X+=2)/INWK_z

 JSR PLS2               \ Lave half ring, phase offset CNT2
 LDA INWK+14            \ nosev_z hi. Start second meridian
 EOR #128               \ flipped nosev_z hi
 STA P                  \ meridian width again
 LDA INWK+26            \ sidev_z hi, for meridian2 at 90 degrees
 JSR PLS4               \ CNT2 = angle of P_opp/A_adj for Lave

 LDX #21                \ sidev.x for second meridian
 JSR PLS5               \ mag K2+2,3 sign XX16+2,3 = NWK(X+=2)/INWK_z
 JMP PLS2               \ Lave half ring, phase offset CNT2

.PL26                   \ crtr \ their comment \ Other planet e.g. #&82 has One crater

 LDA INWK+20            \ roofv_z hi
 BMI PL20               \ rts, crater on far side

 LDX #15                \ roofv.x (same as meridian1)
 JSR PLS3               \ A.Y = 222* INWK(X+=2)/INWK_z. 222 is xoffset of crater
 CLC                    \ add xorg lo
 ADC K3
 STA K3
 TYA                    \ xoffset hi of crater center updated
 ADC K3+1
 STA K3+1
 JSR PLS3               \ A.Y = 222* INWK(X+=2)/INWK_z. 222 is yoffset of crater
 STA P
 LDA K4
 SEC                    \ sub Plo from yorg lo
 SBC P
 STA K4
 STY P                  \ yoffset hi temp
 LDA K4+1               \ yorg hi
 SBC P                  \ yoffset hi temp
 STA K4+1               \ y of crater center updated

 LDX #9                 \ nosev.x  (same as both meridians)
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 LSR A                  \ /2 used in final x of ring
 STA K2                 \ mag 0.x/2
 STY XX16               \ sign 0.x
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 LSR A                  \ /2 used in final y of ring
 STA K2+1               \ mag 0.y/2
 STY XX16+1             \ sign 0.y

 LDX #21                \ sidev.x (same as second meridian)
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 LSR A                  \ /2 used in final x of ring
 STA K2+2               \ mag 2.x/2
 STY XX16+2             \ sign 2.x
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 LSR A                  \ /2 used in final y of ring
 STA K2+3               \ mag 2.y/2
 STY XX16+3             \ sign 2.y

 LDA #64                \ full circle
 STA TGT                \ count target
 LDA #0                 \ no phase offset for crater ring
 STA CNT2
 JMP PLS22              \ guaranteed crater with TGT = #64
}

\ ******************************************************************************
\
\ Subroutine: PLS1
\
\ X = 9 etc. A.Y = INWK(X+=2)/INWK_z
\
\ ******************************************************************************

.PLS1                   \ X = 9 etc. A.Y = INWK(X+=2)/INWK_z
{
 LDA INWK,X
 STA P
 LDA INWK+1,X
 AND #127               \ 7bits of hi
 STA P+1
 LDA INWK+1,X           \ again, get sign for 3rd byte
 AND #128               \ sign only

 JSR DVID3B2            \ divide 3bytes by 2, K = P(2).A/INWK_z
 LDA K                  \ lo
 LDY K+1                \ hi
 BEQ P%+4
 LDA #&FE               \ else sat Acc and keep Y = K+1 non-zero
 LDY K+3                \ sign
 INX                    \ X+=2
 INX
 RTS
}

\ ******************************************************************************
\
\ Subroutine: PLS2
\
\ Lave half ring, mags K2+0to3, signs XX16+0to3, xy(0)xy(1), phase offset CNT2
\
\ ******************************************************************************

.PLS2                   \ Lave half ring, mags K2+0to3, signs XX16+0to3, xy(0)xy(1), phase offset CNT2
{
 LDA #31                \ half-circle
 STA TGT                \ count target
}

\ ******************************************************************************
\
\ Subroutine: PLS22
\
\ Also crater with TGT = #64
\
\ ******************************************************************************

.PLS22                  \ also crater with TGT = #64
{
 LDX #0
 STX CNT                \ count
 DEX                    \ X = #&FF
 STX FLAG

.PLL4                   \ counter CNT+= STP > TGT planet ring

 LDA CNT2               \ for arc
 AND #31                \ angle index
 TAX                    \ sine table
 LDA SNE,X
 STA Q                  \ sine
 LDA K2+2               \ mag x1
 JSR FMLTU              \ A=A*Q/256unsg
 STA R                  \ part2 lo x = mag x1 * sin
 LDA K2+3               \ mag y1
 JSR FMLTU              \ A=A*Q/256unsg
 STA K                  \ part2 lo y =  mag y1 * sin
 LDX CNT2
 CPX #33                \ for arc
 LDA #0                 \ any sign
 ROR A                  \ into 7th bit
 STA XX16+5             \ ysign

 LDA CNT2
 CLC                    \ for arc
 ADC #16                \ cosine
 AND #31                \ index
 TAX                    \ sinetable
 LDA SNE,X
 STA Q                  \ cosine
 LDA K2+1               \ mag y0
 JSR FMLTU              \ A=A*Q/256unsg
 STA K+2                \ part1 lo y = mag y0 * cos
 LDA K2                 \ mag x0
 JSR FMLTU              \ A=A*Q/256unsg
 STA P                  \ part1 lo x  = mag x0 * cos
 LDA CNT2
 ADC #15                \ for arc
 AND #63                \ 63 max
 CMP #33                \ > 32 ?
 LDA #0                 \ any carry is sign
 ROR A                  \ into 7th bit
 STA XX16+4             \ xsign

 LDA XX16+5             \ ysign
 EOR XX16+2             \ x1 sign
 STA S                  \ S = part2 hi x
 LDA XX16+4             \ xsign
 EOR XX16               \ A = part1 hi x
 JSR ADD                \ lo x = mag x0 * cos + mag x1 * sin
 STA T                  \ sum hi
 BPL PL42               \ hop xplus
 TXA                    \ else minus, sum lo
 EOR #&FF
 CLC
 ADC #1
 TAX                    \ flipped lo
 LDA T                  \ sum hi
 EOR #&7F
 ADC #0
 STA T                  \ flip sum hi and continue

.PL42                   \ hop xplus

 TXA                    \ sum x lo
 ADC K3                 \ xcenter lo
 STA K6                 \ xfinal lo
 LDA T                  \ sum x hi
 ADC K3+1               \ xcenter hi
 STA K6+1               \ xfinal hi

 LDA K                  \ part2 lo y
 STA R                  \ part2 lo y
 LDA XX16+5             \ ysign
 EOR XX16+3             \ y1 sign
 STA S                  \ part2 hi y
 LDA K+2                \ part1 lo y
 STA P                  \ part1 lo y
 LDA XX16+4             \ xsign
 EOR XX16+1             \ A = part1 hi y
 JSR ADD                \ lo y = mag y0 * cos +  mag y1 * sin
 EOR #128               \ flip
 STA T                  \ yfinal hi
 BPL PL43               \ hop yplus
 TXA                    \ else minus, sum lo
 EOR #&FF
 CLC
 ADC #1
 TAX                    \ flipped lo, yfinal lo
 LDA T                  \ yfinal hi
 EOR #&7F
 ADC #0
 STA T                  \ flipped sum hi and continue, yfinal hi

.PL43                   \ hop yplus

 JSR BLINE              \ ball line uses (X.T) as next y offset for arc
 CMP TGT                \ CNT+= STP > TGT
 BEQ P%+4               \ = TGT, next
 BCS PL40               \ > TGT exit arc rts
 LDA CNT2               \ next, CNT2
 CLC                    \ +step for ring
 ADC STP
 AND #63                \ round
 STA CNT2
 JMP PLL4               \ loop planet ring

.PL40

 RTS                    \ end Crater ring
}

\ ******************************************************************************
\
\ Subroutine: PLF3-3
\
\ Wipe Sun
\
\ ******************************************************************************

{
 JMP WPLS               \ Wipe Sun
}

\ ******************************************************************************
\
\ Subroutine: PLF3
\
\ Flip height for planet/sun fill
\
\ ******************************************************************************

.PLF3                   \ flip height for planet/sun fill
{
 TXA                    \ Yscreen height lo
 EOR #&FF               \ flip
 CLC
 ADC #1
 TAX                    \ height flipped
}

\ ******************************************************************************
\
\ Subroutine: PLF17
\
\ up A = #&FF as Xlo =0
\
\ ******************************************************************************

.PLF17                  \ up A = #&FF as Xlo =0
{
 LDA #&FF               \ fringe flag will run up
 JMP PLF5               \ guaranteed, Xreg = height ready
}

\ ******************************************************************************
\
\ Subroutine: SUN
\
\ Plot a sun with radius K at pixel coordinate (K3, K4).
\
\ Arguments:
\
\   K(1 0)              The sun's radius as a 16-bit integer
\
\   K3(1 0)             Pixel x-coordinate of the centre of the sun as a 16-bit
\                       integer
\
\   K4(1 0)             Pixel y-coordinate of the centre of the sun as a 16-bit
\                       integer
\
\ ******************************************************************************

.SUN                    \ Sun with radius K
{
 LDA #1
 STA LSX                \ overlaps with LSO vector
 JSR CHKON              \ P+1 set to maxY
 BCS PLF3-3             \ jmp wpls Wipe Sun
 LDA #0                 \ fill up Acc bits based on size
 LDX K                  \ radius
 CPX #&60               \ any carry becomes low bit
 ROL A
 CPX #&28               \ 4 if K >= 40
 ROL A
 CPX #&10               \ 2 if K >= 16
 ROL A                  \ extent of fringes set

.PLF18

 STA CNT                \ bits are extent of fringes
 LDA #2*Y-1             \ 2*#Y-1 is Yscreen
 LDX P+2
 BNE PLF2               \ big height
 CMP P+1                \ is Y screen < P+1
 BCC PLF2               \ big height
 LDA P+1                \ now Acc loaded
 BNE PLF2               \ big height
 LDA #1                 \ else Acc=1 is bottom end of Yscreen

.PLF2                   \ big height

 STA TGT                \ top of screen for Y height
 LDA #2*Y-1             \ #2*Y-1 is Yscreen
 SEC                    \ subtract
 SBC K4                 \ Yorg
 TAX                    \ lo Yscreen lo
 LDA #0                 \ hi
 SBC K4+1
 BMI PLF3               \ flip height then ready to run up
 BNE PLF4               \ if Yscreen hi not zero then height is full radius
 INX
 DEX                    \ ysub lo
 BEQ PLF17              \ if ylo = 0 then ready to run up with A = #&FF
 CPX K                  \ Yscreen lo < radius ?
 BCC PLF5               \ if ylo < radius then ready to run down

.PLF4                   \ height is full radius

 LDX K                  \ counter V height is radius
 LDA #0                 \ fringe flag will run down
}

\ ******************************************************************************
\
\ Subroutine: PLF5
\
\ Xreg = height ready, Acc is flag for run direction
\
\ Other entry points:
\
\   RTS2                Contains an RTS
\
\ ******************************************************************************

.PLF5                   \ Xreg = height ready, Acc is flag for run direction
{
 STX V                  \ counter height
 STA V+1                \ flag 0 (up) or FF (down)

 LDA K
 JSR SQUA2              \ P.A =A*A unsigned
 STA K2+1               \ squared 16-bit radius hi
 LDA P                  \ lo
 STA K2                 \ squared 16-bit stored in K2
 LDY #2*Y-1             \ 2*#Y-1 is Yscreen is counter start
 LDA SUNX
 STA YY                 \ old mid-point of horizontal line
 LDA SUNX+1
 STA YY+1               \ hi

.PLFL2                  \ counter Y down erase top Disc

 CPY TGT                \ Yheight top reached?
 BEQ PLFL               \ exit to Start, Y height = TGT top
 LDA LSO,Y
 BEQ PLF13              \ if half width zero skip line drawing
 JSR HLOIN2             \ line X1,X2 using YY as mid-point, Acc is half-width

.PLF13                  \ skipped line drawing

 DEY                    \ erase top Disc
 BNE PLFL2              \ loop Y

.PLFL                   \ exited as reached Start. Y = TGT, counter V height. Work out extent

 LDA V                  \ counter height
 JSR SQUA2              \ P.A =A*A unsigned
 STA T                  \ squared height hi
 LDA K2                 \ squared 16-bit radius lo
 SEC
 SBC P                  \ height squared lo
 STA Q                  \ radius^2-height^2 lo
 LDA K2+1               \ radius^2 hi
 SBC T                  \ height squared hi
 STA R                  \ extent^2 hi
 STY Y1                 \ Y store line height
 JSR LL5                \ SQRT Q = SQR(Q,R) = sqrt(sub)
 LDY Y1                 \ restore line counter
 JSR DORND              \ do random number
 AND CNT                \ trim fringe
 CLC
 ADC Q                  \ new extent
 BCC PLF44              \ not saturated
 LDA #&FF               \ fringe max extent

.PLF44                  \ fringes not saturated

 LDX LSO,Y
 STA LSO,Y
 BEQ PLF11              \ updated extent, if zero No previous old line
 LDA SUNX
 STA YY                 \ Old mid-point of line
 LDA SUNX+1
 STA YY+1               \ hi
 TXA                    \ old lso,y half-width extent
 JSR EDGES              \ horizontal line old extent clip
 LDA X1
 STA XX                 \ old left
 LDA X2
 STA XX+1               \ old right

 LDA K3                 \ Xcenter
 STA YY                 \ new mid-point
 LDA K3+1
 STA YY+1               \ hi
 LDA LSO,Y
 JSR EDGES              \ horizontal line new extent clip
 BCS PLF23              \ No new line
 LDA X2
 LDX XX                 \ old left
 STX X2
 STA XX                 \ swopped old left and new X2 right
 JSR HLOIN              \ horizontal line X1,Y1,X2  Left fringe

.PLF23                  \ also No new line

 LDA XX                 \ old left or new right
 STA X1
 LDA XX+1               \ old right
 STA X2

.PLF16                  \ Draw New line, also from PLF11

 JSR HLOIN              \ horizontal line X1,Y1,X2  Whole old, or new Right fringe

.PLF6                   \ tail Next line

 DEY                    \ next height Y
 BEQ PLF8               \ Exit Sun fill
 LDA V+1                \ if flag already set
 BNE PLF10              \ take height counter V back up to radius K
 DEC V                  \ else counter height down
 BNE PLFL               \ loop V, Work out extent
 DEC V+1                \ finished down, set flag to go other way

.PLFLS                  \ loop back to Work out extent

 JMP PLFL               \ loop V back, Work out extent

.PLF11                  \ No previous old line at Y1 screen

 LDX K3                 \ Xcenter
 STX YY                 \ new mid-point
 LDX K3+1
 STX YY+1               \ hi
 JSR EDGES              \ horizontal line X1,Y1,X2
 BCC PLF16              \ Draw New line, up
 LDA #0                 \ else no line at height Y
 STA LSO,Y
 BEQ PLF6               \ guaranteed, tail Next line up

.PLF10                  \ V flag set to take height back up to radius K

 LDX V                  \ counter height
 INX                    \ next
 STX V
 CPX K                  \ if height < radius
 BCC PLFLS              \ loop V, Work out extent
 BEQ PLFLS              \ if height = radius, loop V, Work out extent
 LDA SUNX
 STA YY                 \ Onto remaining erase. Old mid-point of line
 LDA SUNX+1
 STA YY+1               \ hi

.PLFL3                  \ rest of counter Y screen line

 LDA LSO,Y
 BEQ PLF9               \ no fringe, skip draw line
 JSR HLOIN2             \ line X1,X2 using YY as mid-point, Acc is half-width

.PLF9                   \ skipped erase line

 DEY                    \ rest of screen
 BNE PLFL3              \ loop Y erase bottom Disc

.PLF8                   \ Exit Planet fill

 CLC                    \ update mid-point of line
 LDA K3
 STA SUNX
 LDA K3+1
 STA SUNX+1

.^RTS2

 RTS                    \ End of Sun fill
}

\ ******************************************************************************
\
\ Subroutine: CIRCLE
\
\ Circle for planet
\
\ ******************************************************************************

.CIRCLE                 \ Circle for planet
{
 JSR CHKON              \ P+1 set to maxY
 BCS RTS2               \ rts

 LDA #0
 STA LSX2

 LDX K                  \ radius
 LDA #8                 \ set up STP size based on radius
 CPX #8                 \ is radius X < 8 ?
 BCC PL89               \ small
 LSR A                  \ STP #4
 CPX #60
 BCC PL89               \ small
 LSR A                  \ bigger circles get smaller step

.PL89                   \ small

 STA STP                \ step for ring
}

\ ******************************************************************************
\
\ Subroutine: CIRCLE2
\
\ also on chart at origin (K3,K4) STP already set
\
\ Draw a circle with the centre at (K3(1 0), K4(1 0)) and radius K.
\
\ ******************************************************************************

.CIRCLE2                \ also on chart at origin (K3,K4) STP already set
{
 LDX #&FF
 STX FLAG
 INX                    \ X = 0
 STX CNT

.PLL3                   \ counter CNT  until = 64

 LDA CNT
 JSR FMLTU2             \ Get K*sin(CNT) in Acc
 LDX #0                 \ hi
 STX T
 LDX CNT                \ the count around the circle
 CPX #33                \ <= #32 ?
 BCC PL37               \ right-half of circle
 EOR #&FF               \ else Xreg = A lo flipped
 ADC #0
 TAX                    \ lo
 LDA #&FF               \ hi flipped
 ADC #0                 \ any carry
 STA T
 TXA                    \ lo flipped, later moved into K6(0,1) for BLINE x offset
 CLC

.PL37                   \ right-half of circle, Acc = xlo

 ADC K3                 \ Xorg
 STA K6                 \ K3(0) + Acc  = lsb of X for bline
 LDA K3+1               \ hi
 ADC T                  \ hi
 STA K6+1               \ K3(1) + T + C = hsb of X for bline

 LDA CNT
 CLC                    \ onto Y
 ADC #16                \ Go ahead a quarter of a quadrant for cosine index
 JSR FMLTU2             \ Get K*sin(CNT) into A
 TAX                    \ y lo =  K*sin(CNT)
 LDA #0                 \ y hi = 0
 STA T
 LDA CNT
 ADC #15                \ count +=15
 AND #63                \ round within 64
 CMP #33                \ <= 32 ?
 BCC PL38               \ if true skip y flip
 TXA                    \ Ylo
 EOR #&FF               \ flip
 ADC #0
 TAX                    \ Ylo flipped
 LDA #&FF               \ hi flipped
 ADC #0                 \ any carry
 STA T
 CLC

.PL38                   \ skipped Y flip

 JSR BLINE              \ ball line uses (X.T) as next y
 CMP #65                \ > #64?
 BCS P%+5               \ hop to exit
 JMP PLL3               \ loop CNT back
 CLC
 RTS                    \ End Circle
}

\ ******************************************************************************
\
\ Subroutine: WPLS2
\
\ Wipe Planet
\
\ ******************************************************************************

.WPLS2                  \ Wipe Planet
{
 LDY LSX2               \ 78 bytes used by bline Xcoords
 BNE WP1                \ Avoid lines down

.WPL1                   \ counter Y starts at 0

 CPY LSP
 BCS WP1                \ arc step reached, exit to Avoid lines
 LDA LSY2,Y             \ buffer Ycoords
 CMP #&FF               \ flag
 BEQ WP2                \ move into X1,Y1
 STA Y2                 \ else move into X2,Y2
 LDA LSX2,Y             \ buffer Xcoords
 STA X2
 JSR LOIN               \ draw line using (X1,Y1), (X2,Y2)
 INY                    \ next vertex
 LDA SWAP
 BNE WPL1               \ loop Y through buffer

 LDA X2                 \ else swap (X2,Y2) -> (X1,Y1)
 STA X1
 LDA Y2
 STA Y1
 JMP WPL1               \ loop Y through buffer

.WP2                    \ flagged move into X1,Y1

 INY                    \ next vertex
 LDA LSX2,Y
 STA X1
 LDA LSY2,Y
 STA Y1
 INY                    \ next vertex
 JMP WPL1               \ loop Y through buffer

.WP1                    \ Avoid lines, used by wipe planet code

 LDA #1
 STA LSP                \ arc step
 LDA #&FF
 STA LSX2
 RTS                    \ WPLS-1
}

\ ******************************************************************************
\
\ Subroutine: WPLS
\
\ Wipe Sun
\
\ ******************************************************************************

.WPLS                   \ Wipe Sun
{
 LDA LSX
 BMI WPLS-1             \ rts
 LDA SUNX
 STA YY                 \ mid-point of line lo
 LDA SUNX+1
 STA YY+1               \ hi
 LDY #2*Y-1             \ #2*Y-1 = Yscreen top

.WPL2                   \ counter Y

 LDA LSO,Y
 BEQ P%+5               \ skip hline2
 JSR HLOIN2             \ line using YY as mid-point, A is half-width
 DEY
 BNE WPL2               \ loop Y
 DEY                    \ Yreg = #&FF, solar empty
 STY LSX
 RTS
}

\ ******************************************************************************
\
\ Subroutine: EDGES
\
\ Clip Horizontal line centered on YY to X1 X2
\
\ ******************************************************************************

.EDGES                  \ Clip Horizontal line centered on YY to X1 X2
{
 STA T
 CLC                    \ trial halfwidth
 ADC YY                 \ add center of line X mid-point
 STA X2                 \ right
 LDA YY+1               \ hi
 ADC #0                 \ any carry
 BMI ED1                \ right overflow
 BEQ P%+6               \ no hsb present, hop to LDA YY
 LDA #254               \ else saturate right
 STA X2

 LDA YY                 \ center of line X mid-point
 SEC                    \ subtract trial halfwidth
 SBC T
 STA X1                 \ left
 LDA YY+1               \ hi
 SBC #0                 \ any carry
 BNE ED3                \ left underflow
 CLC                    \ else, ok draw line
 RTS                    \ X1 and X2 now known

.ED3                    \ left underflow

 BPL ED1                \ X1 left under flow, dont draw
 LDA #2                 \ else saturate left
 STA X1
 CLC                    \ ok draw line
 RTS

.ED1                    \ right overflow, also left dont draw

 LDA #0                 \ clear line buffer solar
 STA LSO,Y
 SEC                    \ dont draw
 RTS                    \ end of Clipped edges
}

\ ******************************************************************************
\
\ Subroutine: CHKON
\
\ Check extent of circles, P+1 set to maxY, Y protected.
\
\ ******************************************************************************

.CHKON                  \ check extent of circles, P+1 set to maxY, Y protected
{
 LDA K3                 \ Xorg
 CLC
 ADC K                  \ radius
 LDA K3+1               \ hi
 ADC #0
 BMI PL21               \ overflow to right, sec rts
 LDA K3                 \ Xorg
 SEC
 SBC K                  \ radius
 LDA K3+1               \ hi
 SBC #0
 BMI PL31               \ Xrange ok
 BNE PL21               \ underflow to left, sec rts

.PL31                   \ Xrange ok

 LDA K4                 \ Yorg
 CLC
 ADC K                  \ radius
 STA P+1                \ maxY = Yorg+radius
 LDA K4+1               \ hi
 ADC #0
 BMI PL21               \ overflow top, sec rts
 STA P+2                \ maxY hi
 LDA K4                 \ Yorg
 SEC
 SBC K                  \ radius
 TAX                    \ bottom lo
 LDA K4+1               \ hi
 SBC #0
 BMI PL44               \ ok to draw, clc
 BNE PL21               \ bottom underflowed, sec rts
 CPX #2*Y-1             \ #2*Y-1, bottom Ylo >= screen Ytop?
 RTS
}

\ ******************************************************************************
\
\ Subroutine: PL21
\
\ dont draw
\
\ ******************************************************************************

.PL21                   \ dont draw
{
 SEC
 RTS
}

\ ******************************************************************************
\
\ Subroutine: PLS3
\
\ Only Crater uses this, A.Y = 222* INWK(X+=2)/INWK_z
\
\ ******************************************************************************

.PLS3                   \ only Crater uses this, A.Y = 222* INWK(X+=2)/INWK_z
{
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 STA P
 LDA #222               \ offset to crater, divide/256 * unit to offset crater center
 STA Q
 STX U                  \ store index
 JSR MULTU              \ P.A = P*Q = 222* INWK(X+=2)/INWK_z
 LDX U                  \ restore index
 LDY K+3                \ sign
 BPL PL12               \ +ve
 EOR #&FF               \ else flip A hi
 CLC
 ADC #1
 BEQ PL12               \ +ve
 LDY #&FF               \ else A flipped
 RTS

.PL12                   \ +ve

 LDY #0
 RTS
}

\ ******************************************************************************
\
\ Subroutine: PLS4
\
\ CNT2 = angle of P_opp/A_adj for Lave
\
\ ******************************************************************************

.PLS4                   \ CNT2 = angle of P_opp/A_adj for Lave
{
 STA Q
 JSR ARCTAN             \ A=arctan (P/Q)
 LDX INWK+14            \ nosev_z hi
 BMI P%+4               \ -ve nosev_z hi keeps arctan +ve
 EOR #128               \ else arctan -ve
 LSR A
 LSR A                  \ /4
 STA CNT2               \ phase offset
 RTS
}

\ ******************************************************************************
\
\ Subroutine: PLS5
\
\ Mag K2+2,3 sign XX16+2,3  = NWK(X+=2)/INWK_z for Lave
\
\ ******************************************************************************

.PLS5                   \ mag K2+2,3 sign XX16+2,3  = NWK(X+=2)/INWK_z for Lave
{
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 STA K2+2               \ mag
 STY XX16+2             \ sign
 JSR PLS1               \ A.Y = INWK(X+=2)/INWK_z
 STA K2+3               \ mag
 STY XX16+3             \ sign
 RTS
}

\ ******************************************************************************
\
\ Subroutine: PLS6
\
\ Visited from PROJ \ Klo.Xhi = P.A/INWK_z, C set if big
\
\ ******************************************************************************

.PLS6                   \ visited from PROJ \ Klo.Xhi = P.A/INWK_z, C set if big
{
 JSR DVID3B2            \ divide 3bytes by 2, K = P(2).A/INWK_z
 LDA K+3
 AND #127               \ sg 7bits
 ORA K+2
 BNE PL21               \ sec rts as too far off
 LDX K+1
 CPX #4                 \ hi >= 4 ? ie >= 1024
 BCS PL6                \ rts as too far off
 LDA K+3                \ sign
\CLC
 BPL PL6                \ rts C clear ok
 LDA K                  \ else flip K lo
 EOR #&FF
 ADC #1                 \ flipped lo
 STA K
 TXA                    \ K+1
 EOR #&FF               \ flip hi
 ADC #0
 TAX                    \ X = K+1 hi flipped
}

\ ******************************************************************************
\
\ Subroutine: PL44
\
\ ok to draw
\
\ ******************************************************************************

.PL44                   \ ok to draw
{
 CLC
}

\ ******************************************************************************
\
\ Subroutine: PL6
\
\ End of Planet, onto keyboard block E ---
\
\ ******************************************************************************

.PL6
{
 RTS                    \ end of Planet, onto keyboard block E ---
}

\ ******************************************************************************
\
\ Subroutine: TT17
\
\ Scan the keyboard and joystick for cursor key or stick movement, and return
\ the result as deltas (changes) in x- and y-coordinates as follows:
\
\   * For joystick, X and Y are integers between -2 and +2 depending on how far
\     the stick has moved
\
\   * For keyboard, X and Y are integers between -1 and +1 depending on which
\     keys ar pressed
\
\ Returns:
\
\   A                   The key pressed, if the arrow keys were used
\
\   X                   Change in the x-coordinate according to the cursor keys
\                       being pressed or joystick movement, as an integer (see
\                        above)
\
\   Y                   Change in the y-coordinate according to the cursor keys
\                       being pressed or joystick movement, as an integer (see
\                       above)
\
\ ******************************************************************************

.TT17
{
 JSR DOKEY              \ Scan the keyboard for flight controls and pause keys,
                        \ (or the equivalent on joystick) and update the key
                        \ logger, setting KL to the key pressed

 LDA JSTK               \ If the joystick was not used, jump down to TJ1,
 BEQ TJ1                \ otherwise we move the cursor with the joystick

 LDA JSTX               \ Fetch the joystick roll, ranging from 1 to 255 with
                        \ 128 as the centre point

 EOR #&FF               \ Flip the sign so A = -JSTX, because the joystick roll
                        \ works in the opposite way to moving a cursor on screen
                        \ in terms of left and right

 JSR TJS1               \ Call TJS1 just below to set Y to a value between -2
                        \ and +2 depending on the joystick roll value (moving
                        \ the stick sideways)

 TYA                    \ Copy Y to A and X
 TAX

 LDA JSTY               \ Fetch the joystick pitch, ranging from 1 to 255 with
                        \ 128 as the centre point, and fall through into TJS1 to
                        \ joystick pitch value (moving the stick up and down)

.TJS1

 TAY                    \ Store A in Y

 LDA #0                 \ Set the result, A = 0

 CPY #&10               \ If Y >= &10 set carry, so A = A - 1
 SBC #0

\CPY #&20               \ These instructions are commented out in the original
\SBC #0                 \ source, but they would make the joystick move the
                        \ cursor faster by increasing the range of Y by -1 to +1

 CPY #&40               \ If Y >= &40 set carry, so A = A - 1
 SBC #0

 CPY #&C0               \ If Y >= &C0 set carry, so A = A + 1
 ADC #0

 CPY #&E0               \ If Y >= &E0 set carry, so A = A + 1
 ADC #0

\CPY #&F0               \ These instructions are commented out in the original
\ADC #0                 \ source, but they would make the joystick move the
                        \ cursor faster by increasing the range of Y by -1 to +1

 TAY                    \ Copy the value of A into Y

 LDA KL                 \ Set A to the value of KL (the key pressed)

 RTS                    \ Return from the subroutine

.TJ1                    \ Arrows from keyboard

 LDA KL                 \ Set A to the value of KL (the key pressed)

 LDX #0                 \ Set the results, X = Y = 0
 LDY #0

 CMP #&19               \ If left arrow was pressed, set X = X - 1
 BNE P%+3
 DEX

 CMP #&79               \ If right arrow was pressed, set X = X + 1
 BNE P%+3
 INX

 CMP #&39               \ If up arrow was pressed, set Y = Y + 1
 BNE P%+3
 INY

 CMP #&29               \ If down arrow was pressed, set Y = Y - 1
 BNE P%+3
 DEY

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: ping
\
\ Set the selected system to the current system.
\
\ ******************************************************************************

.ping
{
 LDX #1                 \ We want to copy the X- and Y-coordinates of the
                        \ current system in (QQ0, QQ1) to the selected system's
                        \ coordinates in (QQ9, QQ10), so set up a counter to
                        \ copy two bytes

.pl1

 LDA QQ0,X              \ Load byte X from the current system in QQ0/QQ1

 STA QQ9,X              \ Store byte X in the selected system in QQ9/QQ10

 DEX                    \ Decrement the loop counter

 BPL pl1                \ Loop back for the next byte to copy

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Save output/ELTE.bin
\
\ ******************************************************************************

PRINT "ELITE E"
PRINT "Assembled at ", ~CODE_E%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_E%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_E%

PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
SAVE "output/ELTE.bin", CODE_E%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE F
\
\ Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_F% = P%
LOAD_F% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\ Subroutine: KS3
\
\ The final part of the KILLSHP routine, called after we have shuffled the ship
\ slots and sorted out our missiles. This simply sets SLSP to the new bottom of
\ the ship heap space.
\
\ Arguments:
\
\   P(1 0)              Points to the heap space of the ship in the last
\                       occupied slot (i.e. it points to the bottom of the
\                       descending heap)
\
\ ******************************************************************************

.KS3
{
 LDA P                  \ After shuffling the ship slots, P(1 0) will point to
 STA SLSP               \ the new bottom of the ship heap, so store this in
 LDA P+1                \ SLSP(1 0), which stores the bottom of the heap
 STA SLSP+1

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: KS1
\
\ Part 12 of the main flight loop calls this routine to remove the ship that is
\ currently being analysed by the flight loop. Once the ship is removed, it
\ jumps back to MAL1 to rejoin the main flight loop, with X pointing to the same
\ slot that we just cleared (and which now contains the next ship in the local
\ bubble of universe).
\
\ Arguments:
\
\   XX0                 The address of the blueprint for this ship
\
\   INF                 The address of the data block for this ship
\
\ ******************************************************************************

.KS1
{
 LDX XSAV               \ Store the current ship's slot number in XSAV

 JSR KILLSHP            \ Call KILLSHP to remove the ship in slot X from our
                        \ little bubble of universe

 LDX XSAV               \ Restore the current ship's slot number from XSAV,
                        \ which now points to the next ship in the bubble

 JMP MAL1               \ Jump to MAL1 to rejoin the main flight loop at the
                        \ start of the ship analysis loop
}

\ ******************************************************************************
\
\ Subroutine: KS4
\
\ Removing the space station from our local bubble of universe, and replace it
\ with the sun.
\
\ ******************************************************************************

.KS4
{
 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 JSR FLFLLS             \ Reset the LSO block, returns with A = 0

 STA FRIN+1             \ Set the second slot in the FRIN table to 0, which
                        \ sets this slot to empty, so when we call NWSHP below
                        \ the new sun that gets created will go into FRIN+1

 STA SSPR               \ Set the "space station present" flag to 0, as we are
                        \ no longer in the space station's safe zone

 JSR SPBLB              \ Call SPBLB to redraw the space station bulb, which
                        \ will erase it from the dashboard

 LDA #6                 \ Set the sun's y_sign to 6
 STA INWK+5

 LDA #129               \ Set A = 129, the "ship" type for the sun

 JMP NWSHP              \ Call NWSHP to set up the sun's data block and add it
                        \ to FRIN, where it will get put in the second slot as
                        \ we just cleared out the second slot, and the first
                        \ slot is already taken by the planet
}

\ ******************************************************************************
\
\ Subroutine: KS2
\
\ Check the local bubble of universe to see if there are any missiles with
\ target lock in the vicinity. If there are, then check their targets; if we
\ just removed their target in the KILLSHP routine, then switch off their AI so
\ they just drift in space, otherwise update their targets to reflect the newly
\ shuffled slot numbers.
\
\ This is called from KILLSHP once the slots have been shuffled down, following
\ the removal of a ship.
\
\ Arguments:
\
\   XX4                 The slot number of the ship we removed just before
\                       calling this routine
\
\ ******************************************************************************

.KS2
{
 LDX #&FF               \ We want to go through the ships in our local bubble
                        \ and pick out all the missiles, so set X to &FF to
                        \ use as a counter

.KSL4

 INX                    \ Increment the counter (so it starts at 0 on the first
                        \ iteration)

 LDA FRIN,X             \ If slot X is empty, loop round again until it isn't,
 BEQ KS3                \ at which point A contains the ship type in that slot

 CMP #MSL               \ If the slot does not contain a missile, loop back to
 BNE KSL4               \ KSL4 to check the next slot

                        \ We have found a slot containing a missile, so now we
                        \ want to check whether it has target lock

 TXA                    \ Set Y = X * 2 and fetch the Y-th address from UNIV
 ASL A                  \ and store it in SC and SC+1 - in other words, set
 TAY                    \ SC(1 0) to point to the missile's ship data block
 LDA UNIV,Y
 STA SC
 LDA UNIV+1,Y
 STA SC+1

 LDY #32                \ Fetch byte #32 from the missile's ship data (AI)
 LDA (SC),Y

 BPL KSL4               \ If bit 7 of byte #32 is clear, then the missile is
                        \ dumb and has no AI, so loop back to KSL4 to move on
                        \ to the next slot

 AND #%01111111         \ Otherwise this missile has AI, so clear bit 7 and
 LSR A                  \ shift right to set the C flag to the missile's "is
                        \ locked" flag, and A to the target's slot number

 CMP XX4                \ If this missile's target is less than XX4, then the
 BCC KSL4               \ target's slot isn't being shuffled down, so jump to
                        \ KSL4 to move on to the next slot

 BEQ KS6                \ If this missile was locked onto the ship that we just
                        \ removed in KILLSHP, jump to KS6 to stop the missile
                        \ from continuing to hunt it down

 SBC #1                 \ Otherwise this missile is locked and has AI enabled,
                        \ and its target will have moved down a slot, so
                        \ subtract 1 from the target number (we know C is set
                        \ from the BCC above)

 ASL A                  \ Shift the target number left by 1, so it's in bits
                        \ 1-6 once again, and also set bit 0 to 1, as the C
                        \ flag is still set, so this makes sure the missile is
                        \ still set to being locked

 ORA #%10000000         \ Set bit 7, so the missile's AI is enabled

 STA (SC),Y             \ Update the missile's AI flag to the value in A

 BNE KSL4               \ Loop back to KSL4 to move on to the next slot (this
                        \ BNE is effectively a JMP as A will never be zero)

.KS6

 LDA #0                 \ The missile's target lock just got removed, so set the
 STA (SC),Y             \ AI flag to 0 to make it dumb and not locked

 BEQ KSL4               \ Loop back to KSL4 to move on to the next slot (this
                        \ BEQ is effectively a JMP as A is always zero)
}

\ ******************************************************************************
\
\ Subroutine: KILLSHP
\
\ Remove the ship in slot X from our little bubble of universe. This happens
\ when we kill a ship, collide with a ship and destroy it, or when a ship moves
\ outside our little bubble.
\
\ We also use this routine when we move out of range of the space station, in
\ which case we replace it with the sun.
\
\ When removing a ship, this creates a gap in the ship slots at FRIN, so we
\ shuffle all the later slots down to close the gap. We also shuffle the ship
\ data blocks at K% and ship lines heap at WP, to reclaim all the memory that
\ the removed ship used to occupy.
\
\ Arguments:
\
\   X                   The slot number of the ship to remove
\
\   XX0                 The address of the blueprint for the ship to remove
\
\   INF                 The address of the data block for the ship to remove
\
\ ******************************************************************************

.KILLSHP
{
 STX XX4                \ Store the slot number of the ship to remove in XX4

                        \ The following two instructions appear in the BASIC
                        \ source file (ELITEF), but in the text source file
                        \ (ELITEF.TXT) they are replaced by:
                        \
                        \   CPX MSTG
                        \
                        \ which does the same thing, but saves two bytes of
                        \ memory (as CPX MSTG is a two-byte opcode, while LDA
                        \ MSTG and CMP XX4 take up four bytes between them)

 LDA MSTG               \ Check whether this slot matches the slot number in
 CMP XX4                \ MSTG, which is the target of our missile lock

 BNE KS5                \ If our missile is not locked on this ship, jump to KS5

 LDY #&EE               \ Otherwise we need to remove our missile lock, so call
 JSR ABORT              \ ABORT to disarm the missile and update the missile
                        \ indicators on the dashboard to green/cyan (Y = &EE)

 LDA #200               \ Print recursive token 40 ("TARGET LOST") as an
 JSR MESS               \ in-flight message

.KS5

 LDY XX4                \ Restore the slot number of the ship to remove into Y

 LDX FRIN,Y             \ Fetch the contents of the slot, which contains the
                        \ ship type

 CPX #SST               \ If this is the space station, then jump to KS4 to
 BEQ KS4                \ replace the space station with the sun

 DEC MANY,X             \ Decrease the number of this type of ship in our little
                        \ bubble, which is stored in MANY+X (where X is the ship
                        \ type)

 LDX XX4                \ Restore the slot number of the ship to remove into X

                        \ We now want to remove this ship and reclaim all the
                        \ memory that it uses. Removing the ship will leave a
                        \ gap in three places, which we need to close up:
                        \
                        \   * The ship slots in FRIN
                        \
                        \   * The ship data blocks in K%
                        \
                        \   * The descending ship lines heap space at WP down
                        \
                        \ The rest of this routine closes up these gaps by
                        \ looping through all the occupied ship slots after the
                        \ slot we are removing, one by one, and shuffling each
                        \ ship's slot, data block and heap space down to close
                        \ up the gaps left by the removed ship. As part of this,
                        \ we have to make sure we update any address pointers
                        \ so they point to the newly shuffled data blocks and
                        \ heap space
                        \
                        \ In the following, when shuffling a ship's data down
                        \ into the preceding empty slot, we call the ship that
                        \ we are shuffling down the "source", and we call the
                        \ empty slot we are shuffling it into the "destination"
                        \
                        \ Before we start looping through the ships we need to
                        \ shuffle down, we need to set up some variables to
                        \ point to the source and destination heap spaces

 LDY #5                 \ Fetch byte #5 of the removed ship's blueprint into A,
 LDA (XX0),Y            \ which gives the ship's maximum heap size for the ship
                        \ we are removing (i.e. the size of the gap in the heap
                        \ created by the ship removal)

                        \ INF currently contains the ship data for the ship we
                        \ are removing, and INF(34 33) contains the address of
                        \ the bottom of the ship's heap, so we can calculate
                        \ the address of the top of the heap by adding the heap
                        \ size to this address

 LDY #33                \ First we add A and the address in INF+33, to get the
 CLC                    \ low byte of the top of the heap, which we store in P
 ADC (INF),Y
 STA P

 INY                    \ And next we add A and address in INF+34, with any
 LDA (INF),Y            \ from the previous addition, to get the high byte of
 ADC #0                 \ the top of the heap, which we store in P+1, so P(1 0)
 STA P+1                \ points to the top of this ship's heap

                        \ Now, we're ready to start looping through the ships
                        \ we want to move, moving the slots, data blocks and
                        \ heap space from the source to the destination. In the
                        \ following, we set up SC to point to the source data,
                        \ and INF (which currently points to the removed ship's
                        \ data that we can now overwrite) points to the
                        \ destination
                        \
                        \ So P(1 0) now points to the top of the heap space for
                        \ the destination

.KSL1

 INX                    \ On entry, X points to the empty slot we want to
                        \ shuffle the next ship into (the destination), so
                        \ this increment points X to the next slot - i.e. the
                        \ source slot we want to shuffle down

 LDA FRIN,X             \ Copy the contents of the source slot into the
 STA FRIN-1,X           \ destination slot

 BEQ KS2                \ If the slot we just shuffled down contains 0, then
                        \ the source slot is empty and we are done shuffling,
                        \ so jump to KS2 to move on to processing missiles

 ASL A                  \ Otherwise we have a source ship to shuffle down into
 TAY                    \ the destination, so set Y = A * 2 so it can act as an
                        \ index into the two-byte ship blueprint lookup table
                        \ at XX21 for the source ship

 LDA XX21-2,Y           \ Set SC(0 1) to point to the blueprint data for the
 STA SC                 \ source ship
 LDA XX21-1,Y
 STA SC+1

 LDY #5                 \ Fetch blueprint byte #5 for the source ship, which
 LDA (SC),Y             \ gives us its maximum heap size, and store it in T
 STA T

                        \ We now subtract T from P(1 0), so P(1 0) will point to
                        \ the bottom of the heap space for the destination
                        \ (which we will use later when closing up the gap in
                        \ the heap space)

 LDA P                  \ First, we subtract the low bytes
 SEC
 SBC T
 STA P

 LDA P+1                \ And then we do the high bytes, for which we subtract
 SBC #0                 \ 0 to include any carry, so this is effectively doing
 STA P+1                \ P(1 0) = P(1 0) - (0 T)

                        \ Next, we want to set SC(1 0) to point to the source
                        \ ship's data block

 TXA                    \ Set Y = X * 2 so it can act as an index into the
 ASL A                  \ two-byte lookup table at UNIV, which contains the
 TAY                    \ addresses of the ship data blocks. In this case we are
                        \ multiplying X by 2, and X contains the source ship's
                        \ slot number so Y is now an index for the source ship's
                        \ entry in UNIV

 LDA UNIV,Y             \ Set SC(1 0) to the address of the data block for the
 STA SC                 \ source ship
 LDA UNIV+1,Y
 STA SC+1

                        \ We have now set up our variables as follows:
                        \
                        \   SC(1 0) points to the source's ship data block
                        \
                        \   INF(1 0) points to the destination's ship data block
                        \
                        \   P(1 0) points to the destination's heap space
                        \
                        \ so let's start copying data from the source to the
                        \ destination

 LDY #35                \ We are going to be using Y as a counter for the 36
                        \ bytes of ship data we want to copy from the source
                        \ to the destination, so we set it to 35 to start things
                        \ off, and will decrement Y for each byte we copy

 LDA (SC),Y             \ Fetch byte #35 of the source's ship data block at SC,
 STA (INF),Y            \ and store it in byte #35 of the destination's block
                        \ at INF, so that's the ship's energy copied from the
                        \ source to the destination. One down, quite a few to
                        \ go...

 DEY                    \ Fetch byte #34 of the source ship, which is the
 LDA (SC),Y             \ high byte of the source ship's heap space, and store
 STA K+1                \ in K+1

 LDA P+1                \ Set the low byte of the destination's heap pointer
 STA (INF),Y            \ to P+1

 DEY                    \ Fetch byte #33 of the source ship, which is the
 LDA (SC),Y             \ low byte of the source ship's heap, and store in K
 STA K                  \ so now we have the following:
                        \
                        \   K(1 0) points to the source's heap space

 LDA P                  \ Set the low byte of the destination's heap pointer
 STA (INF),Y            \ to P, so now the destination's heap pointer is to
                        \ P(1 0), so that's the heap pointer in bytes #33 and
                        \ #34 done

 DEY                    \ Luckily, we can just copy the rest of the source's
                        \ ship data block into the destination, as there are no
                        \ more address pointers, so first we decrement our
                        \ counter in Y to point to the next byte (the AI flag)
                        \ in byte #32) and then start looping

.KSL2

 LDA (SC),Y             \ Copy the Y-th byte of the source to the Y-th byte of
 STA (INF),Y            \ the destination

 DEY                    \ Decrement the counter

 BPL KSL2               \ Loop back to KSL2 to copy the next byte until we have
                        \ copied the whole block

                        \ We have now shuffled the ship's slot and the ship's
                        \ data block, so we only have the heap data itself to do

 LDA SC                 \ First, we copy SC into INF, so when we loop round again,
 STA INF                \ INF will correctly point to the destination for the next
 LDA SC+1               \ iteration
 STA INF+1

 LDY T                  \ Now we want to move the contents of the heap, as all
                        \ we did above was to update the pointers, so first
                        \ we set a counter in Y that is initially set to T
                        \ (which we set above to the maximum heap size for the
                        \ source ship)
                        \
                        \ As a reminder, we have already set the following:
                        \
                        \   K(1 0) points to the source's heap space
                        \
                        \   P(1 0) points to the destination's heap space
                        \
                        \ so we can move the heap data by simply copying the
                        \ correct number of bytes from K(1 0) to P(1 0)
.KSL3

 DEY                    \ Decrement the counter

 LDA (K),Y              \ Copy the Y-th byte of the source heap at K(1 0) to
 STA (P),Y              \ the destination heap at P(1 0)

 TYA                    \ Loop back to KSL3 to copy the next byte, until we
 BNE KSL3               \ have done them all

 BEQ KSL1               \ We have now shuffled everything down one slot, so
                        \ jump back up to KSL1 to see if there is another slot
                        \ that needs shuffling down (this BEQ is effectively a
                        \ JMP as A will always be zero)

}

\ ******************************************************************************
\
\ Variable: SFX
\
\ Sound data. To make a sound, the NOS1 routine copies the four relevant sound
\ bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
\ the table, and are always multiples of 8. Generally, sounds are made by
\ calling the NOISE routine with the sound number in A.
\
\ These bytes are passed to OSWORD 7, and are the equivalents to the parameters
\ passed to the SOUND keyword in BASIC. The parameters therefore have these
\ meanings:
\
\   channel/flush, amplitude (or envelope number if 1-4), pitch, duration
\
\ For the channel/flush parameter, the first byte is the channel while the
\ second is the flush control (where a flush control of 0 queues the sound,
\ while a flush control of 1 makes the sound instantly). When written in
\ hexadecimal, the first figure gives the flush control, while the second is
\ the channel (so &13 indicates flush control = 1 and channel = 3).
\
\ So when we call NOISE with A = 40 to make a long, low beep, then this is
\ effectively what the NOISE routine does:
\
\   SOUND &13, &F4, &0C, &08
\
\ which makes a sound with flush control 1 on channel 3, and with amplitude &F4
\ (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
\ sound, the NOISE routine does this:
\
\   SOUND &10, &02, &60, &10
\
\ which makes a sound with flush control 1 on channel 0, using envelope 2,
\ and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
\ are set up in elite-loader.asm.
\
\ ******************************************************************************

.SFX
{
 EQUB &12,&01,&00,&10   \ 0  - Lasers fired by us
 EQUB &12,&02,&2C,&08   \ 8  - We're being hit by lasers
 EQUB &11,&03,&F0,&18   \ 16 - We died 1 / We made a hit or kill 2
 EQUB &10,&F1,&07,&1A   \ 24 - We died 2 / We made a hit or kill 1
 EQUB &03,&F1,&BC,&01   \ 32 - Short, high beep
 EQUB &13,&F4,&0C,&08   \ 40 - Long, low beep
 EQUB &10,&F1,&06,&0C   \ 48 - Missile launched / Ship launched from station
 EQUB &10,&02,&60,&10   \ 56 - Hyperspace drive engaged
 EQUB &13,&04,&C2,&FF   \ 64 - E.C.M. on
 EQUB &13,&00,&00,&00   \ 72 - E.C.M. off
}

\ ******************************************************************************
\
\ Subroutine: RESET
\
\ Reset our ship and various controls, then fall through into RES4 to restore
\ shields and energy, and reset the stardust and the ship workspace at INWK.
\
\ In this subroutine, this means zero-filling the following locations:
\
\   * Pages &9, &A, &B, &C and &D
\
\   * BETA to BETA+6, which covers the following:
\
\     * BETA, BET1 - Set pitch to 0
\
\     * XC, YC - Set text cursor to (0, 0)
\
\     * QQ22 - Set hyperspace counters to 0
\
\     * ECMA - Turn E.C.M. off
\
\ It also sets QQ12 to &FF, to indicate we are docked, and then falls through
\ into RES4.
\
\ ******************************************************************************

.RESET
{
 JSR ZERO               \ Zero-fill pages &9, &A, &B, &C and &D

 LDX #6                 \ Set up a counter for zeroing BETA through BETA+6

.SAL3

 STA BETA,X             \ Zero the X-th byte after BETA

 DEX                    \ Decrement the loop counter

 BPL SAL3               \ Loop back for the next byte to zero

 STX QQ12               \ X is now negative - i.e. &FF - so this sets QQ12 to
                        \ &FF to indicate we are docked

                        \ Fall through into RES4 to restore shields and energy,
                        \ and reset the stardust and ship workspace at INWK
}

\ ******************************************************************************
\
\ Subroutine: RES4
\
\ Reset the shields and energy banks, then fall through into RES2 to reset the
\ stardust and the ship workspace at INWK.
\
\ ******************************************************************************

.RES4
{
 LDA #&FF               \ Set A to &FF so we can fill up the shields and energy
                        \ bars with a full charge

 LDX #2                 \ The two shields and energy bank levels are stored in
                        \ three consecutive bytes, at FSH through FSH+2, so set
                        \ up a counter in X to index these three bytes

.REL5

 STA FSH,X              \ Set the X-th byte in the FSH block to &FF

 DEX                    \ Decrement the loop counter

 BPL REL5               \ Loop back to do the next byte, until we have done
                        \ all three

                        \ Fall through into RES2 to reset stardust and INWK
}

\ ******************************************************************************
\
\ Subroutine: RES2
\
\ Reset a number of flight variables and workspaces.
\
\ This is called after we launch from a space station, arrive in a new system
\ after hyperspace, launch an escape pod, or die a cold, lonely death in the
\ depths of space.
\
\ Returns:
\
\   Y                   Y is set to &FF
\
\ ******************************************************************************

.RES2
{
 LDA #NOST              \ Reset NOSTM, the number of stardust particles, to the
 STA NOSTM              \ maximum allowed (18)

 LDX #&FF               \ Reset LSX2 and LSY2, the buffers used by the BLINE
 STX LSX2               \ routine for drawing the planet's ball line, to &FF
 STX LSY2

 STX MSTG               \ Reset MSTG, the missile target, to &FF (no target)

 LDA #128               \ Set the current pitch rate to the mid-point, 128
 STA JSTY

 STA ALP2               \ Reset ALP2 (flipped roll sign) and BET2 (pitch sign)
 STA BET2               \ to negative, i.e. roll positive, pitch negative

 ASL A                  \ This sets A to 0

 STA ALP2+1             \ Reset ALP2+1 (roll sign) and BET2+1 (flipped pitch
 STA BET2+1             \ sign) to positive, i.e. roll positive, pitch negative

 STA MCNT               \ Reset MCNT (move count) to 0

 LDA #3                 \ Reset DELTA (speed) to 3
 STA DELTA

 STA ALPHA              \ Reset ALPHA (flipped reduced roll rate) to 3

 STA ALP1               \ Reset ALP1 (reduced roll rate) to 3

 LDA SSPR               \ Fetch the "space station present" flag, and if we are
 BEQ P%+5               \ not inside the safe zone, skip the next instruction

 JSR SPBLB              \ Light up the space station bulb on the dashboard

 LDA ECMA               \ Fetch the E.C.M. status flag, and if E.C.M. is off,
 BEQ yu                 \ skip the next instruction

 JSR ECMOF              \ Turn off the E.C.M. sound

.yu

 JSR WPSHPS             \ Wipe all ships from the scanner

 JSR ZERO               \ Zero-fill pages &9, &A, &B, &C and &D

 LDA #LO(WP-1)          \ Reset the ship lines pointer to be empty, so point
 STA SLSP               \ SLSP to the byte before the WP workspace
 LDA #HI(WP-1)
 STA SLSP+1

 JSR DIALS              \ Update the dashboard

                        \ Finally, fall through into ZINF to reset the INWK
                        \ ship workspace
}

\ ******************************************************************************
\
\ Subroutine: ZINF
\
\ Zero-fill the INWK ship workspace and reset the orientation vectors.
\
\ Returns:
\
\   Y                   Y is set to &FF
\
\ ******************************************************************************

.ZINF
{
 LDY #NI%-1             \ There are NI% bytes in the INWK workspace, so set a
                        \ counter in Y so we can loop through them

 LDA #0                 \ Set A to 0 so we can zero-fill the workspace

.ZI1

 STA INWK,Y             \ Zero the Y-th byte of the INWK workspace

 DEY                    \ Decrement the loop counter

 BPL ZI1                \ Loop back for the next byte, ending when we have
                        \ zero-filled the last byte at INWK, which leaves Y
                        \ with a value of &FF

                        \ Finally, we reset the orientation vectors as follows:
                        \
                        \   nosev = (0,  0, -1)
                        \   roofv = (0,  1,  0)
                        \   sidev = (1,  0,  0)
                        \
                        \ &6000 represents 1 in the orientation vectors, while
                        \ &E000 represents -1. We already set the vectors to
                        \ zero above, so we just need to set up the diagonal
                        \ values and we're done

 LDA #&60               \ Set A to represent a 1

 STA INWK+18            \ Set INWK+18 = roofv_y_hi = &60 = 1
 STA INWK+22            \ Set INWK+22 = sidev_x_hi = &60 = 1

 ORA #128               \ Flip the sign of A to represent a -1

 STA INWK+14            \ Set INWK+14 = nosev_z_hi = &E0 = -1

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: msblob
\
\ Display the dashboard's missile indicators, with all the missiles reset to
\ green/cyan (i.e. not armed or locked).
\
\ ******************************************************************************

.msblob
{
 LDX #4                 \ Set up a loop counter in X to count through all four
                        \ missile indicators

.ss

 CPX NOMSL              \ If the counter is equal to the number of missiles,
 BEQ SAL8               \ jump down to SQL8 to draw remaining the missiles, as
                        \ the rest of them are present and should be drawn in
                        \ green/cyan

 LDY #0                 \ Draw the missile indicator at position X in black
 JSR MSBAR

 DEX                    \ Decrement the counter to point to the next missile

 BNE ss                 \ Loop back to ss if we stil have missiles to draw

 RTS                    \ Return from the subroutine

.SAL8

 LDY #&EE               \ Draw the missile indicator at position X in green/cyan
 JSR MSBAR

 DEX                    \ Decrement the counter to point to the next missile

 BNE SAL8               \ Loop back to SAL8 if we stil have missiles to draw

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: me2
\
\ Remove an in-flight message from the space view.
\
\ ******************************************************************************

.me2
{
 LDA MCH                \ Fetch the token number of the current message into A

 JSR MESS               \ Call MESS to print the token, which will remove it
                        \ from the screen as printing uses EOR logic

 LDA #0                 \ Set the delay in DLY to 0, so any new in-flight
 STA DLY                \ messages will be shown instantly

 JMP me3                \ Jump back into the main spawning loop at TT100
}

\ ******************************************************************************
\
\ Subroutine: Ze
\
\ Initialise INWK to a hostile ship. Specifically:
\
\   * Reset the INWK ship workspace
\
\   * Set the ship to a fair distance away (32) in all axes, in front of us but
\     randomly up or down, left or right
\
\   * Give the ship a 4% chance of having E.C.M.
\
\   * Set the ship to hostile, with AI enabled
\
\ Also sets X and T1 to a random value, and A to a random value between 192 and
\ 255,and the C flag randomly.
\
\ ******************************************************************************

.Ze
{
 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 JSR DORND              \ Set A and X to random numbers

 STA T1                 \ Store A in T1

 AND #%10000000         \ Extract the sign of A and store in x_sign
 STA INWK+2

 TXA                    \ Extract the sign of X and store in y_sign
 AND #%10000000
 STA INWK+5

 LDA #32                \ Set x_hi = y_hi = z_hi = 32, a fair distance away
 STA INWK+1
 STA INWK+4
 STA INWK+7

 TXA                    \ Set the C flag if X >= 245 (4% chance)
 CMP #245

 ROL A                  \ Set bit 0 of A to the C flag (i.e. there's a 4%
                        \ chance of this ship having E.C.M.)

 ORA #%11000000         \ Set bits 6 and 7 of A, so the ship is hostile (bit 6
                        \ and has AI (bit 7)

 STA INWK+32            \ Store A in the AI flag of this ship
}

\ ******************************************************************************
\
\ Subroutine: DORND2
\
\ A version of DORND that restricts the value of r2 so that bit 0 is always 0.
\ Having C cleared changes the calculations in DORND to:
\
\   r2 = ((r0 << 1) mod 256)
\   r0 = r2 + r2 + bit 7 of r0
\
\ so r2 always has bit 0 cleared, i.e. r2 is always a multiple of 2.
\
\ ******************************************************************************

.DORND2
{
 CLC                    \ This ensures that bit 0 of r2 is 0
}

\ ******************************************************************************
\
\ Subroutine: DORND
\
\ Set A and X to random numbers. Carry flag is also set randomly. Overflow flag
\ will be have a 50% probability of being 0 or 1.
\
\ There are two calculations of two 8-bit numbers in this routine. The first
\ pair is at RAND and RAND+2 (let's call them r0 and r2) and the second pair
\ is at RAND+1 and RAND+3 (let's call them r1 and r3).
\
\ The values of r0 and r2 are not read by any other routine apart from this
\ one, so they are effectively internal to the random number generation
\ routine. r1 and r3, meanwhile, are returned in A and X with each call to
\ DORND, and along with the returned values of the C and V flags, form the
\ the random results we're looking for.
\
\ The seeds are overwritten in three places:
\
\   * All four locations are updated by EXL2, using a STA &FFFD,Y instruction
\     with Y = 2, 3, 4, 5 (so this points the write to zero page location &00,
\     which is where RAND is located, in the first four bytes of memory).
\
\  * r0 is written to at the start of M% in the main loop, to seed the random
\    number generator. Here, r0 is set to the first byte of the ship data block
\    at K% (x_lo for the first ship at K%).
\
\  * r3 is written to in EX4 as part of the explosion routine, with r3 being
\    set to the seventh byte of the ship data block at K%+6 (z_lo for the
\    first ship at K%).
\
\ r0 and r2 follow the following sequence through successive calls to DORND,
\ going from r0 and r2 to r0 and r2 with each call:
\
\   r2 = ((r0 << 1) mod 256) + C
\   r0 = r2 + r2 + bit 7 of r0
\
\ C is the carry flag on entry. If this routine is entered with the carry flag
\ clear, e.g. via DORND2, then if bit 0 of RAND+2 is 0, it will remain at 0.
\
\ r1 and r3 (which are returned in A and X) follow this number sequence through
\ successive calls to DORND, going from r1 and r3 to r1 and r3:
\
\   A = r1 = r1 + r3 + C
\   X = r3 = r1
\
\ C is the carry flag from the calculation of r0 above, i.e. from the addition
\ of r2 with r2 and bit 7 of r0. Because r3 is set to r1, this can be thought
\ of as a number sequence, with A being the next number in the sequence and X
\ being the value of A from the previous call.
\
\ ******************************************************************************

.DORND
{
 LDA RAND               \ r2 = ((r0 << 1) mod 256) + C
 ROL A                  \ r0 = r2 + r2 + bit 7 of r0
 TAX
 ADC RAND+2             \ C = carry bit from r0 calculation
 STA RAND
 STX RAND+2

 LDA RAND+1             \ A = r1 = r1 + r3 + C
 TAX                    \ X = r3 = r1
 ADC RAND+3
 STA RAND+1
 STX RAND+3

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: Main game loop (Part 1 of 6)
\
\ This is part of the main game loop. This section covers the following:
\
\   * Spawn a trader, i.e. a Cobra Mk III that isn't attacking anyone, with one
\     missile and a 50% chance of having an E.C.M., a speed between 16 and 31,
\     and a clockwise roll
\
\ We call this from within the main loop, with A set to a random number and the
\ carry flag set.
\
\ ******************************************************************************

{
.MTT4

 LSR A                  \ Clear bit 7 of our random number in A

 STA INWK+32            \ Store this in the ship's AI flag, so this ship does
                        \ not have AI

 STA INWK+29            \ Store A in the ship's roll counter, giving it a
                        \ clockwise roll (as bit 7 is clear), and a 1 in 127
                        \ chance of it having no damping

 ROL INWK+31            \ Set bit 0 of missile count (as we know the carry flag
                        \ is set), giving the ship one missile

 AND #31                \ Set the ship speed to our random number, set to a
 ORA #16                \ minimum of 16 and a maximum of 31
 STA INWK+27

 LDA #CYL               \ Add a new Cobra Mk III to the local universe and fall
 JSR NWSHP              \ through into the main game loop again

\ ******************************************************************************
\
\ Subroutine: Main game loop (Part 2 of 6)
\
\ This is part of the main game loop. This section covers the following:
\
\   * Call M% to do the main flight loop
\
\   * Potentially spawn a trader (Cobra Mk III), asteroid or cargo canister
\
\ Other entry points:
\
\   TT100               The entry point for the start of the main game loop,
\                       which calls the main flight loop and the moves into the
\                       spawning routine
\
\   me3                 Used by me2 to jump back into the main game loop after
\                       printing an in-flight message
\
\ ******************************************************************************

.^TT100

 JSR M%                 \ Call M% to enter the main flight loop

 DEC DLY                \ Decrement the delay counter in DLY, so any in-flight
                        \ messages get removed once the counter reaches zero

 BEQ me2                \ If DLY is now 0, jump to me2 to remove any in-flight
                        \ message from the space view, and once done, return to
                        \ me3 below, skipping the following two instructions

 BPL me3                \ If DLY is positive, jump to me3 to skip the next
                        \ instruction

 INC DLY                \ If we get here, DLY is negative, so we have gone too
                        \ and need to increment DLY back to 0

.^me3

 DEC MCNT               \ Decrement the main loop counter in MCNT

 BEQ P%+5               \ If the counter has reached zero, which it will do
                        \ every 256 main loops, skip the next JMP instruction
                        \ (or to put it another way, if the counter hasn't
                        \ reached zero, jump down to MLOOP, skipping all the
                        \ following checks)

.ytq

 JMP MLOOP              \ Jump down to MLOOP to do some end-of-loop tidying and
                        \ restart the main loop

                        \ We only get here once every 256 iterations of the
                        \ main loop. If we aren't in witchspace and don't
                        \ already have 3 or more asteroids in our local bubble,
                        \ then this section has a 13% chance of spawning
                        \ something benign (the other 87% of the time we jump
                        \ down to consider spawning cops, pirates and bounty
                        \ hunters)
                        \
                        \ If we are in that 13%, then 50% of the time this will
                        \ be a Cobra Mk III trader, and the other 50% of the
                        \ time it will either be an asteroid (98.5% chance) or,
                        \ very rarely, a cargo (1.5% chance) canister

 LDA MJ                 \ If we are in witchspace following a mis-jump, skip the
 BNE ytq                \ following by jumping down to MLOOP (via ytq above)

 JSR DORND              \ Set A and X to random numbers

 CMP #35                \ If A >= 35 (87% chance), jump down to MTT1 to skip
 BCS MTT1               \ the spawning of an asteroid or cargo canister and
                        \ potentially spawn something else

 LDA MANY+AST           \ If we already have 3 or more asteroids in the local
 CMP #3                 \ bubble, jump down to MTT1 to skip the following and
 BCS MTT1               \ potentially spawn something else

 JSR ZINF               \ Call ZINF to reset the INWK ship workspace

 LDA #38                \ Set z_hi = 38 (far away)
 STA INWK+7

 JSR DORND              \ Set A, X and carry flag to random numbers

 STA INWK               \ Set x_lo = random

 STX INWK+3             \ Set y_lo = random

 AND #%10000000         \ Set x_sign = bit 7 of x_lo
 STA INWK+2

 TXA                    \ Set y_sign = bit 7 of y_lo
 AND #%10000000
 STA INWK+5

 ROL INWK+1             \ Set bit 2 of x_hi to the carry flag, which is random,
 ROL INWK+1             \ so this randomly moves us slightly off-centre

 JSR DORND              \ Set A, X and overflow flag to random numbers

 BVS MTT4               \ If overflow is set (50% chance), jump up to MTT4 to
                        \ spawn a trader

 ORA #%01101111         \ Take the random number in A and set bits 0-3 and 5-6,
 STA INWK+29            \ so the result has a 50% chance of being positive or
                        \ negative, and a 50% chance of bits 0-6 being 127.
                        \ Storing this number in the roll counter therefore
                        \ gives our new ship a fast roll speed with a 50%
                        \ chance of having no damping, plus a 50% chance of
                        \ rolling clockwise or anti-clockwise

 LDA SSPR               \ If we are inside the space station safe zone, jump
 BNE MTT1               \ down to MTT1 to skip the following and potentially
                        \ spawn something else

 TXA                    \ Set A to the random X we set above, which we haven't
 BCS MTT2               \ used yet, and if carry is set (50% chance) jump down
                        \ to MTT2 to skip the following

 AND #31                \ Set the ship speed to our random number, set to a
 ORA #16                \ minimum of 16 and a maximum of 31
 STA INWK+27

 BCC MTT3               \ Jump down to MTT3, skipping the following (this BCC
                        \ is effectively a JMP as we know the carry flag is
                        \ clear, having passed through the BCS above)

.MTT2

 ORA #%01111111         \ Set bits 0-6 of A to 127, leaving bit 7 as random, so
 STA INWK+30            \ storing this number in the pitch counter means we have
                        \ full pitch with no damping, with a 50% chance of
                        \ pitching up or down

.MTT3

 JSR DORND              \ Set A and X to random numbers

 CMP #5                 \ Set A to the ship number of an asteroid, and keep
 LDA #AST               \ this value for 98.5% of the time (i.e. if random
 BCS P%+4               \ A >= 5 skip the following instruction)

 LDA #OIL               \ Set A to the ship number of a cargo canister

 JSR NWSHP              \ Add our new asteroid or canister to the universe

\ ******************************************************************************
\
\ Subroutine: Main game loop (Part 3 of 6)
\
\ This is part of the main game loop. This section covers the following:
\
\   * Potentially spawn a cop (in a Viper), very rarely if we have been good,
\     more often if have been naughty, and very often if we have been properly
\     bad
\
\ ******************************************************************************

.MTT1

 LDA SSPR               \ If we are inside the space station's safe zone, jump
 BNE MLOOP              \ to MLOOP to skip the following

 JSR BAD                \ Call BAD to work out how much illegal contraband we
                        \ are carrying in our hold (A is up to 40 for a
                        \ standard hold crammed with contraband, up to 70 for
                        \ an extended cargo hold full of narcotics and slaves)

 ASL A                  \ Double A to a maximum of 80 or 140

 LDX MANY+COPS          \ If there are no cops in the local bubble, skip the
 BEQ P%+5               \ next instruction

 ORA FIST               \ There are cops in the vicinity and we've got a hold
                        \ full of jail time, so OR the value in A with FIST to
                        \ get a new value that is at least as high as both
                        \ values, to reflect the fact that they have almost
                        \ certainly scanned our ship

 STA T                  \ Store our badness level in T

 JSR Ze                 \ Call Ze to initialise INWK to a potentially hostile
                        \ ship, and set X to a random value and A to a random
                        \ value between 192 and 255

 CMP T                  \ If the random value in A >= our badness level, which
 BCS P%+7               \ will be the case unless we have been really, really
                        \ bad, then skip the following two instructions (so if
                        \ we are really bad, there's a higher chance of
                        \ spawning a cop, otherwise we got away with it, for
                        \ now)

 LDA #COPS              \ Add a new police ship to the local bubble
 JSR NWSHP

 LDA MANY+COPS          \ If we now have at least one cop in the local bubble,
 BNE MLOOP              \ jump down to MLOOP, otherwise fall through into the
                        \ next part to look at spawning something else

\ ******************************************************************************
\
\ Subroutine: Main game loop (Part 4 of 6)
\
\ This is part of the main game loop. This section covers the following:
\
\   * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
\     Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
\     (Sidewinders and/or Mambas)
\
\ ******************************************************************************

 DEC EV                 \ Decrement EV, the extra vessels spawning delay, and
 BPL MLOOP              \ jump to MLOOP if it is still positive, so we only
                        \ do the following when the EV counter runs down

 INC EV                 \ EV is negative, so bump it up again, setting it back
                        \ to 0

 JSR DORND              \ Set A and X to random numbers

 LDY gov                \ If the government of this system is 0 (anarchy), jump
 BEQ LABEL_2            \ straight to LABEL_2 to start spawning pirates or a
                        \ lone bounty hunter

 CMP #90                \ If the random number in A >= 90 (65% chance), jump to
 BCS MLOOP              \ MLOOP to stop spawning (so there's a 35% chance of
                        \ spawning pirates or a lone bounty hunter)

 AND #7                 \ Reduce the random number in A to the range 0-7, and
 CMP gov                \ if A is less than government of this system, jump
 BCC MLOOP              \ to MLOOP to stop spawning (so safer governments with
                        \ larger gov numbers have a greater chance of jumping
                        \ out, which is another way of saying that more
                        \ dangerous systems spawn pirates and bounty hunters
                        \ more often)

.LABEL_2                \ Now to spawn a lone bounty hunter, a Thargoid or a
                        \ group of pirates

 JSR Ze                 \ Call Ze to initialise INWK to a potentially hostile
                        \ ship, and set X to a random value and A to a random
                        \ value between 192 and 255

 CMP #200               \ If the random number in A >= 200 (13% chance), jump
 BCS mt1                \ to mt1 to spawn pirates, otherwise keep going to
                        \ spawn a lone bounty hunter or a Thargoid

 INC EV                 \ Increase the extra vessels spawning counter, to
                        \ prevent the next attempt to spawn extra vessels

 AND #3                 \ Set A = Y = random number in the range 3-6, which
 ADC #3                 \ we will use to determine the type of ship
 TAY

                        \ We now build the AI flag for this ship in A

 TXA                    \ First, set the C flag if X >= 200 (22% chance)
 CMP #200

 ROL A                  \ Set bit 0 of A to the C flag (i.e. there's a 22%
                        \ chance of this ship having E.C.M.)

 ORA #%11000000         \ Set bits 6 and 7 of A, so the ship is hostile (bit 6
                        \ and has AI (bit 7)

 CPY #6                 \ If Y = 6 (i.e. a Thargoid), jump down to the tha
 BEQ tha                \ routine to decide whether or not to spawn it (where
                        \ there's a 22% chance of this happening)

 STA INWK+32            \ Store A in the AI flag of this ship

 TYA                    \ Add a new ship of type Y to the local bubble, so
 JSR NWSHP              \ that's a Mamba, Cobra Mk III or Python

.mj1

 JMP MLOOP              \ Jump down to MLOOP, as we are done spawning ships

.mt1

 AND #3                 \ It's time to spawn a group of pirates, so set A to a
                        \ random number in the range 0-3, which will be the
                        \ loop counter for spawning pirates below (so we will
                        \ spawn 1-4 pirates)

 STA EV                 \ Delay further spawnings by this number

 STA XX13               \ Store the number in XX13, the pirate counter

.mt3

 JSR DORND              \ Set A and X to random numbers

 AND #3                 \ Set A to a random number in the range 0-3

 ORA #1                 \ Set A to %01 or %11 (Sidewinder or Mamba)

 JSR NWSHP              \ Add a new ship of type A to the local bubble

 DEC XX13               \ Decrement the pirate counter

 BPL mt3                \ If we need more pirates, loop back up to mt3,
                        \ otherwise we are done spawning, so fall through into
                        \ the end of the main loop at MLOOP

\ ******************************************************************************
\
\ Subroutine: Main game loop (Part 5 of 6)
\
\ Other entry points: MLOOP
\
\ This is part of the main game loop. This section covers the following:
\
\   * Cool down lasers
\
\   * Make calls to update the dashboard
\
\ Other entry points:
\
\   MLOOP               The entry point for the main game loop. This entry point
\                       comes after the the call to the main flight loop and
\                       spawning routines, so it marks the start of the main
\                       game loop for when we are docked (as we don't need to
\                       call the main flight loop or spawning routines if we
\                       aren't in space)
\
\ ******************************************************************************

.^MLOOP
 LDA #%00000001         \ Set 6522 System VIA interrupt enable register IER
 STA SHEILA+&4E         \ (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
                        \ which comes from the keyboard)

 LDX #&FF               \ Reset the 6502 stack pointer, which clears the stack
 TXS

 LDX GNTMP              \ If the laser temperature in GNTMP is non-zero,
 BEQ EE20               \ decrement it (i.e. cool it down a bit)
 DEC GNTMP

.EE20

 JSR DIALS              \ Call DIALS to update the dashboard

 LDA QQ11               \ If this is a space view, skip the following four
 BEQ P%+11              \ instructions (i.e. jump to JSR TT17 below)

 AND PATG               \ If PATG = &FF (author names are shown on start-up)
 LSR A                  \ and bit 0 of QQ11 is 1 (the current view is type 1),
 BCS P%+5               \ then skip the following instruction

 JSR DELAY-5            \ Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
                        \ slow the main loop down a bit

 JSR TT17               \ Scan the keyboard for the cursor keys or joystick,
                        \ returning the cursor's delta values in X and Y and
                        \ the key pressed in A

\ ******************************************************************************
\
\ Subroutine: Main game loop (Part 6 of 6)
\
\ This is part of the main game loop. This section covers the following:
\
\   * Process more keypresses (red function keys, docked keys etc.)
\
\   * Support joining the main loop with a key already "pressed", so we can
\     jump into the main game loop to perform a specific action. In practice,
\     this is used when we enter the docking bay in BAY to display Status Mode
\     (red key f8), and when we finish buying or selling cargo in BAY2 to jump
\     to the Inventory (red key f9).
\
\ Other entry points:
\
\   FRCE                The entry point for the main game loop if we want to
\                       jump straight to a specific screen, by pretending to
\                       "press" a key, in which case A contains the internal key
\                       number of the key we want to "press"
\
\ ******************************************************************************

.^FRCE

 JSR TT102              \ Call TT102 to process the keypress in A

 LDA QQ12               \ Fetch the docked flag from QQ12 into A

 BNE MLOOP              \ If we are docked, loop back up to MLOOP just above
                        \ to restart the main loop, but skipping all the flight
                        \ and spawning code in the top part of the main loop

 JMP TT100              \ Otherwise jump to TT100 to restart the main loop from
                        \ the start
}

\ ******************************************************************************
\
\ Subroutine: tha
\
\ Consider spawning a Thargoid (22% chance).
\
\ ******************************************************************************

.tha
{
 JSR DORND              \ Set A and X to random numbers

 CMP #200               \ If A < 200 (78% chance), skip the next instruction
 BCC P%+5

 JSR GTHG               \ Call GTHG to spawn a Thargoid ship

 JMP MLOOP              \ Jump back into the main loop at MLOOP, which is just
                        \ after the ship-spawning section
}

\ ******************************************************************************
\
\ Subroutine: TT102
\
\ Process function key presses, plus "@" (save commander), "H" (hyperspace),
\ "D" (show distance to system) and "O" (move chart cursor back to current
\ system). We can also pass cursor position deltas in X and Y to indicate that
\ the cursor keys or joystick have been used (i.e. the values that are returned
\ by routine TT17).
\
\ Arguments:
\
\   A                   The internal key number of the key pressed (see p.142 of
\                       the Advanced User Guide for a list of internal key
\                       numbers)
\
\   X                   The amount to move the crosshairs in the x-axis
\
\   Y                   The amount to move the crosshairs in the y-axis
\
\ ******************************************************************************

.TT102
{
 CMP #f8                \ If red key f8 was pressed, jump to STATUS to show the
 BNE P%+5               \ Status Mode screen, returning from the subroutine
 JMP STATUS             \ using a tail call

 CMP #f4                \ If red key f4 was pressed, jump to TT22 to show the
 BNE P%+5               \ Long-range Chart, returning from the subroutine using
 JMP TT22               \ a tail call

 CMP #f5                \ If red key f5 was pressed, jump to TT23 to show the
 BNE P%+5               \ Short-range Chart, returning from the subroutine using
 JMP TT23               \ a tail call

 CMP #f6                \ If red key f6 was pressed, call TT111 to select the
 BNE TT92               \ system nearest to galactic coordinates (QQ9, QQ10)
 JSR TT111              \ (the location of the chart crosshairs) and jump to
 JMP TT25               \ TT25 to show the Data on System screen, returning
                        \ from the subroutine using a tail call

.TT92

 CMP #f9                \ If red key f9 was pressed, jump to TT213 to show the
 BNE P%+5               \ Inventory screen, returning from the subroutine
 JMP TT213              \ using a tail call

 CMP #f7                \ If red key f7 was pressed, jump to TT167 to show the
 BNE P%+5               \ Market Price screen, returning from the subroutine
 JMP TT167              \ using a tail call

 CMP #f0                \ If red key f0 was pressed, jump to TT110 to launch our
 BNE fvw                \ ship (if docked), returning from the subroutine using
 JMP TT110              \ a tail call

.fvw

 BIT QQ12               \ If bit 7 of QQ12 is clear (i.e. we are not docked, but
 BPL INSP               \ in space), jump to INSP to skip the following checks
                        \ for f1-f3 and "@" (save commander file) keypresses

 CMP #f3                \ If red key f3 was pressed, jump to EQSHP to show the
 BNE P%+5               \ Equip Ship screen, returning from the subroutine using
 JMP EQSHP              \ a tail call

 CMP #f1                \ If red key f1 was pressed, jump to TT219 to show the
 BNE P%+5               \ Buy Cargo screen, returning from the subroutine using
 JMP TT219              \ a tail call

 CMP #&47               \ If "@" was pressed, jump to SVE to save the commander
 BNE P%+5               \ file, returning from the subroutine using a tail call
 JMP SVE

 CMP #f2                \ If red key f2 was pressed, jump to TT208 to show the
 BNE LABEL_3            \ Sell Cargo screen, returning from the subroutine using
 JMP TT208              \ a tail call

.INSP

 CMP #f1                \ If the key pressed is < red key f1 or > red key f3,
 BCC LABEL_3            \ jump to LABEL_3 (so only do the following if the key
 CMP #f3+1              \ pressed is f1, f2 or f3)
 BCS LABEL_3

 AND #3                 \ If we get here then we are either in space, or we are
 TAX                    \ docked and none of f1-f3 were pressed, so we can now
 JMP LOOK1              \ process f1-f3 with their in-flight functions, i.e.
                        \ switching space views
                        \
                        \ A will contain &71, &72 or &73 (for f1, f2 or f3), so
                        \ set X to the last digit (1, 2 or 3) and jump to LOOK1
                        \ to switch to view X (back, left or right), returning
                        \ from the subroutine using a tail call

.LABEL_3

 CMP #&54               \ If "H" was pressed, jump to hyp to do a hyperspace
 BNE P%+5               \ jump (if we are in space), returning from the
 JMP hyp                \ subroutine using a tail call

 CMP #&32               \ If "D" was pressed, jump to T95 to print the distance
 BEQ T95                \ to a system (if we are in one of the chart screens)

 STA T1                 \ Store A (the key that's been pressed) in T1

 LDA QQ11               \ If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         \ keep going, otherwise jump down to TT107 to skip the
 BEQ TT107              \ following

 LDA QQ22+1             \ If the on-screen hyperspace counter is non-zero,
 BNE TT107              \ then we are already counting down, so jump to TT107
                        \ to skip the following

 LDA T1                 \ Restore the original value of A (the key that's been
                        \ pressed) from T1

 CMP #&36               \ If "O" was pressed, do the following three JSRs,
 BNE ee2                \ otherwise jump to ee2 to skip the following

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will erase the crosshairs currently there

 JSR ping               \ Set the target system to the current system (which
                        \ will move the location in (QQ9, QQ10) to the current
                        \ home system

 JSR TT103              \ Draw small crosshairs at coordinates (QQ9, QQ10),
                        \ which will draw the crosshairs at our current home
                        \ system

.ee2

 JSR TT16               \ Call TT16 to move the crosshairs by the amount in X
                        \ and Y, which were passed to this subroutine as
                        \ arguments

.TT107

 LDA QQ22+1             \ If the on-screen hyperspace counter is zero, return
 BEQ t95                \ from the subroutine (as t95 contains an RTS), as we
                        \ are not currently counting down to a hyperspace jump

 DEC QQ22               \ Decrement the internal hyperspace counter

 BNE t95                \ If the internal hyperspace counter is still non-zero,
                        \ then we are still counting down, so return from the
                        \ subroutine (as t95 contains an RTS)

                        \ If we get here then the internal hyperspace counter
                        \ has just reached zero and it wasn't zero before, so
                        \ we need to reduce the on-screen counter and update
                        \ the screen. We do this by first printing the next
                        \ number in the countdown sequence, and then printing
                        \ the old number, which will erase the old number
                        \ and display the new one because printing uses EOR
                        \ logic

 LDX QQ22+1             \ Set X = the on-screen hyperspace counter - 1
 DEX                    \ (i.e. the next number in the sequence)

 JSR ee3                \ Print the 8-bit number in X at text location (0, 1)

 LDA #5                 \ Reset the the internal hyperspace counter to 5
 STA QQ22

 LDX QQ22+1             \ Set X = the on-screen hyperspace counter (i.e. the
                        \ current number in the sequence, which is already
                        \ shown on-screen)

 JSR ee3                \ Print the 8-bit number in X at text location (0, 1),
                        \ i.e. print the hyperspace countdown in the top-left
                        \ corner

 DEC QQ22+1             \ Decrement the on-screen hyperspace countdown

 BNE t95                \ If the countdown is not yet at zero, return from the
                        \ subroutine (as t95 contains an RTS)

 JMP TT18               \ Otherwise the countdown has finished, so jump to TT18
                        \ to do a hyperspace jump, returning from the subroutine
                        \ using a tail call

.t95

 RTS                    \ Return from the subroutine

.T95                    \ If we get here, "D" was pressed, so we need to show
                        \ the distance to the selected system (if we are in a
                        \ chart view)

 LDA QQ11               \ If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         \ keep going, otherwise return from the subroutine (as
 BEQ t95                \ t95 contains an RTS)

 JSR hm                 \ Call hm to move the crosshairs to the target system
                        \ in (QQ9, QQ10), returning with A = 0

 STA QQ17               \ Set QQ17 = 0 to switch to ALL CAPS

 JSR cpl                \ Print control code 3 (the selected system name)

 LDA #128               \ Set QQ17 = 128 to switch to Sentence Case, with the
 STA QQ17               \ next letter in capitals

 LDA #1                 \ Move the text cursor to column 1 and down one line
 STA XC                 \ (in other words, to the start of the next line)
 INC YC

 JMP TT146              \ Print the distance to the selected system and return
                        \ from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: BAD
\
\ Work out how bad we are from the amount of contraband in our hold. The
\ formula is:
\
\   (slaves + narcotics) * 2 + firearms
\
\ so slaves and narcotics are twice as illegal as firearms. The value in FIST
\ (our legal status) is set to a minimum of this value whenever we launch from
\ a space station, and a FIST of 50 or more is fugitive status, so leaving a
\ station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
\ across multiple trips, is enough to make us a fugitive.
\
\ ******************************************************************************

.BAD                    \ Legal status from Cargo scan
{
 LDA QQ20+3             \ Set A to the number of tonnes of slaves in the hold

 CLC                    \ Clear the carry flag so we can do addition without
                        \ the carry flag affecting the result

 ADC QQ20+6             \ Add the number of tonnes of narcotics in the hold

 ASL A                  \ Double the result and add the number of tonnes of
 ADC QQ20+10            \ firearms in the hold

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: FAROF
\
\ Compare x_hi, y_hi and z_hi with &E0, and set the C flag if all three <= &E0,
\ otherwise clear the C flag.
\
\ Returns:
\
\   C flag              Set if x_hi <= &E0 and y_hi <= &E0 and z_hi <= &E0
\
\                       Clear otherwise (i.e. if any one of them are bigger than
\                       &E0)
\
\ ******************************************************************************

.FAROF
{
 LDA #&E0               \ Set A = &E0 and fall through into FAROF2 to do the
                        \ comparison
}

\ ******************************************************************************
\
\ Subroutine: FAROF2
\
\ Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
\ otherwise clear the C flag.
\
\ Returns:
\
\   C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
\
\                       Clear otherwise (i.e. if any one of them are bigger than
\                       A)
\
\ ******************************************************************************

.FAROF2
{
 CMP INWK+1             \ If A < x_hi, C will be clear so jump to MA34 to
 BCC MA34               \ return from the subroutine with C clear, otherwise
                        \ C will be set so move on to the next one

 CMP INWK+4             \ If A < y_hi, C will be clear so jump to MA34 to
 BCC MA34               \ return from the subroutine with C clear, otherwise
                        \ C will be set so move on to the next one

 CMP INWK+7             \ If A < z_hi, C will be clear, otherwise C will be set

.MA34

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: MAS4
\
\ Logical OR the value in A with the high bytes of the ship's position (x_hi,
\ y_hi and z_hi).
\
\ Returns:
\
\   A                   A OR x_hi OR y_hi OR z_hi
\
\ ******************************************************************************

.MAS4
{
 ORA INWK+1             \ OR A with x_hi, y_hi and z_hi
 ORA INWK+4
 ORA INWK+7

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DEATH
\
\ We have been killed, so display the chaos of our destruction above a "GAME
\ OVER" sign, and clean up the mess ready for the next attempt.
\
\ ******************************************************************************

.DEATH
{
 JSR EXNO3              \ Make the sound of us dying

 JSR RES2               \ Reset a number of flight variables and workspaces

 ASL DELTA              \ Divide our speed in DELTA by 4
 ASL DELTA

 LDX #24                \ Set the screen to only show 24 text rows, which hides
 JSR DET1               \ the dashboard, setting A to 6 in the process

 JSR TT66               \ Clear the top part of the screen, draw a white border,
                        \ and set the current view type in QQ11 to 6 (death
                        \ screen)

 JSR BOX                \ Call BOX to redraw the same white border (BOX is part
                        \ of TT66), which removes the border as it is drawn
                        \ using EOR logic

 JSR nWq                \ Create a cloud of stardust containing the maximum
                        \ number of dust particles (i.e. NOSTM of them)

 LDA #12                \ Move the text cursor to column 12 on row 12
 STA YC
 STA XC

 LDA #146               \ Print recursive token 13 ("{switch to all caps}GAME
 JSR ex                 \ OVER"

.D1

 JSR Ze                 \ Initialise INWK workspace, set X and T1 to a random
                        \ value, and A to a random value between 192 and 255 and
                        \ the C flag randomly

 LSR A                  \ Set A = A / 4, so A is now between 48 and 63, and
 LSR A                  \ store in INWK+0 (x_lo)
 STA INWK

 LDY #0                 \ Set the following to 0: the current view in QQ11
 STY QQ11               \ (space view), x_hi, y_hi, z_hi and the AI flag (no AI
 STY INWK+1             \ or E.C.M. and not hostile)
 STY INWK+4
 STY INWK+7
 STY INWK+32

 DEY                    \ Set Y = 255

 STY MCNT               \ Reset the main loop counter to 255, so all timer-based
                        \ calls will be stopped

 STY LASCT              \ Set the laser count to 255 to act as a counter in the
                        \ D2 loop below, so this setting determines how long the
                        \ death animation lasts (it's 5.1 seconds, as LASCT is
                        \ decremented every vertical sync, or 50 times a second,
                        \ and 255 / 50 = 5.1)

 EOR #%00101010         \ Flip bits 1, 3 and 5 in A (x_lo) to get another number
 STA INWK+3             \ between 48 and 63, and store in INWK+3 (y_lo)

 ORA #%01010000         \ Set bits 4 and 6 of A to bump it up to between 112 and
 STA INWK+6             \ 127, and store in INWK+6 (z_lo)

 TXA                    \ Set A to the random number in X and keep bits 0-3 and
 AND #%10001111         \ the bit 7 to get a number between -15 and +15, and
 STA INWK+29            \ store in INWK+29 (roll counter) to give our ship a
                        \ gentle roll with damping

 ROR A                  \ C is random from above call to Ze, so this sets A to a
 AND #%10000111         \ number between -7 and +7, which we store in INWK+30
 STA INWK+30            \ (pitch counter) to give our ship a very gentle pitch
                        \ with damping

 PHP                    \ Store the processor flags

 LDX #OIL               \ Call fq1 with X set to OIL, which adds a new cargo
 JSR fq1                \ canister to our local bubble of universe and points it
                        \ away from us with double DELTA speed (i.e. 6, as DELTA
                        \ was set to 3 by the call to RES2 above). INF is set to
                        \ point to the ship's data block in K%

 PLP                    \ Restore the processor flags, including our random C
                        \ flag from before

 LDA #0                 \ Set bit 7 of A to our random C flag and store in byte
 ROR A                  \ 31 of the ship's data block, so this has a 50% chance
 LDY #31                \ of marking our new canister as being killed (so it
 STA (INF),Y            \ will explode)

 LDA FRIN+3             \ The call we made to RES2 before we entered the loop at
 BEQ D1                 \ D1 will have reset all the ship slots at FRIN, so this
                        \ checks to see if the fourth slot is empty, and if it
                        \ is we loop back to D1 to add another canister, until
                        \ we have added four of them

 JSR U%                 \ Clear the key logger, which also sets A = 0

 STA DELTA              \ Set our speed in DELTA to 3, so all the cargo
                        \ canisters we just added drift away from us

.D2

 JSR M%                 \ Call the M% routine to do the main flight loop once,
                        \ which will display our exploding canister scene and
                        \ move everything about

 LDA LASCT              \ Loop back to D2 to run the main flight loop until
 BNE D2                 \ LASCT reaches zero (which will take 5.1 seconds, as
                        \ explained above)

 LDX #31                \ Set the screen to show all 31 text rows, which shows
 JSR DET1               \ the dashboard, and fall through into DEATH2 to reset
                        \ and restart the game

}

\ ******************************************************************************
\
\ Subroutine: DEATH2
\
\ Reset most of the game and restart from the title screen.
\
\ ******************************************************************************

.DEATH2
{
 JSR RES2               \ Reset a number of flight variables and workspaces
                        \ and fall through into the entry code for the game
                        \ to restart from the title screen
}

\ ******************************************************************************
\
\ Subroutine: TT170
\
\ Entry point for Elite game code. Also called following death or quitting a
\ game (by pressing Escape when paused).
\
\ BRKV is set to point to BR1 by elite-loader.asm.
\
\ Other entry points:
\
\   BR1                 Restarts the game, but without resetting the stack
\                       pointer. BRKV is set to point here by elite-loader.asm
\
\ ******************************************************************************

.TT170
{
 LDX #&FF               \ Set stack pointer to &01FF, so stack is in page 1
 TXS                    \ (this is the standard location for the 6502 stack)

.^BR1                   \ BRKV is set to point here by elite-loader.asm

 LDX #3                 \ Set XC = 3 (set text cursor to column 3)
 STX XC

 JSR FX200              \ Disable the Escape key and clear memory if the Break
                        \ key is pressed (*FX 200,3)

 LDX #CYL               \ Call the TITLE subroutine to show the rotating ship
 LDA #128               \ and load prompt. The arguments sent to TITLE are:
 JSR TITLE              \
                        \   X = type of ship to show, CYL is Cobra Mk III
                        \
                        \   A = text token to show below the rotating ship, 128
                        \       is "  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"
                        \
                        \ The TITLE subroutine returns with the internal number
                        \ of the key pressed in A (see p.142 of the Advanced
                        \ User Guide for a list of internal key number)

 CMP #&44               \ Did we press "Y"? If not, jump to QU5, otherwise
 BNE QU5                \ continue on to load a new commander

\BR1                    \ These instructions are commented out in the original
\LDX #3                 \ source. This block starts with the same *FX call as
\STX XC                 \ above, then clears the screen, calls a routine to
\JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
\LDA #1                 \ in the tape version but is in the disc version, and
\JSR TT66               \ then it displays "LOAD NEW COMMANDER (Y/N)?" and
\JSR FLKB               \ lists the current cargo, before falling straight into
\LDA #14                \ the load routine below, whether or not we have
\JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
\BCC QU5                \ first line is a commented label, BR1, which is where
                        \ BRKV points, so when this is uncommented, pressing
                        \ the Break key should jump straight to the load screen

 JSR GTNME              \ We want to load a new commander, so we need to get
                        \ the commander name to load

 JSR LOD                \ We then call the LOD subroutine to load the commander
                        \ file to address NA%+8, which is where we store the
                        \ commander save file

 JSR TRNME              \ Once loaded, we copy the commander name to NA%

 JSR TTX66              \ And we clear the top part of the screen and draw a
                        \ white border

.QU5                    \ By the time we get here, the correct commander name
                        \ is at NA% and the correct commander data is at NA%+8.
                        \ Specifically:
                        \
                        \   * If we loaded a commander file, then the name and
                        \     data from that file will be at NA% and NA%+8
                        \
                        \   * If this is a brand new game, then NA% will contain
                        \     the default starting commander name ("JAMESON")
                        \     and NA%+8 will contain the default commander data
                        \
                        \   * If this is not a new game (because they died or
                        \     quit) and we didn't want to load a commander file,
                        \     then NA% will contain the last saved commander
                        \     name, and NA%+8 the last saved commander data. If
                        \     the game has never been saved, this will still be
                        \     the default commander

\JSR TTX66              \ This instruction is commented out in the original
                        \ source; it clears the screen and draws a border

 LDX #NT%               \ The size of the commander data block is NT% bytes,
                        \ and it starts at NA%+8, so we need to copy the data
                        \ from the "last saved" buffer at NA%+8 to the current
                        \ commander workspace at TP. So we set up a counter in X
                        \ for the NT% bytes that we want to copy

.QUL1

 LDA NA%+7,X            \ Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
 STA TP-1,X             \ (the -1 is because X is counting down from NT% to 1)

 DEX                    \ Decrement the loop counter

 BNE QUL1               \ Loop back for the next byte of the commander file

 STX QQ11               \ X is 0 by the end of the above loop, so this sets QQ11
                        \ to 0, which means we will be showing a view without a
                        \ boxed title at the top (i.e. we're going to use the
                        \ screen layout of a space view in the following)

                        \ If the commander check below fails, we keep jumping
                        \ back to here to crash the game with an infinite loop

 JSR CHECK              \ Call the CHECK subroutine to calculate the checksum
                        \ for the current commander block at NA%+8 and put it
                        \ in A

 CMP CHK                \ Test the calculated checksum against CHK

IF _REMOVE_COMMANDER_CHECK

 NOP                    \ If we have disabled the commander check, then ignore
 NOP                    \ the checksum and fall through into the next part

ELSE

 BNE P%-6               \ If commander check is enabled and the calculated
                        \ checksum does not match CHK, then loop back to repeat
                        \ the check - in other words, we enter an infinite loop
                        \ here, as the checksum routine will keep returning the
                        \ same incorrect value

ENDIF

                        \ The checksum CHK is correct, so now we check whether
                        \ CHK2 = CHK EOR A9, and if this check fails, bit 7 of
                        \ the competition code COK gets set, presumably to
                        \ indicate to Acornsoft that there may have been some
                        \ hacking going on with this competition entry

 EOR #&A9               \ X = checksum EOR &A9
 TAX

 LDA COK                \ Set A = competition code in COK

 CPX CHK2               \ If X = CHK2, then skip the next instruction
 BEQ tZ

 ORA #128               \ Set bit 7 of A

.tZ

 ORA #2                 \ Set bit 1 of A

 STA COK                \ Store the competition code A in COK

 JSR msblob             \ Reset the dashboard's missile indicators to all be
                        \ green/cyan

 LDA #147               \ Call the TITLE subroutine to show the rotating ship
 LDX #MAM               \ and fire/space prompt. The arguments sent to TITLE
 JSR TITLE              \ are:
                        \
                        \   X = type of ship to show, MAM is Mamba
                        \   A = text token to show below the rotating ship, 147
                        \       is "PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"

 JSR ping               \ Set the target system coordinates (QQ9, QQ10) to the
                        \ current system coordinates (QQ0, QQ1) we just loaded

 JSR hyp1               \ Arrive in the system closest to (QQ9, QQ10) and then
                        \ and then fall through into the docking bay routine
                        \ below
}

\ ******************************************************************************
\
\ Subroutine: BAY
\
\ Go to the docking bay (i.e. show the Status Mode screen).
\
\ We end up here after the startup process (load commander etc.), as well as
\ after a successful save, an escape pod launch, a successful docking, the end
\ of a cargo sell, and various errors (such as not having enough cash, entering
\ too many items when buying, trying to fit an item to your ship when you
\ already have it, running out of cargo space, and so on).
\
\ ******************************************************************************

.BAY
{
 LDA #&FF               \ Set QQ12 = &FF (the docked flag) to indicate that we
 STA QQ12               \ are docked

 LDA #f8                \ Jump into the main loop at FRCE, setting the key
 JMP FRCE               \ "pressed" to red key f8 (so we show the Status Mode
                        \ screen)
}

\ ******************************************************************************
\
\ Subroutine: TITLE
\
\ Display the title screen, with a rotating ship and a recursive text token at
\ the bottom of the screen.
\
\ Arguments:
\
\   A                   The number of the recursive token to show below the
\                       rotating ship (see variable QQ18 for details of
\                       recursive tokens)
\
\   X                   The type of the ship to show (see variable XX21 for a
\                       list of ship types)
\
\ ******************************************************************************

.TITLE
{
 PHA                    \ Store the token number on the stack for later

 STX TYPE               \ Store the ship type in location TYPE

 JSR RESET              \ Reset our ship so we can use it for the rotating
                        \ title ship

 LDA #1                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 1

 DEC QQ11               \ Decrement QQ11 to 0, so from here on we are using a
                        \ space view

 LDA #96                \ Set nosev_z hi = 96 (96 is the value of unity in the
 STA INWK+14            \ rotation vector)

\LSR A                  \ This instruction is commented out in the original
                        \ source. It would halve the value of zhi to 48, so the
                        \ ship would start off closer to the viewer

 STA INWK+7             \ Set z_hi, the high byte of the ship's z-coordinate,
                        \ to 96, which is the distance at which the rotating
                        \ ship starts out before coming towards us

 LDX #127
 STX INWK+29            \ Set roll counter = 127, so don't dampen the roll
 STX INWK+30            \ Set pitch counter = 127, so don't dampen the pitch

 INX                    \ Set QQ17 = 128, which sets Sentence Case, with the
 STX QQ17               \ next letter printing in upper case

 LDA TYPE               \ Set up a new ship, using the ship type in TYPE
 JSR NWSHP

 LDY #6                 \ Set the text cursor to column 6
 STY XC

 JSR DELAY              \ Delay for 6 vertical syncs (6/50 = 0.12 seconds)

 LDA #30                \ Print recursive token 144 ("---- E L I T E ----")
 JSR plf                \ followed by a newline

 LDY #6                 \ Set the text cursor to column 6 again
 STY XC

 INC YC                 \ Move the text cursor down a row

 LDA PATG               \ If PATG = 0, skip the following two lines, which
 BEQ awe                \ print the author credits (PATG can be toggled by
                        \ pausing the game and pressing "X")

 LDA #254               \ Print recursive token 94, "BY D.BRABEN & I.BELL"
 JSR TT27

.awe

 JSR CLYNS              \ Clear the bottom three text rows of the upper screen,
                        \ and move the text cursor to column 1 on row 21, i.e.
                        \ the start of the top row of the three bottom rows.
                        \ It also returns with Y = 0

 STY DELTA              \ Set DELTA = 0 (i.e. ship speed = 0)

 STY JSTK               \ Set KSTK = 0 (i.e. keyboard, not joystick)

 PLA                    \ Restore the recursive token number we stored on the
 JSR ex                 \ stack at the start of this subroutine, and print that
                        \ token

 LDA #148               \ Move the text cursor to column 7 and print recursive
 LDX #7                 \ token 148 ("(C) ACORNSOFT 1984")
 STX XC
 JSR ex

.TLL2

 LDA INWK+7             \ If z_hi (the ship's distance) is 1, jump to TL1 to
 CMP #1                 \ skip the following decrement
 BEQ TL1

 DEC INWK+7             \ Decrement the ship's distance, to bring the ship
                        \ a bit closer to us

.TL1

 JSR MVEIT              \ Move the ship in space according to the orientation
                        \ vectors and the new value in z_hi

 LDA #128               \ Set z_lo = 128 (so the closest the ship gets to us is
 STA INWK+6             \ z_hi = 1, z_lo = 128, or 256 + 128 = 384

 ASL A                  \ Set A = 0

 STA INWK               \ Set x_lo = 0, so ship remains in the screen centre

 STA INWK+3             \ Set y_lo = 0, so ship remains in the screen centre

 JSR LL9                \ Call LL9 to display the ship

 DEC MCNT               \ Decrement the move counter

 LDA SHEILA+&40         \ Read 6522 System VIA input register IRB (SHEILA &40)

 AND #%00010000         \ Bit 4 of IRB (PB4) is clear if joystick 1's fire
                        \ button is pressed, otherwise it is set, so AND'ing
                        \ the value of IRB with %10000 extracts this bit

\TAX                    \ This instruction is commented out in the original
                        \ source

 BEQ TL2                \ If the joystick fire button is pressed, jump to BL2

 JSR RDKEY              \ Scan the keyboard for a keypress

 BEQ TLL2               \ If no key was pressed, loop back up to move/rotate
                        \ the ship and check again for a key press

 RTS                    \ Return from the subroutine

.TL2

 DEC JSTK               \ Joystick fire button was pressed, so set JSTK to &FF
                        \ (it was set to 0 above), to disable keyboard and
                        \ enable joysticks

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: CHECK
\
\ Calculate the checksum for the last saved commander data block, to protect
\ against corruption and tampering. The checksum is returned in A.
\
\ This algorithm is also implemented in elite-checksum.py.
\
\ ******************************************************************************

.CHECK
{
 LDX #NT%-2             \ Set X to the size of the commander data block, less
                        \ 2 (as there are two checksum bytes)

 CLC                    \ Clear the carry flag so we can do addition without
                        \ the carry flag affecting the result

 TXA                    \ Seed the checksum calculation by setting A to the
                        \ size of the commander data block, less 2

                        \ We now loop through the commander data block,
                        \ starting at the end and looping down to the start
                        \ (so at the start of this loop, the X-th byte is the
                        \ last byte of the commander data block, i.e. the save
                        \ count)

.QUL2

 ADC NA%+7,X            \ Add the X-1-th byte of the data block to A, plus
                        \ carry

 EOR NA%+8,X            \ EOR A with the X-th byte of the data block

 DEX                    \ Decrement the loop counter

 BNE QUL2               \ Loop back for the next byte in the data block

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TRNME
\
\ Copy the last saved commander's name from INWK to NA%.
\
\ ******************************************************************************

.TRNME
{
 LDX #7                 \ The commander's name can contain a maximum of 7
                        \ characters, and is terminated by a carriage return,
                        \ so set up a counter in X to copy 8 characters

.GTL1

 LDA INWK,X             \ Copy the X-th byte of INWK to the X-th byte of NA%
 STA NA%,X

 DEX                    \ Decrement the loop counter

 BPL GTL1               \ Loop back until we have copied all 8 bytes

                        \ Fall through into TR1 to copy the name back from NA%
                        \ to INWK, though this has no effect apart from saving
                        \ one byte, as we don't need an RTS here
}

\ ******************************************************************************
\
\ Subroutine: TR1
\
\ Copy the last saved commander's name from NA% to INWK.
\
\ ******************************************************************************

.TR1
{
 LDX #7                 \ The commander's name can contain a maximum of 7
                        \ characters, and is terminated by a carriage return,
                        \ so set up a counter in X to copy 8 characters

.GTL2

 LDA NA%,X              \ Copy the X-th byte of NA% to the X-th byte of INWK
 STA INWK,X

 DEX                    \ Decrement the loop counter

 BPL GTL2               \ Loop back until we have copied all 8 bytes

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: GTNME
\
\ Get the commander's name for loading or saving a commander file. The name is
\ stored at INWK, terminated by a return character (13).
\
\ If Escape is pressed or a blank name is entered, then INWK is set to the name
\ from the last saved commander block.
\
\ ******************************************************************************

.GTNME
{
 LDA #1                 \ Clear the top part of the screen, draw a white border,
 JSR TT66               \ and set the current view type in QQ11 to 1

 LDA #123               \ Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
 JSR TT27

 JSR DEL8               \ Wait for 8/50 of a second (0.16 seconds)

 LDA #%10000001         \ Clear 6522 System VIA interrupt enable register IER
 STA SHEILA+&4E         \ (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt
                        \ which comes from the keyboard)

 LDA #15                \ Perform a *FX 15,0 command (flush all buffers)
 TAX
 JSR OSBYTE

 LDX #LO(RLINE)         \ Call OSWORD with A = 0 and (Y X) pointing to the
 LDY #HI(RLINE)         \ configuration block below, which reads a line from
 LDA #0                 \ the current input stream (i.e. the keyboard)
 JSR OSWORD

\LDA #%00000001         \ These instructions are commented out in the original
\STA SHEILA+&4E         \ source, but they would set 6522 System VIA interrupt
                        \ enable register IER (SHEILA &4E) bit 1 (i.e. disable
                        \ the CA2 interrupt, which comes from the keyboard)

 BCS TR1                \ The C flag will be set if we pressed Escape when
                        \ entering the name, in which case jump to TR1 to copy
                        \ the last saved commander's name from NA% to INWK
                        \ and return from the subroutine there

 TYA                    \ The OSWORD call returns the length of the commander's
 BEQ TR1                \ name in Y, so transfer this to A, and if it is zero
                        \ (a blank name was entered), jump to TR1 to copy
                        \ the last saved commander's name from NA% to INWK
                        \ and return from the subroutine there

 JMP TT67               \ We have a name, so jump to TT67 to print a newline
                        \ and return from the subroutine using a tail call

.RLINE                  \ This is the OSWORD configuration block used above

 EQUW INWK              \ The address to store the input, so the commander's
                        \ name will be stored in INWK as it is typed

 EQUB 7                 \ Maximum line length = 7, as that's the maximum size
                        \ for a commander's name

 EQUB '!'               \ Allow ASCII characters from "!" through to "z" in
 EQUB 'z'               \ the name
}

\ ******************************************************************************
\
\ Subroutine: ZERO
\
\ Zero-fill pages &9, &A, &B, &C and &D.
\
\ ******************************************************************************

.ZERO
{
 LDX #&D                \ Point X to page &D

.ZEL

 JSR ZES1               \ Call ZES1 below to zero-fill the page in X

 DEX                    \ Decrement X to point to the next page

 CPX #9                 \ If X is > 9 (i.e. is &A, &B or &C), then loop back
 BNE ZEL                \ up to clear the next page

                        \ Then fall through into ZES1 with X set to 9, so we
                        \ clear page &9 too
}

\ ******************************************************************************
\
\ Subroutine: ZES1
\
\ Zero-fill the page whose number is in X.
\
\ Arguments:
\
\   X                   The page we want to zero-fill
\
\ ******************************************************************************

.ZES1
{
 LDY #0                 \ If we set Y = SC = 0 and fall through into ZES2
 STY SC                 \ below, then we will zero-fill 255 bytes starting from
                        \ SC - in other words, we will zero-fill the whole of
                        \ page X
}

\ ******************************************************************************
\
\ Subroutine: ZES2
\
\ Zero-fill the page whose number is in X, from position SC to SC + Y.
\
\ If Y is 0, this will zero-fill 255 bytes starting from SC
\
\ If Y is negative, this will zero-fill from SC + Y to SC - 1, i.e. the Y bytes
\ before SC
\
\ Arguments:
\
\   X                   The page where we want to zero-fill
\
\   Y                   A negative value denoting how many bytes before SC we
\                       want to start zeroing
\
\   SC                  The position in the page where we should zero fill up to
\
\ ******************************************************************************

.ZES2
{
 LDA #0                 \ Load X with the byte we want to fill the memory block
                        \ with - i.e. zero

 STX SC+1               \ We want to zero-fill page X, so store this in the
                        \ high byte of SC, so the 16-bit address in SC and
                        \ SC+1 is now pointing to the SC-th byte of page X

.ZEL1

 STA (SC),Y             \ Zero the Y-th byte of the block pointed to by SC,
                        \ so that's effectively the Y-th byte before SC

 INY                    \ Increment the loop counter

 BNE ZEL1               \ Loop back to zero the next byte

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: SVE
\
\ Save the commander file.
\
\ ******************************************************************************

.SVE
{
 JSR GTNME              \ Clear the screen and ask for the commander filename
                        \ to save, storing the name at INWK

 JSR TRNME              \ Transfer the commander filename from INWK to NA%

 JSR ZERO               \ Zero-fill pages &9, &A, &B, &C and &D

 LSR SVC                \ Halve the save count value in SVC

 LDX #NT%               \ We now want to copy the current commander data block
                        \ from location TP to the last saved commander block at
                        \ NA%+8, so set a counter in X to copy the NT% bytes in
                        \ the commander data block
                        \
                        \ We also want to copy the data block to another
                        \ location &0B00, which is normally used for the ship
                        \ lines heap

.SVL1

 LDA TP,X               \ Copy the X-th byte of TP to the X-th byte of &B00
 STA &B00,X             \ and NA%+8
 STA NA%+8,X

 DEX                    \ Decrement the loop counter

 BPL SVL1               \ Loop back until we have copied all NT% bytes

 JSR CHECK              \ Call CHECK to calculate the checksum for the last
                        \ saved commander and return it in A

 STA CHK                \ Store the checksum in CHK, which is at the end of the
                        \ last saved commander block

 PHA                    \ Store the checksum on the stack

 ORA #%10000000         \ Set K = checksum with bit 7 set
 STA K

 EOR COK                \ Set K+2 = K EOR'd with COK
 STA K+2

 EOR CASH+2             \ Set K+1 = K+2 EOR'd with the third cash byte
 STA K+1

 EOR #%01011010         \ Set K+3 = K+1 EOR 01011010 EOR high byte of kill tally
 EOR TALLY+1
 STA K+3

 JSR BPRNT              \ Print the competition number stored in K to K+3. The
                        \ values of the C flag and U will affect how this is
                        \ printed, which is odd as they appear to be random (C
                        \ is last set in CHECK and could go either way, and it's
                        \ hard to know when U was last set as it's a temporary
                        \ variable in zero page, so isn't reset by ZERO). I
                        \ wonder if the competition number can ever get printed
                        \ out incorrectly, with a decimal point and the wrong
                        \ number of digits?

 JSR TT67               \ Call TT67 twice to print two newlines
 JSR TT67

 PLA                    \ Restore the checksum from the stack

 STA &B00+NT%           \ Store the checksum in the last byte of the save file
                        \ at &0B00 (the equivalent of CHK in the last saved
                        \ block)

 EOR #&A9               \ Store the checksum EOR &A9 in CHK2, the penultimate
 STA CHK2               \ byte of the last saved commander block

 STA &AFF+NT%           \ Store the checksum EOR &A9 in the penultimate byte of
                        \ the save file at &0B00 (the equivalent of CHK2 in the
                        \ last saved block)

 LDY #&B                \ Set up an OSFILE block at &0C00, containing:
 STY &C0B               \
 INY                    \ Start address for save = &00000B00 in &0C0A to &0C0D
 STY &C0F               \
                        \ End address for save = &00000C00 in &0C0E to &0C11
                        \
                        \ Y is left containing &C which we use below

 LDA #%10000001         \ Clear 6522 System VIA interrupt enable register IER
 STA SHEILA+&4E         \ (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
                        \ which comes from the keyboard)

 INC SVN                \ Increment SVN to indicate we are about to start saving
                        \ (SVN is actually a screen address at &7FFD)

 LDA #0                 \ Call QUS1 with A = 0, Y = &C to save the commander
 JSR QUS1               \ file with the filename we copied to INWK at the start
                        \ of this routine

 LDX #0                 \ Set X = 0 for storing in SVN below

 \STX SHEILA+&4E        \ This instruction is commented out in the original
                        \ source. It would affect the 6522 System VIA interrupt
                        \ enable register IER (SHEILA &4E) if any of bits 0-6
                        \ of X were set, but they aren't, so this instruction
                        \ would have no effect anyway

 \DEX                   \ This instruction is commented out in the original
                        \ source. It would end up setting SVN to &FF, which
                        \ affects the logic in the IRQ1 handler

 STX SVN                \ Set SVN to 0 to indicate we are done saving

 JMP BAY                \ Go to the docking bay (i.e. show Status Mode)
}

\ ******************************************************************************
\
\ Subroutine: QUS1
\
\ Load or save the commander file. The filename should be stored at INWK,
\ terminated with a carriage return (13), and the routine should be called with
\ Y set to &C.
\
\ Arguments:
\
\   A                   File operation to be performed. Can be one of the
\                       following:
\
\                         * 0 (save file)
\
\                         * &FF (load file)
\
\   Y                   Points to the page number containing the OSFILE block,
\                       which must be &C because that's where the pointer to the
\                       filename in INWK is stored below (by the STX &C00
\                       instruction)
\
\ ******************************************************************************

.QUS1
{
 LDX #INWK              \ Store a pointer to INWK at the start of the block at
 STX &0C00              \ &0C00, in byte 0 because INWK is in zero page

 LDX #0                 \ Set X to 0 so (Y X) = &0C00

 JMP OSFILE             \ Jump to OSFILE to do the file operation specified in
                        \ &0C00, returning from the subroutine using a tail
                        \ call
}

\ ******************************************************************************
\
\ Subroutine: LOD
\
\ Load a commander file. The filename should be stored at INWK, terminated with
\ a carriage return (13).
\
\ ******************************************************************************

.LOD
{
 LDX #2                 \ Enable the Escape key and clear memory if the Break
 JSR FX200              \ key is pressed (*FX 200,2)

 JSR ZERO               \ Zero-fill pages &9, &A, &B, &C and &D

 LDY #&B                \ Set up an OSFILE block at &0C00, containing:
 STY &0C03              \
 INC &0C0B              \ Load address = &00000B00 in &0C02 to &0C05
 INY                    \
                        \ Length of file = &00000100 in &0C0A to &0C0D
                        \
                        \ Y is left containing &C which we use next

 LDA #&FF               \ Call QUS1 with A = &FF, Y = &C to load the commander
 JSR QUS1               \ file at address &0B00

 LDA &B00               \ If the first byte of the loaded file has bit 7 set,
 BMI SPS1+1             \ jump to SPS+1, which is the second byte of an LDA #0
                        \ instruction, i.e. a BRK instruction, which will force
                        \ an interrupt to call the address in BRKV, which is set
                        \ to BR1... so this instruction restarts the game from
                        \ the title screen. Valid commander files for the tape
                        \ version of Elite only have 0 for the first byte, while
                        \ the disc version can have 0, 1, 2, &A or &E, so having
                        \ bit 7 set is invalid anyway

 LDX #NT%               \ We have successfully loaded the commander file at
                        \ &0B00, so now we want to copy it to the last saved
                        \ commander data block at NA%+8, so we set up a counter
                        \ in X to copy NT% bytes

.LOL1

 LDA &B00,X             \ Copy the X-th byte of &0B00 to the X-th byte of NA%+8
 STA NA%+8,X

 DEX                    \ Decrement the loop counter

 BPL LOL1               \ Loop back until we have copied all NT% bytes

 LDX #3                 \ Fall through into FX200 to disable the Escape key and
                        \ clear memory if the Break key is pressed (*FX 200,3)
                        \ and return from the subroutine there
}

\ ******************************************************************************
\
\ Subroutine: FX200
\
\ Performs a *FX 200,X command, which controls the behaviour of the Escape and
\ Break keys.
\
\ ******************************************************************************

.FX200
{
 LDY #0                 \ Call OSBYTE &C8 (200) with Y = 0, so new value is
 LDA #200               \ set to X
 JMP OSBYTE

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: SPS1
\
\ Calculate the vector to the planet and store it in XX15. ******************************************************************************

.SPS1
{
 LDX #0                 \ Copy the two high bytes of the planet's x-coordinate
 JSR SPS3               \ into K3(2 1 0), separating out the sign bit into K3+2

 LDX #3                 \ Copy the two high bytes of the planet's y-coordinate
 JSR SPS3               \ into K3(5 4 3), separating out the sign bit into K3+5

 LDX #6                 \ Copy the two high bytes of the planet's z-coordinate
 JSR SPS3               \ into K3(8 7 6), separating out the sign bit into K3+8

                        \ Fall through into TAS2 to build XX15 from K3
}

\ ******************************************************************************
\
\ Subroutine: TAS2
\
\ Normalise the vector in K3, which has 16-bit values and separate sign bits,
\ and store the normalised version in XX15 as a signed 8-bit vector.
\
\ A normalised vector (also known as a unit vector) has length 1, so this
\ routine takes an existing vector in K3 and scales it so the length of the
\ new vector is 1. This is used in two places: when drawing the compass, and
\ when applying AI tactics to ships.
\
\ We do this in two stages. This stage shifts the 16-bit vector coordinates in
\ K3 to the left as far as they will go without losing any bits off the end, so
\ we can then take the high bytes and use them as the most accurate 8-bit vector
\ to normalise. Then the next stage (in routine NORM) does the normalisation.
\
\ Arguments:
\
\   K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
\                       x_sign is just bit 7
\
\   K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
\                       y_sign is just bit 7
\
\   K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
\                       z_sign is just bit 7
\
\ Returns:
\
\   XX15                The normalised vector, with:
\
\                         * The x-coordinate in XX15
\
\                         * The y-coordinate in XX15+1
\
\                         * The z-coordinate in XX15+2
\
\ ******************************************************************************

.TAS2
{
 LDA K3                 \ OR the three low bytes and 1 to get a byte that has
 ORA K3+3               \ a 1 wherever any of the three low bytes has a 1
 ORA K3+6               \ (as well as always having bit 0 set), and store in
 ORA #1                 \ K3+9
 STA K3+9

 LDA K3+1               \ OR the three high bytes to get a byte in A that has a
 ORA K3+4               \ 1 wherever any of the three high bytes has a 1
 ORA K3+7

                        \ (A K3+9) now has a 1 wherever any of the 16-bit
                        \ values in K3 has a 1
.TAL2

 ASL K3+9               \ Shift (A K3+9) to the left, so bit 7 of the high byte
 ROL A                  \ goes into the C flag

 BCS TA2                \ If the left shift pushed a 1 out of the end, then we
                        \ know that at least one of the coordinates has a 1 in
                        \ this position, so jump to TA2 as we can't shift the
                        \ values in K3 any further to the left

 ASL K3                 \ Shift K3(1 0), the x-coordinate, to the left
 ROL K3+1

 ASL K3+3               \ Shift K3(4 3), the y-coordinate, to the left
 ROL K3+4

 ASL K3+6               \ Shift K3(6 7), the z-coordinate, to the left
 ROL K3+7

 BCC TAL2               \ Jump back to TAL2 to do another shift left (this BCC
                        \ is effectively a JMP as we know bit 7 of K3+7 is not a
                        \ 1, as otherwise bit 7 of A would have been a 1 and we
                        \ would have taken the BCS above)

.TA2                    \ exited, Build XX15(0to2) from (raw) K3(1to8)

 LDA K3+1               \ Fetch the high byte of the x-coordinate from our left-
 LSR A                  \ shifted K3, shift it right to clear bit 7, stick the
 ORA K3+2               \ sign bit in there from the x_sign part of K3, and
 STA XX15               \ store the resulting signed 8-bit x-coordinate in XX15

 LDA K3+4               \ Fetch the high byte of the y-coordinate from our left-
 LSR A                  \ shifted K3, shift it right to clear bit 7, stick the
 ORA K3+5               \ sign bit in there from the y_sign part of K3, and
 STA XX15+1             \ store the resulting signed 8-bit y-coordinate in
                        \ XX15+1

 LDA K3+7               \ Fetch the high byte of the z-coordinate from our left-
 LSR A                  \ shifted K3, shift it right to clear bit 7, stick the
 ORA K3+8               \ sign bit in there from the z_sign part of K3, and
 STA XX15+2             \ store the resulting signed 8-bit  z-coordinate in
                        \ XX15+2

                        \ Now we have a signed 8-bit version of the vector K3 in
                        \ XX15, so fall through into NORM to normalise it
}

\ ******************************************************************************
\
\ Subroutine: NORM
\
\ Normalise the three-coordinate vector in XX15.
\
\ We do this by dividing each of the three coordinates by the length of the
\ vector, which we can calculate using Pythagoras. Once normalised, 96 (&E0) is
\ used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
\ represent -1. This enables us to represent fractional values of less than 1
\ using integers.
\
\ Arguments:
\
\   XX15                The vector to normalise, with:
\
\                         * The x-coordinate in XX15
\
\                         * The y-coordinate in XX15+1
\
\                         * The z-coordinate in XX15+2
\
\ Returns:
\
\   XX15                The normalised vector
\
\ Other entry points:
\
\   NO1                 Contains an RTS
\
\ ******************************************************************************

.NORM
{
 LDA XX15               \ Fetch the x-coordinate into A

 JSR SQUA               \ Set (A P) = A * A = x^2

 STA R                  \ Set (R Q) = (A P) = x^2
 LDA P
 STA Q

 LDA XX15+1             \ Fetch the y-coordinate into A

 JSR SQUA               \ Set (A P) = A * A = y^2

 STA T                  \ Set (T P) = (A P) = y^2

 LDA P                  \ Set (R Q) = (R Q) + (T P) = x^2 + y^2
 ADC Q                  \
 STA Q                  \ First, doing the low bytes, Q = Q + P

 LDA T                  \ And then the high bytes, R = R + T
 ADC R
 STA R

 LDA XX15+2             \ Fetch the z-coordinate into A

 JSR SQUA               \ Set (A P) = A * A = z^2

 STA T                  \ Set (T P) = (A P) = z^2

 LDA P                  \ Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
 ADC Q                  \
 STA Q                  \ First, doing the low bytes, Q = Q + P

 LDA T                  \ And then the high bytes, R = R + T
 ADC R
 STA R

 JSR LL5                \ We now have the following:
                        \
                        \ (R Q) = x^2 + y^2 + z^2
                        \
                        \ so we can call LL5 to use Pythagoras to get:
                        \
                        \ Q = SQRT(R Q)
                        \   = SQRT(x^2 + y^2 + z^2)
                        \
                        \ So Q now contains the length of the vector (x, y, z),
                        \ and we can normalise the vector by dividing each of
                        \ the coordinates by this value, which we do by calling
                        \ routine TIS2. TIS2 returns the divided figure, using
                        \ 96 to represent 1 and 96 with bit 7 set for -1

 LDA XX15               \ Call TIS2 to divide the x-coordinate in XX15 by Q,
 JSR TIS2               \ with 1 being represented by 96
 STA XX15

 LDA XX15+1             \ Call TIS2 to divide the y-coordinate in XX15+1 by Q,
 JSR TIS2               \ with 1 being represented by 96
 STA XX15+1

 LDA XX15+2             \ Call TIS2 to divide the z-coordinate in XX15+2 by Q,
 JSR TIS2               \ with 1 being represented by 96
 STA XX15+2

.^NO1

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: RDKEY
\
\ Scan the keyboard, starting with internal key number 16 (Q) and working
\ through the set of internal key numbers (see p.142 of the Advanced User Guide
\ for a list of internal key numbers).
\
\ This routine is effectively the same as OSBYTE &7A, though the OSBYTE call
\ preserves A, unlike this routine.
\
\ Returns:
\
\   X                   If a key is being pressed, X contains the internal key
\                       number, otherwise it contains 0
\
\   A                   Contains the same as X
\
\ ******************************************************************************

.RDKEY
{
 LDX #16                \ Start the scan with internal key number 16 (Q)

.Rd1

 JSR DKS4               \ Scan the keyboard to see if the key in X is currently
                        \ being pressed

 BMI Rd2                \ Jump to Rd2 if this key is being pressed (in which
                        \ case DKS4 will have returned a negative value,
                        \ specifically 128 + X)

 INX                    \ Increment the key number

 BPL Rd1                \ Loop back to test the next key, ending the loop when
                        \ X is negative (i.e. 128)

 TXA                    \ If we get here, nothing is being pressed, so copy X
                        \ into A so that X = A = 128

.Rd2

 EOR #128               \ EOR A with 128, to switch off bit 7, so A now
                        \ contains 0 if no key has been pressed, or the
                        \ internal key number if it has been pressed

 TAX                    \ Copy A into X

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: ECMOF
\
\ Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
\ E.C.M. switching off).
\
\ ******************************************************************************

.ECMOF
{
 LDA #0                 \ Set ECMA and ECMB to 0 to indicate that no E.C.M. is
 STA ECMA               \ currently running
 STA ECMP

 JSR ECBLB              \ Update the E.C.M. indicator bulb on the dashboard

 LDA #72                \ Call the NOISE routine with A = 72 to make the sound
 BNE NOISE              \ of the E.C.M. being turned off and return from the
                        \ subroutine using a tail call (this BNE is effectively
                        \ a JMP as A will never be zero)
}

\ ******************************************************************************
\
\ Subroutine: EXNO3
\
\ Make the sound of death in the cold, hard vacuum of space. Apparently, in
\ Elite space, everyone can hear you scream.
\
\ This routine also makes the sound of a destroyed cargo canister if we don't
\ get scooping right, the sound of us colliding with another ship, and the sound
\ of us being hit with depleted shields. It is not a good sound to hear.
\
\ ******************************************************************************

.EXNO3
{
 LDA #16                \ Call the NOISE routine with A = 16 to make the first
 JSR NOISE              \ death sound

 LDA #24                \ Call the NOISE routine with A = 24 to make the second
 BNE NOISE              \ death sound and return from the subroutine using a
                        \ tail call (this BNE is effectively a JMP as A will
                        \ never be zero)
}

\ ******************************************************************************
\
\ Subroutine: SFRMIS
\
\ An enemy has fired a missile, so add the missile to our universe if there is
\ room, and if there is, make the appropriate warnings and noises.
\
\ ******************************************************************************

.SFRMIS
{
 LDX #MSL               \ Set X to the ship type of a missile, and call SFS1-2
 JSR SFS1-2             \ to add the missile to our universe with an AI flag
                        \ of %11111110 (AI enabled, hostile, no E.C.M.)

 BCC NO1                \ The carry flag will be set if the call to SFS1-2 was
                        \ a success, so if it's clear, jump to NO1 to return
                        \ from the subroutine (as NO1 contains an RTS)

 LDA #120               \ Print recursive token 120 ("INCOMING MISSILE") as an
 JSR MESS               \ in-flight message

 LDA #48                \ Call the NOISE routine with A = 48 to make the sound
 BNE NOISE              \ of the missile being launched and return from the
                        \ subroutine using a tail call (this BNE is effectively
                        \ a JMP as A will never be zero)
}

\ ******************************************************************************
\
\ Subroutine: EXNO2
\
\ We have killed a ship, so increase the kill tally, displaying an iconic
\ message of encouragement if the kill total is a multiple of 256, and then
\ make a nearby explosion sound.
\
\ ******************************************************************************

.EXNO2
{
 INC TALLY              \ Increment the low byte of the kill count in TALLY

 BNE EXNO-2             \ If there is no carry, jump to the LDX #7 below (at
                        \ EXNO-2)

 INC TALLY+1            \ Increment the high byte of the kill count in TALLY

 LDA #101               \ The kill total is a multiple of 256, so it's time
 JSR MESS               \ for a pat on the back, so print recursive token 101
                        \ ("RIGHT ON COMMANDER!") as an in-flight message

 LDX #7                 \ Set X = 7 and fall through into EXNO to make the
                        \ sound of a ship exploding
}

\ ******************************************************************************
\
\ Subroutine: EXNO
\
\ Make the two-part explosion sound of us making a laser strike, or of another
\ ship exploding.
\
\ The volume of the first explosion is affected by the distance of the ship
\ being hit, with more distant ships being quieter. The value in X also affects
\ the volume of the first explosion, with a higher X giving a quieter sound
\ (so X can be used to differentiate a laser strike from an explosion).
\
\ Arguments:
\
\   X                   The larger the value of X, the fainter the explosion.
\                       Allowed values are:
\
\                         * 7  = explosion is louder (i.e. the ship has just
\                                exploded)
\
\                         * 15 = explosion is quieter (i.e. this is just a laser
\                                strike)
\
\ ******************************************************************************

.EXNO
{
 STX T                  \ Store the distance in T

 LDA #24                \ Set A = 24 to denote the sound of us making a hit or
 JSR NOS1               \ kill (part 1), and call NOS1 to set up the sound
                        \ block in XX16

 LDA INWK+7             \ Fetch z_hi, the distance of the ship being hit in
 LSR A                  \ terms of the z-axis (in and out of the screen), and
 LSR A                  \ divide by 4. If z_hi has either bit 6 or 7 set then
                        \ that ship is too far away to be shown on the scanner
                        \ (as per the SCAN routine), so we know the maximum
                        \ z_hi at this point is %00111111, and shifting z_hi
                        \ to the right twice gives us a maximum value of
                        \ %00001111

 AND T                  \ This reduces A to a maximum of X; X can be either
                        \ 7 = %0111 or 15 = %1111, so AND'ing with 15 will
                        \ not affect A, while AND'ing with 7 will clear bit
                        \ 3, reducing the maximum value in A to 7

 ORA #%11110001         \ The SOUND command's amplitude ranges from 0 (for no
                        \ sound) to -15 (full volume), so we can set bits 0 and
                        \ 4-7 in A, and keep bits 1-3 from the above to get
                        \ a value between -15 (%11110001) and -1 (%11111111),
                        \ with lower values of z_hi and argument X leading
                        \ to a more negative number (so the closer the ship or
                        \ the smaller the value of X, the louder the sound)

 STA XX16+2             \ The amplitude byte of the sound block in XX16 is in
                        \ byte 3 (where it's the low byte of the amplitude), so
                        \ this sets the amplitude to the value in A

 JSR NO3                \ Make the sound from our updated sound block in XX16

 LDA #16                \ Set A = 16 to denote we have made a hit or kill
                        \ (part 2), and fall through into NOISE to make the
                        \ sound

 EQUB &2C               \ Skip the next instruction by turning it into
                        \ &2C &A9 &20, or BIT &20A9, which does nothing bar
                        \ affecting the flags
}

\ ******************************************************************************
\
\ Subroutine: BEEP
\
\ Make a short, high beep.
\
\ ******************************************************************************

.BEEP
{
 LDA #32                \ Set A = 32 to denote a short, high beep, and fall
                        \ through into NOISE to make the sound
}

\ ******************************************************************************
\
\ Subroutine: NOISE
\
\ Make the sound whose number is in A.
\
\ Arguments:
\
\   A                   The number of the sound to be made. See the
\                       documentation for variable SFX for a list of sound
\                       numbers
\
\ ******************************************************************************

.NOISE
{
 JSR NOS1               \ Set up the sound block in XX16 for the sound in A and
                        \ fall through into NO3 to make the sound
}

\ ******************************************************************************
\
\ Subroutine: NO3
\
\ Make a sound from a prepared sound block in XX16 (if sound is enabled). See
\ routine NOS1 for details of preparing the XX16 sound block.
\
\ ******************************************************************************

.NO3
{
 LDX DNOIZ              \ If DNOIZ is non-zero, then sound is disabled, so
 BNE NO1                \ return from the subroutine

 LDX #LO(XX16)          \ Otherwise call OSWORD 7, with (Y X) pointing to the
 LDY #HI(XX16)          \ sound block in XX16. This makes the sound as
 LDA #7                 \ described in the documentation for variable SFX,
 JMP OSWORD             \ and returns from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: NOS1
\
\ Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
\ with Y indicating the sound number to copy (from the values in the sound
\ table at SFX). So, for example, if we call this routine with A = 40 (long,
\ low beep), the following bytes will be set in XX16 to XX16+7:
\
\   &13 &00 &F4 &00 &0C &00 &08 &00
\
\ This block will be passed to OSWORD 7 to make the sound, which expects the
\ four sound attributes as 16-bit big-endian values - in other words, with the
\ low byte first. So the above block would pass the values &0013, &00F4, &000C
\ and &0008 to the SOUND command when used with OSWORD 7, or:
\
\   SOUND &13, &F4, &0C, &08
\
\ as the high bytes are always zero.
\
\ Arguments:
\
\   A                   The sound number to copy from SFX to XX16, which is
\                       always a multiple of 8
\
\ ******************************************************************************

.NOS1
{
 LSR A                  \ Divide A by 2, and also clear the carry flag, as bit
                        \ of A is always zero

 ADC #3                 \ Set Y = A + 3, so Y now points to the last byte of
 TAY                    \ four within the block of four-byte values

 LDX #7                 \ We want to copy four bytes, spread out into an 8-byte
                        \ block, so set a counter in Y to cover 8 bytes

.NOL1

 LDA #0                 \ Set the X-th byte of XX16 to 0
 STA XX16,X

 DEX                    \ Decrement the destination byte pointer

 LDA SFX,Y              \ Set the X-th byte of XX16 to the value from SFX+Y
 STA XX16,X

 DEY                    \ Decrement the source byte pointer again

 DEX                    \ Decrement the destination byte pointer again

 BPL NOL1               \ Loop back for the next source byte

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Variable: KYTB
\
\ Keyboard table for in-flight controls. This table contains the internal key
\ codes for the flight keys (see p.142 of the Advanced User Guide for a list of
\ internal key numbers).
\
\ The pitch, roll, speed and laser keys (i.e. the seven primary flight
\ control keys) have bit 7 set, so they have 128 added to their internal
\ values. This doesn't appear to be used anywhere.
\
\ Note that KYTB actually points to the byte before the start of the table, so
\ the offset of the first key value is 1 (i.e. KYTB+1), not 0.
\
\ ******************************************************************************

KYTB = P% - 1           \ Point KYTB to the byte before the start of the table
{
                        \ These are the primary flight controls (pitch, roll,
                        \ speed and lasers):

 EQUB &68 + 128         \ ?         KYTB+1      Slow down
 EQUB &62 + 128         \ Space     KYTB+2      Speed up
 EQUB &66 + 128         \ <         KYTB+3      Roll left
 EQUB &67 + 128         \ >         KYTB+4      Roll right
 EQUB &42 + 128         \ X         KYTB+5      Pitch up
 EQUB &51 + 128         \ S         KYTB+6      Pitch down
 EQUB &41 + 128         \ A         KYTB+7      Fire lasers

                        \ These are the secondary flight controls:

 EQUB &60               \ Tab       KYTB+8      Energy bomb
 EQUB &70               \ Escape    KYTB+9      Launch escape pod
 EQUB &23               \ T         KYTB+10     Arm missile
 EQUB &35               \ U         KYTB+11     Unarm missile
 EQUB &65               \ M         KYTB+12     Fire missile
 EQUB &22               \ E         KYTB+13     E.C.M.
 EQUB &45               \ J         KYTB+14     In-system jump
 EQUB &52               \ C         KYTB+15     Docking computer
}

\ ******************************************************************************
\
\ Subroutine: DKS1
\
\ Scan the keyboard for the flight key given in register Y, where Y is the
\ offset into the KYTB table above (so we can scan for Space by setting Y to
\ 2, for example). If the key is pressed, set the corresponding byte in the
\ key logger at KL to &FF.
\
\ Arguments:
\
\   Y                   The offset into the KYTB table above of the key that we
\                       want to scan on the keyboard
\
\ ******************************************************************************

.DKS1
{
 LDX KYTB,Y             \ Get the internal key number from the Y-th byte of the
                        \ KYTB table above

 JSR DKS4               \ Call DKS4, which will set A and X to a negative value
                        \ if the key is being pressed

 BPL DKS2-1             \ The key is not being pressed, so return from the
                        \ subroutine (as DKS2-1 contains an RTS)

 LDX #&FF               \ Store &FF in the Y-th byte of the key logger at KL
 STX KL,Y

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: CTRL
\
\ Scan the keyboard to see if CTRL is currently pressed.
\
\ Returns:
\
\   X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
\                       pressed
\
\                       X = 1 if CTRL is not being pressed
\
\   A                   Contains the same as X
\
\ ******************************************************************************

.CTRL
{
 LDX #1                 \ Set X to the internal key number for CTRL and fall
                        \ through to DSK4 to scan the keyboard
}

\ ******************************************************************************
\
\ Subroutine: DKS4
\
\ Scan the keyboard to see if the key specified in X is currently being
\ pressed.
\
\ Arguments:
\
\   X                   The internal number of the key to check (see p.142 of
\                       the Advanced User Guide for a list of internal key
\                       numbers)
\
\ Returns:
\
\   X                   If the key in X is being pressed, X contains the
\                       original argument X, but with bit 7 set (i.e. X + 128).
\                       If the key in X is not being pressed, the value in X is
\                       unchanged
\
\   A                   Contains the same as X
\
\ ******************************************************************************

.DKS4
{
 LDA #3                 \ Set A to 3, so it's ready to send to SHEILA once
                        \ interrupts have been disabled

 SEI                    \ Disable interrupts so we can scan the keyboard
                        \ without being hijacked

 STA SHEILA+&40         \ Set 6522 System VIA output register ORB (SHEILA &40)
                        \ to %0011 to stop auto scan of keyboard

 LDA #%01111111         \ Set 6522 System VIA data direction register DDRA
 STA SHEILA+&43         \ (SHEILA &43) to %0111 1111. This sets the A registers
                        \ (IRA and ORA) so that
                        \
                        \ Bits 0-6 of ORA will sent to the keyboard
                        \
                        \ Bit 7 of IRA will be read from the keyboard

 STX SHEILA+&4F         \ Set 6522 System VIA output register ORA (SHEILA &4F)
                        \ to X, the key we want to scan for; bits 0-6 will be
                        \ sent to the keyboard, of which bits 0-3 determine the
                        \ keyboard column, and bits 4-6 the keyboard row

 LDX SHEILA+&4F         \ Read 6522 System VIA output register IRA (SHEILA &4F)
                        \ into X; bit 7 is the only bit that will have changed.
                        \ If the key is pressed, then bit 7 will be set (so X
                        \ will contain 128 + X), otherwise it will be clear (so
                        \ X will be unchanged)

 LDA #%00001011         \ Set 6522 System VIA output register ORB (SHEILA &40)
 STA SHEILA+&40         \ to %1011 to restart auto scan of keyboard

 CLI                    \ Allow interrupts again

 TXA                    \ Transfer X into A

 RTS
}

\ ******************************************************************************
\
\ Subroutine: DKS2
\
\ Return the value of ADC channel in X (used to read the joystick). The value
\ will be inverted if the game has been configured to reverse both joystick
\ channels (which can be done by pausing the game and pressing J).
\
\ Arguments:
\
\   X                   The ADC channel to read:
\
\                         * 1 = joystick X
\
\                         * 2 = joystick Y
\
\ Returns:
\
\   (A X)               The 16-bit value read from channel X, with the value
\                       inverted if the game has been configured to reverse the
\                       joystick
\
\ ******************************************************************************

.DKS2
{
 LDA #128               \ Call OSBYTE 128 to fetch the 16-bit value from ADC
 JSR OSBYTE             \ channel X, returning (Y X), i.e. the high byte in Y
                        \ and the low byte in X

 TYA                    \ Copy Y to A, so the result is now in (A X)

 EOR JSTE               \ The high byte A is now EOR'd with the value in
                        \ location JSTE, which contains &FF if both joystick
                        \ channels are reversed and 0 otherwise (so A now
                        \ contains the high byte but inverted, if that's what
                        \ the current settings say)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DKS3
\
\ Toggle a configuration setting and emit a beep. This is called when the game
\ is paused and a key is pressed that changes the games's configuration.
\ Specifically, this routine toggles the configuration settings for the
\ following keys:
\
\   * Caps Lock toggles keyboard flight damping (&40)
\   * A toggles keyboard auto-recentre (&41)
\   * X toggles author names on start-up screen (&42)
\   * F toggles flashing console bars (&43)
\   * Y toggles reverse joystick Y channel (&44)
\   * J toggles reverse both joystick channels (&45)
\   * K toggles keyboard and joystick (&46)
\
\ The numbers in brackets are the internal key numbers (see p.142 of the
\ Advanced User Guide for a list of internal key numbers). We pass the key that
\ has been pressed in X, and the configuration option to check it against in Y,
\ so this routine is typically called in a loop that loops through the various
\ configuration options.
\
\ Arguments:
\
\   X                   The internal number of the key that's been pressed
\
\   Y                   The internal number of the configuration key to check
\                       against, from the list above (i.e. Y must be from &40 to
\                       &46)
\
\ ******************************************************************************

.DKS3
{
 STY T                  \ Store the configuration key argument in T

 CPX T                  \ If X <> Y, jump to Dk3 to return from the subroutine
 BNE Dk3

                        \ We have a match between X and Y, so now to toggle
                        \ the relevant configuration byte. Caps Lock has a key
                        \ value of &40 and has its configuration byte at
                        \ location DAMP, A has a value of &41 and has its byte
                        \ at location DJD, which is DAMP+1, and so on. So we
                        \ can toggle the configuration byte by changing the
                        \ byte at DAMP + (X - &40), or to put it in indexing
                        \ terms, DAMP-&40,X. It's no coincidence that the
                        \ game's configuration bytes are set up in this order
                        \ and with these keys (and this is also why the sound
                        \ on/off keys are dealt with elsewhere, as the internal
                        \ key for S and Q are &51 and &10, which don't fit
                        \ nicely into this approach)

 LDA DAMP-&40,X         \ Fetch the byte from DAMP + (X - &40), invert it and
 EOR #&FF               \ put it back (0 means no and &FF means yes in the
 STA DAMP-&40,X         \ configuration bytes, so this toggles the setting)

 JSR BELL               \ Make a beep sound so we know something has happened

 JSR DELAY              \ Wait for Y vertical syncs (Y is between 64 and 70, so
                        \ this is always a bit longer than a second)

 LDY T                  \ Restore the configuration key argument into Y

.Dk3

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: DKJ1
\
\ Read joystick flight controls. Specifically, scan the keyboard for the speed
\ up and slow down keys, and read the joystick's fire button and X and Y axes,
\ storing the results in the key logger and the joystick position variables.
\
\ This routine is only called if joysticks are enabled (JSTK = non-zero).
\
\ ******************************************************************************

.DKJ1
{
 LDY #1                 \ Update the key logger for key 1 in the KYTB table, so
 JSR DKS1               \ KY1 will be &FF if ? (slow down) is being pressed

 INY                    \ Update the key logger for key 2 in the KYTB table, so
 JSR DKS1               \ KY2 will be &FF if Space (speed up) is being pressed

 LDA SHEILA+&40         \ Read 6522 System VIA input register IRB (SHEILA &40)

 TAX                    \ This instruction doesn't seem to have any effect, as
                        \ X is overwritten in a few instructions. When the
                        \ joystick is checked in a similar way in the TITLE
                        \ subroutine for the "Press Fire Or Space,Commander."
                        \ stage of the start-up screen, there's another
                        \ unnecessary TAX instruction present, but there it's
                        \ commented out

 AND #%00010000         \ Bit 4 of IRB (PB4) is clear if joystick 1's fire
                        \ button is pressed, otherwise it is set, so AND'ing
                        \ the value of IRB with %10000 extracts this bit

 EOR #%00010000         \ Flip bit 4 so that it's set if the fire button has
 STA KY7                \ been pressed, and store the result in the keyboard
                        \ logger at location KY7, which is also where the A key
                        \ (fire lasers) key is logged

 LDX #1                 \ Call DKS2 to fetch the value of ADC channel 1 (the
 JSR DKS2               \ joystick X value) into (A X), and OR A with 1. This
 ORA #1                 \ ensures that the high byte is at least 1, and then we
 STA JSTX               \ store the result in JSTX

 LDX #2                 \ Call DKS2 to fetch the value of ADC channel 2 (the
 JSR DKS2               \ joystick Y value) into (A X), and EOR A with JSTGY.
 EOR JSTGY              \ JSTGY will be &FF if the game is configured to
 STA JSTY               \ reverse the joystick Y channel, so this EOR does
                        \ exactly that, and then we store the result in JSTY

 JMP DK4                \ We are done scanning the joystick flight controls,
                        \ so jump to DK4 to scan for other keys, using a tail
                        \ call so we can return from the subroutine there
}

\ ******************************************************************************
\
\ Subroutine: U%
\
\ Clear the key logger (from KY1 through KY19).
\
\ Returns:
\
\   A                   A is set to 0
\
\ ******************************************************************************

.U%
{
 LDA #0                 \ Set A to 0, as this means "key not pressed" in the
                        \ key logger at KL

 LDY #15                \ We want to clear the 15 key logger locations from
                        \ KY1 to KY19, so set a counter in Y. We don't want to
                        \ clear the first key logger location, at KL, as the
                        \ keyboard table at KYTB starts with offset 1, not 0,
                        \ so KL is not technically part of the key logger
                        \ (it's actually used for logging keys that don't
                        \ appear in the keyboard table, and which therefore
                        \ don't use the key logger)

.DKL3

 STA KL,Y               \ Store 0 in the Y-th byte of the key logger

 DEY                    \ Decrement the counter

 BNE DKL3               \ And loop back for the next key

 RTS
}

\ ******************************************************************************
\
\ Subroutine: DOKEY
\
\ Scan for the seven primary flight controls (or the equivalent on joystick),
\ pause and configuration keys, and secondary flight controls, and update the
\ key logger accordingly. Specifically:
\
\   * If we are on keyboard configuration, clear the key logger and update it
\     for the seven primary flight controls, and update the roll and pitch
\     rates accordingly.
\
\   * If we are on joystick configuration, clear the key logger and jump to
\     DKJ1, which reads the joystick equivalents of the primary flight
\     controls.
\
\ Both options end up at DK4 to scan for other keys, beyond the seven primary
\ flight controls.
\
\ ******************************************************************************

.DOKEY
{
 JSR U%                 \ Call U% to clear the key logger

 LDA JSTK               \ If JSTK is non-zero, then we are configured to use
 BNE DKJ1               \ the joystick rather than keyboard, so jump to DKJ1
                        \ to read the joystick flight controls, before jumping
                        \ to DK4 below

 LDY #7                 \ We're going to work our way through the primary flight
                        \ control keys (pitch, roll, speed and laser), so set a
                        \ counter in Y so we can loop through all 7

.DKL2

 JSR DKS1               \ Call DKS1 to see if the KYTB key at offset Y is being
                        \ pressed, and set the key logger accordingly

 DEY                    \ Decrement the loop counter

 BNE DKL2               \ Loop back for the next key, working our way from A at
                        \ KYTB+7 down to ? at KYTB+1

 LDX JSTX               \ Set X = JSTX, the current roll rate (as shown in the
                        \ RL indicator on the dashboard)

 LDA #7                 \ Set A to 7, which is the amount we want to alter the
                        \ roll rate by if the roll keys are being pressed

 LDY KL+3               \ If the < key is being pressed, then call the BUMP2
 BEQ P%+5               \ routine to increase the roll rate in X by A
 JSR BUMP2

 LDY KL+4               \ If the > key is being pressed, then call the REDU2
 BEQ P%+5               \ routine to decrease the roll rate in X by A, taking
 JSR REDU2              \ the keyboard auto re-centre setting into account

 STX JSTX               \ Store the updated roll rate in JSTX

 ASL A                  \ Double the value of A, to 14

 LDX JSTY               \ Set X = JSTY, the current pitch rate (as shown in the
                        \ DC indicator on the dashboard)

 LDY KL+5               \ If the > key is being pressed, then call the REDU2
 BEQ P%+5               \ routine to decrease the pitch rate in X by A, taking
 JSR REDU2              \ the keyboard auto re-centre setting into account

 LDY KL+6               \ If the S key is being pressed, then call the BUMP2
 BEQ P%+5               \ routine to increase the pitch rate in X by A
 JSR BUMP2

 STX JSTY               \ Store the updated roll rate in JSTY

                        \ Fall through into DK4 to scan for other keys
}

\ ******************************************************************************
\
\ Subroutine: DK4
\
\ Scan for pause and configuration keys, and if this is a space view, also scan
\ for secondary flight controls.
\
\ Specifically:
\
\   * Scan for the pause button (COPY) and if it's pressed, pause the game and
\     process any configuration key presses until the game is unpaused (DELETE)
\
\   * If this is a space view, scan for secondary flight keys and update the
\     relevant bytes in the key logger
\
\ ******************************************************************************

.DK4
{
 JSR RDKEY              \ Scan the keyboard from Q upwards and fetch any key
                        \ press into X

 STX KL                 \ Store X in KL, byte 0 of the key logger

 CPX #&69               \ If COPY is not being pressed, jump to DK2 below,
 BNE DK2                \ otherwise let's process the configuration keys

.FREEZE                 \ COPY is being pressed, so we enter a loop that
                        \ listens for configuration keys, and we keep looping
                        \ until we detect a DELETE keypress. This effectively
                        \ pauses the game when COPY is pressed, and unpauses
                        \ it when DELETE is pressed

 JSR WSCAN              \ Call WSCAN to wait for the vertical sync, so the whole
                        \ screen gets drawn

 JSR RDKEY              \ Scan the keyboard from Q upwards and fetch any key
                        \ press into X

 CPX #&51               \ If S is not being pressed, skip to DK6
 BNE DK6

 LDA #0                 \ S is being pressed, so set DNOIZ to 0 to turn the
 STA DNOIZ              \ sound on

.DK6

 LDY #&40               \ We now want to loop through the keys that toggle
                        \ various settings. These have internal key numbers
                        \ between &40 (Caps Lock) and &46 (K), so we set up the
                        \ first key number in Y to act as a loop counter. See
                        \ subroutine DKS3 for more details on this

.DKL4

 JSR DKS3               \ Call DKS3 to scan for the key given in Y, and toggle
                        \ the relevant setting if it is pressed

 INY                    \ Increment Y to point to the next toggle key

 CPY #&47               \ The last toggle key is &46 (K), so check whether we
                        \ have just done that one

 BNE DKL4               \ If not, loop back to check for the next toggle key

.DK55

 CPX #&10               \ If Q is not being pressed, skip to DK7
 BNE DK7

 STX DNOIZ              \ S is being pressed, so set DNOIZ to X, which is
                        \ non-zero (&10), so this will turn the sound off

.DK7

 CPX #&70               \ If Escape is not being pressed, skip over the next
 BNE P%+5               \ instruction

 JMP DEATH2             \ Escape is being pressed, so jump to DEATH2 to end
                        \ the game

 CPX #&59               \ If DELETE is not being pressed, we are still paused,
 BNE FREEZE             \ so loop back up to keep listening for configuration
                        \ keys, otherwise fall through into the rest of the
                        \ key detection code, which unpauses the game

.DK2

 LDA QQ11               \ If the current view is non-zero (i.e. not a space
 BNE DK5                \ view), return from the subroutine (as DK5 contains
                        \ an RTS)

 LDY #15                \ This is a space view, so now we want to check for all
                        \ the secondary flight keys. The internal key numbers
                        \ are in the keyboard table KYTB from KYTB+8 to
                        \ KYTB+15, and their key logger locations are from KL+8
                        \ to KL+15. So set a decreasing counter in Y for the
                        \ index, starting at 15, so we can loop through them

 LDA #&FF               \ Set A to &FF so we can store this in the keyboard
                        \ logger for keys that are being pressed

.DKL1

 LDX KYTB,Y             \ Get the internal key value of the Y-th flight key
                        \ the KYTB keyboard table

 CPX KL                 \ We stored the key that's being pressed in Kl above,
                        \ so check to see if the Y-th flight key is being
                        \ pressed

 BNE DK1                \ If it is not being pressed, skip to DK1 below

 STA KL,Y               \ The Y-th flight key is being pressed, so set that
                        \ key's location in the key logger to &FF

.DK1

 DEY                    \ Decrement the loop counter

 CPY #7                 \ Have we just done the last key?

 BNE DKL1               \ If not, loop back to process the next key

.DK5

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TT217
\
\ Scan the keyboard until a key is pressed, and return the key's ASCII code.
\ If, on entry, a key is already being held down, then wait until that key is
\ released first (so this routine detects the first key down event following
\ the subroutine call).
\
\ Returns:
\
\   X                   The ASCII code of the key that was pressed
\
\   A                   Contains the same as X
\
\   Y                   Y is preserved
\
\ Other entry points:
\
\   out                 Contains an RTS
\
\ ******************************************************************************

.TT217
{
 STY YSAV               \ Store Y in temporary storage, so we can restore it
                        \ later

.t

 JSR DELAY-5            \ Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
                        \ don't take up too much CPU time while looping round

 JSR RDKEY              \ Scan the keyboard, starting from Q

 BNE t                  \ If a key was already being held down when we entered
                        \ this routine, keep looping back up to t, until the
                        \ key is released

.t2

 JSR RDKEY              \ Any pre-existing key press is now gone, so we can
                        \ start scanning the keyboard again, starting from Q

 BEQ t2                 \ Keep looping up to t2 until a key is pressed

 TAY                    \ Copy A to Y, so Y contains the internal key number
                        \ of the key pressed

 LDA (TRTB%),Y          \ The address in TRTB% points to the MOS key
                        \ translation table, which is used to translate
                        \ internal key values to ASCII, so this fetches the
                        \ key's ASCII code into A

 LDY YSAV               \ Restore the original value of Y we stored above

 TAX                    \ Copy A into X

.^out

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: me1
\
\ Erase an old in-flight message and display a new one.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\   X                   Must be set to 0
\
\ ******************************************************************************

.me1
{
 STX DLY                \ Set the message delay in DLY to 0, so any new
                        \ in-flight messages will be shown instantly

 PHA                    \ Store the new message token we want to print

 LDA MCH                \ Set A to the token number of the message that is
 JSR mes9               \ currently on screen, and call mes9 to print it (which
                        \ will remove it from the screen, as printing is done
                        \ using EOR logic)

 PLA                    \ Restore the new message token

 EQUB &2C               \ Fall through into me1 to print the new message, but
                        \ skip the first instruction by turning it into
                        \ &2C &A9 &6C, or BIT &6CA9, which does nothing bar
                        \ affecting the flags
}

\ ******************************************************************************
\
\ Subroutine: ou2
\
\ Display "E.C.M.SYSTEM DESTROYED" as an in-flight message.
\
\ ******************************************************************************

.ou2
{
 LDA #108               \ Set A to recursive token 108 ("E.C.M.SYSTEM")

 EQUB &2C               \ Fall through into ou3 to print the new message, but
                        \ skip the first instruction by turning it into
                        \ &2C &A9 &6F, or BIT &6FA9, which does nothing bar
                        \ affecting the flags
}

\ ******************************************************************************
\
\ Subroutine: ou3
\
\ Display "FUEL SCOOPS DESTROYED" as an in-flight message.
\
\ ******************************************************************************

.ou3
{
 LDA #111               \ Set A to recursive token 111 ("FUEL SCOOPS")
}

\ ******************************************************************************
\
\ Subroutine: MESS
\
\ Display an in-flight message in capitals at the bottom of the space view,
\ erasing any existing in-flight message first.
\
\ Arguments:
\
\   A                   The text token to be printed
\
\ ******************************************************************************

.MESS
{
 LDX #0                 \ Set QQ17 = 0 to set ALL CAPS
 STX QQ17

 LDY #9                 \ Move the text cursor to column 9, row 22, at the
 STY XC                 \ bottom middle of the screen
 LDY #22
 STY YC

 CPX DLY                \ If the message delay in DLY is not zero, jump up to
 BNE me1                \ me1 to erase the current message first (whose token
                        \ number will be in MCH)

 STY DLY                \ Set the message delay in DLY to 22

 STA MCH                \ Set MCH to the token we are about to display and fall
                        \ through to mes9 to print the token
}

\ ******************************************************************************
\
\ Subroutine: mes9
\
\ Print a text token, followed by " DESTROYED" if the destruction flag is set
\ (for when a piece of equipment is destroyed).
\
\ ******************************************************************************

.mes9
{
 JSR TT27               \ Call TT27 to print the text token in A

 LSR de                 \ If bit 1 of location de is clear, return from the
 BCC out                \ subroutine (as out contains an RTS)

 LDA #253               \ Print recursive token 93 (" DESTROYED") and return
 JMP TT27               \ from the subroutine using a tail call
}

\ ******************************************************************************
\
\ Subroutine: OUCH
\
\ Our shields are dead and we are taking damage, so there is a small chance of
\ losing cargo or equipment.
\
\ ******************************************************************************

.OUCH
{
 JSR DORND              \ Set A and X to random numbers

 BMI out                \ If A < 0 (50% chance), return from the subroutine
                        \ (as out contains an RTS)

 CPX #22                \ If X >= 22 (89% chance), return from the subroutine
 BCS out                \ (as out contains an RTS)

 LDA QQ20,X             \ If we do not have any of item QQ20+X, return from the
 BEQ out                \ subroutine (as out contains an RTS). X is in the range
                        \ 0-21, so this not only checks for cargo, but also for
                        \ E.C.M., fuel scoops, energy bomb, energy unit and
                        \ docking computer, all of which can be destroyed

 LDA DLY                \ If there is already an in-flight message on screen,
 BNE out                \ return from the subroutine (as out contains an RTS)

 LDY #3                 \ Set bit 1 of de, the equipment destruction flag, so
 STY de                 \ that when we call MESS below, " DESTROYED" is appended
                        \ to the in-flight message

 STA QQ20,X             \ A is 0 (as we didn't branch with the BNE above), so
                        \ this sets QQ20+X to 0, which destroys any cargo or
                        \ equipment we have of that type

 CPX #17                \ If X >= 17 then we just lost a piece of equipment, so
 BCS ou1                \ jump to ou1 to print the relevant message

 TXA                    \ Print recursive token 48 + A as an in-flight token,
 ADC #208               \ which will be in the range 48 ("FOOD") to 64 ("ALIEN
 BNE MESS               \ ITEMS") as the C flag is clear, so this prints the
                        \ destroyed item's name, followed by " DESTROYED" (as we
                        \ set bit 1 of the de flag above), and returns from the
                        \ subroutine using a tail call

.ou1

 BEQ ou2                \ If X = 17, jump to ou2 to print "E.C.M.SYSTEM
                        \ DESTROYED" and return from the subroutine using a tail
                        \ call

 CPX #18                \ If X = 18, jump to ou3 to print "FUEL SCOOPS
 BEQ ou3                \ DESTROYED" and return from the subroutine using a tail
                        \ call

 TXA                    \ Otherwise X is in the range 19 to 21 and the C flag is
 ADC #113-20            \ set (as we got here via a BCS to ou1), so we set A as
                        \ follows:
                        \
                        \   A = 113 - 20 + X + C
                        \     = 113 - 19 + X
                        \     = 113 to 115

 BNE MESS               \ Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
                        \ or "DOCKING COMPUTERS") as an in-flight message,
                        \ followed by " DESTROYED", and return from the
                        \ subroutine using a tail call
}

\ ******************************************************************************
\
\ Variable: QQ16
\
\ Two-letter token lookup table for tokens 128-159. See variable QQ18 for
\ details of how the two-letter token system works.
\
\ ******************************************************************************

.QQ16
{
 EQUS "AL"
 EQUS "LE"
 EQUS "XE"
 EQUS "GE"
 EQUS "ZA"
 EQUS "CE"
 EQUS "BI"
 EQUS "SO"
 EQUS "US"
 EQUS "ES"
 EQUS "AR"
 EQUS "MA"
 EQUS "IN"
 EQUS "DI"
 EQUS "RE"
 EQUS "A?"
 EQUS "ER"
 EQUS "AT"
 EQUS "EN"
 EQUS "BE"
 EQUS "RA"
 EQUS "LA"
 EQUS "VE"
 EQUS "TI"
 EQUS "ED"
 EQUS "OR"
 EQUS "QU"
 EQUS "AN"
 EQUS "TE"
 EQUS "IS"
 EQUS "RI"
 EQUS "ON"
}

\ ******************************************************************************
\
\ Variable: QQ23
\
\ Market prices table. Each item has four bytes of data, like this:
\
\   Byte #0 = Base price
\   Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
\             Unit in bits 5-6
\   Byte #2 = Base quantity
\   Byte #3 = Mask to control price fluctuations
\
\ To make it easier for humans to follow, we've defined a macro called ITEM
\ that takes the following arguments and builds the four bytes for us:
\
\   ITEM base price, economic factor, units, base quantity, mask
\
\ So for food, we have the following:
\
\   * Base price = 19
\   * Economic factor = -2
\   * Unit = tonnes
\   * Base quantity = 6
\   * Mask = %00000001
\
\ ******************************************************************************

.QQ23
{
 ITEM 19,  -2, 't',   6, %00000001   \ 0  = Food

 ITEM 20,  -1, 't',  10, %00000011   \ 1  = Textiles

 ITEM 65,  -3, 't',   2, %00000111   \ 2  = Radioactives

 ITEM 40,  -5, 't', 226, %00011111   \ 3  = Slaves

 ITEM 83,  -5, 't', 251, %00001111   \ 4  = Liquor/Wines

 ITEM 196,  8, 't',  54, %00000011   \ 5  = Luxuries

 ITEM 235, 29, 't',   8, %01111000   \ 6  = Narcotics

 ITEM 154, 14, 't',  56, %00000011   \ 7  = Computers

 ITEM 117,  6, 't',  40, %00000111   \ 8  = Machinery

 ITEM 78,   1, 't',  17, %00011111   \ 9  = Alloys

 ITEM 124, 13, 't',  29, %00000111   \ 10 = Firearms

 ITEM 176, -9, 't', 220, %00111111   \ 11 = Furs

 ITEM 32,  -1, 't',  53, %00000011   \ 12 = Minerals

 ITEM 97,  -1, 'k',  66, %00000111   \ 13 = Gold

 ITEM 171, -2, 'k',  55, %00011111   \ 14 = Platinum

 ITEM 45,  -1, 'g', 250, %00001111   \ 15 = Gem-Stones

 ITEM 53,  15, 't', 192, %00000111   \ 16 = Alien Items
}

\ ******************************************************************************
\
\ Subroutine: TIDY
\
\ Orthonormalize the orientation vectors for a ship. This means making the three
\ orientation vectors orthogonal (perpendicular to each other), and normal (so
\ each of the vectors has length 1).
\
\ We do this because we use the small angle approximation to rotate these
\ vectors in space. It is is not completely accurate, so the three vectors tend
\ to get stretched over time, so periodically we tidy the vectors with this
\ routine to ensure they remain as orthonormal as possible.
\
\ ******************************************************************************
\
\ Deep dive: Tidying orthonormal vectors
\ --------------------------------------
\ The challenge here is to take the three orientation vectors, nosev, roofv and
\ sidev, and tweak then so that they are orthogonal and normal once again. Let's
\ call these new, tweaked vectors nosev, roofv and sidev, and let's look at
\ how we can calculate them.
\ 
\ The first vector, nosev
\ ------------------------
\ First, let's normalise nosev, so it has length 1 (stored internally as 96),
\ and let's call this nosev. We start with the node vector, as normalising it
\ doesn't change the direction that the ship is pointing in, so if we happen to
\ be looking at a ship as it gets tidied, at least it won't change direction.
\ 
\ The second vector, roofv
\ -------------------------
\ Next, we want to tweak roofv into a new vector roofv, where roofv is
\ perpendicular to nosev. When two vectors are perpendicular, their dot product
\ is zero, so this means:
\ 
\   roofv . nosev = 0
\ 
\ This expands to:
\ 
\   nosev_x * roofv_x + nosev_y * roofv_y + nosev_z * roofv_z = 0
\ 
\ which we can expand to the following:
\ 
\   roofv_x = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
\   roofv_y = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
\   roofv_z = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
\ 
\ Because time is of the essence, we would rather only calculate one of these,
\ so we do a clever trick. If you think of two arbitrary lines on a piece of
\ paper, then given any direction, it's possible to move the end of one of the
\ lines in that direction so that the lines become parallel. In the case of our
\ vectors, this means we can tweak roofv in one axis only - i.e. only change one
\ of its x, y, and z coordinates - and can still get a vector that's at
\ right-angles to nosev.
\ 
\ So let's say that we tweak roofv in the x-axis only, then that means we leave
\ roofv_y and roofv_z alone - so roofv_y = roofv_y and roofv_z = roofv_z. So
\ this means:
\ 
\   roofv_x = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
\   roofv_y = roofv_y
\   roofv_z = roofv_z
\ 
\ So we can just tweak roofv_x to roofv_x, using this calculation:
\ 
\   roofv_x = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
\ 
\ and roofv will be perpendicular to nosev; then all we need to do is normalise
\ roofv and we've got our second orthonormal vector.
\ 
\ We can do the same with any of the axes, leading to these two equations:
\ 
\   roofv_y = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
\   roofv_z = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
\ 
\ So how do we choose which coordinate axis to move? Well, seeing as we are
\ going to be dividing by one of the coordinates of nosev in our calculation,
\ and dividing by big numbers in integer arithmetic isn't so accurate (as we're
\ dealing in integers here, not floating point numbers), we could always choose
\ an equation with a low nosev value, and this is exactly what Elite does. First
\ we check whether nosev_x is small, and if it is, we do this one:
\ 
\   roofv_x = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
\ 
\ Otherwise we check whether nosev_y is small, and if it is, we do this one:
\ 
\   roofv_y = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
\ 
\ Otherwise, we have no choice but to do this one:
\ 
\   roofv_z = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
\ 
\ And finally we normalise roofv, so it has length 1 (stored internally as 96)
\ 
\ The third vector, sidev
\ ------------------------
\ So we have two vectors in nosev and roofv that are orthogonal and normal, so
\ we just need to find a vector that is perpendicular to these two. There's an
\ easy way to calculate such a vector, by using the cross-product.
\ 
\ The cross-product works like this. Consider two vectors, a and b, which have
\ an angle theta between them. The cross-product of these two vectors, a x b,
\ gives us another vector that is at right-angles to the first two, and which
\ has length |a| * |b| * sin(theta).
\ 
\ In other words, if we calculate the following:
\ 
\   sidev = nosev x roofv
\ 
\ which we can do by breaking it down into axes:
\ 
\   [sidex_x]   [nosev_x]   [roofv_x]
\   [sidex_y] = [nosev_y] x [roofv_y]
\   [sidex_z]   [nosev_z]   [roofv_z]
\ 
\               [nosev_z * roofv_y - nosev_y * roofv_z]
\             = [nosev_x * roofv_z - nosev_z * roofv_x]
\               [nosev_y * roofv_x - nosev_x * roofv_y]
\ 
\ then this sets sidev to a vector that is perpendicular to the others, and
\ which has length |nose_v| * |roof_v| * sin(theta). We know that because
\ nose_v and roof_v are orthonormal, theta must be a right-angle, and
\ |nose_v| and |roof_v| must be 1, so this means sidev has length 1:
\ 
\   |nose_v| * |roof_v| * sin(theta) = 1 * 1 * 1 = 1
\ 
\ So if we calculate the following in the routine below, this will set sidev to
\ a vector of length 1 that's perpendicular to the other two, which is a third
\ orthonormal vector - exactly what we want our third vector to be.
\ 
\   sidev_x = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
\   sidev_y = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
\   sidev_z = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
\ 
\ We divide by 96 as we use 96 to represent 1 internally. This means the length
\ of nosev and roofv internally is actually 96, so the length of the
\ cross-product would be 96 96. We want the length of sidev to be 96 (so it
\ represents 1), so we divide by 96 to get the correct result.
\
\ ******************************************************************************

{
.TI2                    \ Called from below with A = 0, X = 0, Y = 4 when
                        \ nosev_x and nosev_y are small, so we assume that
                        \ nosev_z is big

 TYA                    \ A = Y = 4
 LDY #2
 JSR TIS3               \ Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
 STA INWK+20            \ -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z

 JMP TI3                \ Jump to TI3 to keep tidying

.TI1                    \ Called from below with A = 0, Y = 4 when nosev_x is
                        \ small

 TAX                    \ Set X = A = 0

 LDA XX15+1             \ Set A = nosev_y, and if the top two magnitude bits
 AND #%01100000         \ are both clear, jump to TI2 with A = 0, X = 0, Y = 4
 BEQ TI2

 LDA #2                 \ Otherwise nosev_y is big, so set up the index values
                        \ to pass to TIS3

 JSR TIS3               \ Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
 STA INWK+18            \ -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y

 JMP TI3                \ Jump to TI3 to keep tidying

.^TIDY

 LDA INWK+10            \ Set (XX15, XX15+1, XX15+2) = nosev
 STA XX15
 LDA INWK+12
 STA XX15+1
 LDA INWK+14
 STA XX15+2

 JSR NORM               \ Call NORM to normalise the vector in XX15, i.e. nosev

 LDA XX15               \ Set nosev = (XX15, XX15+1, XX15+2)
 STA INWK+10
 LDA XX15+1
 STA INWK+12
 LDA XX15+2
 STA INWK+14

 LDY #4                 \ Set Y = 4

 LDA XX15               \ Set A = nosev_x, and if the top two magnitude bits
 AND #%01100000         \ are both clear, jump to TI1 with A = 0, Y = 4
 BEQ TI1

 LDX #2                 \ Otherwise nosev_x is big, so set up the index values
 LDA #0                 \ to pass to TIS3

 JSR TIS3               \ Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
 STA INWK+16            \ -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x

.TI3

 LDA INWK+16            \ Set (XX15, XX15+1, XX15+2) = roofv
 STA XX15
 LDA INWK+18
 STA XX15+1
 LDA INWK+20
 STA XX15+2

 JSR NORM               \ Call NORM to normalise the vector in XX15, i.e. roofv

 LDA XX15               \ Set roofv = (XX15, XX15+1, XX15+2)
 STA INWK+16
 LDA XX15+1
 STA INWK+18
 LDA XX15+2
 STA INWK+20

 LDA INWK+12            \ Set Q = nosev_y
 STA Q

 LDA INWK+20            \ Set A = roofv_z

 JSR MULT12             \ Set (S R) = Q * A = nosev_y * roofv_z

 LDX INWK+14            \ Set X = nosev_z

 LDA INWK+18            \ Set A = roofv_y

 JSR TIS1               \ Set (A ?) = (-X * A + (S R)) / 96
                        \        = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
                        \
                        \ This also sets Q = nosev_z

 EOR #%10000000         \ Set sidev_x = -A
 STA INWK+22            \        = (nosev_z * roofv_y - nosev_y * roofv_z) / 96

 LDA INWK+16            \ Set A = roofv_x

 JSR MULT12             \ Set (S R) = Q * A = nosev_z * roofv_x

 LDX INWK+10            \ Set X = nosev_x

 LDA INWK+20            \ Set A = roofv_z

 JSR TIS1               \ Set (A ?) = (-X * A + (S R)) / 96
                        \        = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
                        \
                        \ This also sets Q = nosev_x

 EOR #%10000000         \ Set sidev_y = -A
 STA INWK+24            \        = (nosev_x * roofv_z - nosev_z * roofv_x) / 96

 LDA INWK+18            \ Set A = roofv_y

 JSR MULT12             \ Set (S R) = Q * A = nosev_x * roofv_y

 LDX INWK+12            \ Set X = nosev_y

 LDA INWK+16            \ Set A = roofv_x

 JSR TIS1               \ Set (A ?) = (-X * A + (S R)) / 96
                        \        = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96

 EOR #%10000000         \ Set sidev_z = -A
 STA INWK+26            \        = (nosev_y * roofv_x - nosev_x * roofv_y) / 96

 LDA #0                 \ Set A = 0 so we can clear the low bytes of the
                        \ orientation vectors

 LDX #14                \ We want to clear the low bytes, so start from sidev_y
                        \ at INWK+9+14 (we clear all except sidev_z_lo, though
                        \ I suspect this is in error and that X should be 16)

.TIL1

 STA INWK+9,X           \ Set the low byte in INWK+9+X to zero

 DEX                    \ Set X = X - 2 to jump down to the next low byte
 DEX

 BPL TIL1               \ Loop back until we have zeroed all the low bytes

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TIS2
\
\ Calculate the following division, where A is a sign-magnitude number and Q is
\ a positive integer:
\
\   A = A / Q
\
\ The value of A is returned as a sign-magnitude number with 96 representing 1,
\ and the maximum value returned is 1 (i.e. 96). This routine is used when
\ normalising vectors, where we represent fractions using integers, so this
\ gives us an approximation to two decimal places.
\
\ ******************************************************************************
\
\ Deep dive: "Shift-and-subtract" division
\ ----------------------------------------
\ This routine implements integer division using the "shift and subtract"
\ algorithm. This is similar in concept to the "shift and add" algorithm used to
\ implement multiplication in routines like MULT1, but it's essentially the
\ reverse of that algorithm.
\
\ In the same way that "shift and add" implements a binary version of the manual
\ long multiplication process, "shift and subtract" implements long division. We
\ shift bits out of the left end of the number being divided (A), subtracting the
\ largest possible multiple of the divisor (Q) after each shift; each bit of A
\ where we can subtract Q gives a 1 the answer to the division, otherwise it
\ gives a 0.
\
\ In pseudo-code, the algorithm to calculate T = P / Q (with remainder A) looks
\ like this:
\
\   T = 0
\   A = 0
\   for x = 7 to 0
\     A = A << 1
\     A(bit 0) = P(bit x)
\     if A >= Q then
\       A = A  Q
\       T(bit x) = 1
\
\ This is the algorithm implemented below, except we save space (and make things
\ much more confusing) by using A for both the number being divided and the
\ remainder, building the answer in T instead of P, and using set bits in T to
\ implement the loop counter. The basic idea of shifting and subtracting is the
\ same, though.
\
\ ******************************************************************************

.TIS2
{
 TAY                    \ Store the argument A in Y

 AND #%01111111         \ Strip the sign bit from the argument, so A = |A|

 CMP Q                  \ If A >= Q then jump to TI4 to return a 1 with the
 BCS TI4                \ correct sign

 LDX #%11111110         \ Set T to have bits 1-7 set, so we can rotate through 7
 STX T                  \ loop iterations, getting a 1 each time, and then
                        \ getting a 0 on the 8th iteration... and we can also
                        \ use T to catch our result bits into bit 0 each time

.TIL2

 ASL A                  \ Shift A to the left

 CMP Q                  \ If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  \ A >= Q, so set A = A - Q
                        \
                        \ Going into this subtraction we we know the C flag is
                        \ set as we passed through the BCC above, and we also
                        \ know that A >= Q, so the C flag will still be set once
                        \ we are done

 ROL T                  \ Rotate the counter in T to the left, and catch the
                        \ result bit into bit 0 (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 BCS TIL2               \ If we still have set bits in T, loop back to TIL2 to
                        \ do the next iteration of 7

                        \ We've done the division and now have a result in the
                        \ range 0-255 here, which we need to reduce to the range
                        \ 0-96. We can do that by multiplying the result by 3/8,
                        \ as 256 * 3/8 = 96

 LDA T                  \ Set T = T / 4
 LSR A
 LSR A
 STA T

 LSR A                  \ Set T = T / 8 + T / 4
 ADC T                  \       = 3T / 8
 STA T

 TYA                    \ Fetch the sign bit of the original argument A
 AND #%10000000

 ORA T                  \ Apply the sign bit to T

 RTS                    \ Return from the subroutine

.TI4

 TYA                    \ Fetch the sign bit of the original argument A
 AND #%10000000

 ORA #96                \ Apply the sign bit to 96 (which represents 1)

 RTS                    \ Return from the subroutine
}

\ ******************************************************************************
\
\ Subroutine: TIS3
\
\ Calculate the following expression:
\
\   A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
\
\ where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
\ routine is called with the following values:
\
\   X = 0, Y = 2, A = 4 ->
\         A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
\
\   X = 0, Y = 4, A = 2 ->
\         A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
\
\   X = 2, Y = 4, A = 0 ->
\         A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
\
\ Arguments:
\
\   X                   Index 1 (0 = x, 2 = ny, 4 = z)
\
\   Y                   Index 2 (0 = x, 2 = ny, 4 = z)
\
\   A                   Index 3 (0 = x, 2 = ny, 4 = z)
\
\ ******************************************************************************

.TIS3
{
 STA P+2                \ Store P+2 in A for later

 LDA INWK+10,X          \ Set Q = nosev_x_hi (plus X)
 STA Q

 LDA INWK+16,X          \ Set A = roofv_x_hi (plus X)

 JSR MULT12             \ Set (S R) = Q * A
                        \           = nosev_x_hi * roofv_x_hi

 LDX INWK+10,Y          \ Set Q = nosev_x_hi (plus Y)
 STX Q

 LDA INWK+16,Y          \ Set A = roofv_x_hi (plus Y)

 JSR MAD                \ Set (A X) = Q * A + (S R)
                        \           = (nosev_x,X * roofv_x,X) +
                        \             (nosev_x,Y * roofv_x,Y)

 STX P                  \ Store low byte of result in P, so result is now in
                        \ (A P)

 LDY P+2                \ Set Q = roofv_x_hi (plus argument A)
 LDX INWK+10,Y
 STX Q

 EOR #%10000000         \ Flip the sign of A

                        \ Fall through into DIVDT to do:
                        \
                        \   (P+1 A) = (A P) / Q
                        \
                        \     = -((nosev_x,X * roofv_x,X) +
                        \         (nosev_x,Y * roofv_x,Y))
                        \       / nosev_x,A
}

\ ******************************************************************************
\
\ Subroutine: DVIDT
\
\ Calculate the following integer division between sign-magnitude numbers:
\
\   (P+1 A) = (A P) / Q
\
\ This uses the same "shift and subtract" algorithm as TIS2.
\
\ ******************************************************************************

.DVIDT
{
 STA P+1                \ Set P+1 = A, so P(1 0) = (A P)

 EOR Q                  \ Set T = the sign bit of A EOR Q, so it's 1 if A and Q
 AND #%10000000         \ have different signs, i.e. it's the sign of the result
 STA T                  \ of A / Q
 
 LDA #0                 \ Set A = 0 for us to build a result

 LDX #16                \ Set a counter in X to count the 16 bits in P(1 0)

 ASL P                  \ Shift P(1 0) left
 ROL P+1

 ASL Q                  \ Clear the sign bit of Q the C flag at the same time
 LSR Q

.DVL2

 ROL A                  \ Shift A to the left

 CMP Q                  \ If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  \ Set A = A - Q
                        \
                        \ Going into this subtraction we we know the C flag is
                        \ set as we passed through the BCC above, and we also
                        \ know that A >= Q, so the C flag will still be set once
                        \ we are done

 ROL P                  \ Rotate P(1 0) to the left, and catch the result bit
 ROL P+1                \ into the C flag (which will be a 0 if we didn't
                        \ do the subtraction, or 1 if we did)

 DEX                    \ Decrement the loop counter

 BNE DVL2               \ Loop back for the next bit until we have done all 16
                        \ bits of P(1 0)

 LDA P                  \ Set A = P so the low byte is in the result in A

 ORA T                  \ Set A to the correct sign bit that we set in T above

 RTS                    \ Return from the subroutine

}

\ ******************************************************************************
\
\ Save output/ELTF.bin
\
\ ******************************************************************************

PRINT "ELITE F"
PRINT "Assembled at ", ~CODE_F%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_F%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_F%

PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
SAVE "output/ELTF.bin", CODE_F%, P%, LOAD%

\ ******************************************************************************
\
\ ELITE G
\
\ Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_G% = P%
LOAD_G% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\ Subroutine: SHPPT
\
\ Ship plot as point from LL10
\
\ ******************************************************************************

.SHPPT                  \ ship plot as point from LL10
{
 JSR EE51               \ if bit3 set draw to erase lines in XX19 heap
 JSR PROJ               \ Project K+INWK(x,y)/z to K3,K4 for craft center
 ORA K3+1
 BNE nono
 LDA K4                 \ #Y Ymiddle not K4 when docked
 CMP #Y*2-2             \ #Y*2-2  96*2-2 screen height
 BCS nono               \ off top of screen
 LDY #2                 \ index for edge heap
 JSR Shpt               \ Ship is point, could end if nono-2
 LDY #6                 \ index for edge heap
 LDA K4                 \ #Y
 ADC #1                 \ 1 pixel uo
 JSR Shpt               \ Ship is point, could end if nono-2
 LDA #8                 \ set bit3 (to erase later) and plot as Dot
 ORA XX1+31             \ display/exploding state|missiles
 STA XX1+31
 LDA #8                 \ Dot uses #8 not U
 JMP LL81+2             \ skip first two edges on XX19 heap
 PLA                    \ nono-2 \ Changing return address
 PLA                    \ ending routine early
}

\ ******************************************************************************
\
\ Subroutine: nono
\
\ Clear bit3 nothing to erase in next round, no draw.
\
\ ******************************************************************************

.nono                   \ clear bit3 nothing to erase in next round, no draw
{
 LDA #&F7               \ clear bit3
 AND XX1+31             \ display/exploding state|missiles
 STA XX1+31
 RTS
}

\ ******************************************************************************
\
\ Subroutine: Shpt
\
\ Ship is point at screen center
\
\ ******************************************************************************

.Shpt                   \ ship is point at screen center
{
 STA (XX19),Y
 INY
 INY                    \ next Y coord
 STA (XX19),Y
 LDA K3                 \ Xscreen-mid, not K3 when docked
 DEY                    \ 2nd X coord
 STA (XX19),Y
 ADC #3                 \ 1st X coord
 BCS nono-2             \ overflowed to right, remove 2 from stack and clear bit 3
 DEY
 DEY                    \ first entry in group of 4 added to ship line heap
 STA (XX19),Y
 RTS
}

\ ******************************************************************************
\
\ Subroutine: LL5
\
\ Calculate the following square root:
\
\   Q = SQRT(R Q)
\
\ ******************************************************************************

.LL5                    \ 2BSQRT Q=SQR(RQ) \ two-byte square root, R is hi, Q is lo
{
 LDY R                  \ hi
 LDA Q
 STA S                  \ lo
 LDX #0                 \ result
 STX Q
 LDA #8                 \ counter
 STA T

.LL6                    \ counter T

 CPX Q
 BCC LL7                \ no carry
 BNE LL8                \ hop ne
 CPY #&40               \ hi
 BCC LL7                \ no carry

.LL8                    \ hop ne

 TYA
 SBC #&40
 TAY                    \ new hi
 TXA
 SBC Q
 TAX                    \ maybe carry into

.LL7                    \ no carry

 ROL Q                  \ result
 ASL S                  \ maybe carry into Yreg
 TYA
 ROL A
 TAY                    \ Yhi *2
 TXA
 ROL A
 TAX                    \ Xlo *2
 ASL S                  \ maybe carry into Yreg
 TYA
 ROL A
 TAY                    \ Yhi *2
 TXA
 ROL A
 TAX                    \ Xlo *2
 DEC T
 BNE LL6                \ loop T
 RTS                    \ Q left with root
}

\ ******************************************************************************
\
\ Subroutine: LL28
\
\ BFRDIV R=A*256/Q \ byte from remainder of division
\
\ Returns:
\
\   C flag              Set if answer is too big for one byte, clear otherwise
\
\ Other entry points:
\
\   LL28+4              Skips A >= Q check, always returns with C flag cleared
\
\   LL31                Skips A >= Q check and does not set R to 254
\ ******************************************************************************

.LL28                   \ BFRDIV R=A*256/Q \ byte from remainder of division
{
 CMP Q                  \ is A >= Q ?
 BCS LL2                \ if yes, answer too big for 1 byte, R=#&FF

 LDX #254               \ remainder R for AofQ *256/Q
 STX R                  \ div roll counter

.^LL31                   \ roll R

 ASL A
 BCS LL29               \ hop to Reduce
 CMP Q
 BCC P%+4               \ skip sbc
 SBC Q
 ROL R
 BCS LL31               \ loop R
 RTS                    \ R left with remainder of division

.LL29                   \ Reduce

 SBC Q
 SEC
 ROL R
 BCS LL31               \ loop R
 RTS                    \ R left with remainder of division

.LL2                    \ answer too big for 1 byte, R=#&FF

 LDA #&FF
 STA R
 RTS
}

\ ******************************************************************************
\
\ Subroutine: LL38
\
\ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
\
\ ******************************************************************************

.LL38                   \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
{
 EOR S                  \ sign of operator is A xor S
 BMI LL39               \ 1 byte subtraction
 LDA Q                  \ else addition, S already correct
 CLC
 ADC R
 RTS

.LL39                   \ 1 byte subtraction (S)A = R-Q

 LDA R
 SEC
 SBC Q
 BCC P%+4               \ sign of S needs correcting, hop over rts
 CLC
 RTS
 PHA                    \ store subtraction result
 LDA S
 EOR #128               \ flip
 STA S
 PLA                    \ restore subtraction result
 EOR #255
 ADC #1                 \ negate
 RTS
}

\ ******************************************************************************
\
\ Subroutine: LL51
\
\ XX12=XX15.XX16  each vector is 16-bit x,y,z
\ XX16_hsb[   1  3  5    highest XX16 done below is 5, then X taken up by 6, Y taken up by 2.
\             7  9 11
\	         13 15 17=0 ?]
\
\ ******************************************************************************

.LL51                   \ XX12=XX15.XX16  each vector is 16-bit x,y,z
{
 LDX #0
 LDY #0

.ll51                   \ counter X+=6 < 17  Y+=2

 LDA XX15               \ xmag
 STA Q
 LDA XX16,X
 JSR FMLTU              \ Acc= XX15 *XX16 /256 assume unsigned
 STA T
 LDA XX15+1
 EOR XX16+1,X
 STA S                  \ xsign
 LDA XX15+2             \ ymag
 STA Q
 LDA XX16+2,X
 JSR FMLTU              \ Acc= XX15 *XX16 /256 assume unsigned
 STA Q
 LDA T
 STA R                  \ move T to R
 LDA XX15+3             \ ysign
 EOR XX16+3,X
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 STA T
 LDA XX15+4             \ zmag
 STA Q
 LDA XX16+4,X
 JSR FMLTU              \ Acc= XX15 *XX16 /256 assume unsigned
 STA Q
 LDA T
 STA R                  \ move T to R
 LDA XX15+5             \ zsign
 EOR XX16+5,X
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 STA XX12,Y
 LDA S                  \ result sign
 STA XX12+1,Y
 INY
 INY                    \ Y +=2
 TXA
 CLC
 ADC #6
 TAX                    \ X +=6
 CMP #17                \ X finished?
 BCC ll51               \ loop for second half of matrix
 RTS
}

\ ******************************************************************************
\
\ Subroutine: LL25
\
\ Planet
\
\ ******************************************************************************

.LL25                   \ planet
{
 JMP PLANET
}

\ ******************************************************************************
\
\ Subroutine: LL9
\
\ Object ENTRY for displaying, including debris.
\
\ ******************************************************************************

.LL9                    \ object ENTRY for displaying, including debris
{
 LDA TYPE               \ ship type
 BMI LL25               \ planet as bit7 set
 LDA #31                \ max visibility
 STA XX4
 LDA #32                \ mask for bit 5, exploding
 BIT XX1+31             \ display explosion state|missiles
 BNE EE28               \ bit5 set, explosion ongoing
 BPL EE28               \ bit7 clear, else Start blowing up!
 ORA XX1+31
 AND #&3F               \ clear bit7,6
 STA XX1+31
 LDA #0                 \ acceleration & pitch zeroed
 LDY #28                \ byte #28 accel
 STA (INF),Y
 LDY #30                \ byte #30 pitch counter
 STA (INF),Y
 JSR EE51               \ if bit3 set erase old lines in XX19 heap
 LDY #1                 \ edge heap byte1
 LDA #18                \ counter for explosion radius
 STA (XX19),Y
 LDY #7                 \ Hull byte#7 explosion of ship type e.g. &2A
 LDA (XX0),Y
 LDY #2                 \ edge heap byte2
 STA (XX19),Y

\LDA XX1+32
\AND #&7F
\STA XX1+32

.EE55                   \ counter Y, 4 rnd bytes to edge heap

 INY                    \ #3 start
 JSR DORND
 STA (XX19),Y
 CPY #6                 \ bytes 3to6 = random bytes for seed
 BNE EE55               \ loop Y

.EE28                   \ bit5 set do explosion, or bit7 clear, dont kill

 LDA XX1+8              \ sign of Z coord

.EE49                   \ In view?

 BPL LL10               \ hop over as object in front
}

.LL14                   \ Test to remove object
{
 LDA XX1+31             \ display explosion state|missiles
 AND #32                \ bit5 ongoing explosion?
 BEQ EE51               \ if no then if bit3 set erase old lines in XX19 heap
 LDA XX1+31             \ else exploding
 AND #&F7               \ clear bit3
 STA XX1+31
 JMP DOEXP              \ Explosion
}

.EE51                   \ if bit3 set draw lines in XX19 heap
{
 LDA #8                 \ mask for bit 3
 BIT XX1+31             \ exploding/display state|missiles
 BEQ LL10-1             \ if bit3 clear, just rts
 EOR XX1+31             \ else toggle bit3 to allow lines
 STA XX1+31
 JMP LL155              \ clear LINEstr. Draw lines in XX19 heap

\LL24
 RTS                    \ needed by beq \ LL10-1
}

.LL10                   \ object in front of you
{
 LDA XX1+7              \ zhi
 CMP #&C0               \ far in front
 BCS LL14               \ test to remove object
 LDA XX1                \ xlo
 CMP XX1+6              \ zlo
 LDA XX1+1              \ xhi
 SBC XX1+7              \ zhi, gives angle to object
 BCS LL14               \ test to remove object
 LDA XX1+3              \ ylo
 CMP XX1+6              \ zlo
 LDA XX1+4              \ yhi
 SBC XX1+7              \ zhi
 BCS LL14               \ test to remove object
 LDY #6                 \ Hull byte6, node gun*4
 LDA (XX0),Y
 TAX                    \ node heap index
 LDA #255               \ flag on node heap at gun
 STA XX3,X
 STA XX3+1,X
 LDA XX1+6              \ zlo
 STA T
 LDA XX1+7              \ zhi
 LSR A
 ROR T
 LSR A
 ROR T
 LSR A
 ROR T
 LSR A
 BNE LL13               \ hop as far
 LDA T
 ROR A                  \ bring in hi bit0
 LSR A
 LSR A                  \ small zlo
 LSR A                  \ updated visibility
 STA XX4
 BPL LL17               \ guaranteed hop to Draw wireframe

.LL13                   \ hopped to as far

 LDY #13                \ Hull byte#13, distance point at which ship becomes a dot
 LDA (XX0),Y
 CMP XX1+7              \ dot_sign >= z_hi will leave carry set
 BCS LL17               \ hop over to draw Wireframe
 LDA #32                \ mask bit5 exploding
 AND XX1+31             \ exploding/display state|missiles
 BNE LL17               \ hop over to Draw wireframe or exploding
 JMP SHPPT              \ else ship plot point, up

.LL17                   \ draw Wireframe (including nodes exploding)

 LDX #5                 \ load rotmat into XX16

.LL15                   \ counter X

 LDA XX1+21,X
 STA XX16,X
 LDA XX1+15,X
 STA XX16+6,X
 LDA XX1+9,X
 STA XX16+12,X
 DEX
 BPL LL15               \ loop X
 LDA #197               \ comment here about NORM
 STA Q
 LDY #16

.LL21                   \ counter Y -=2

 LDA XX16,Y             \ XX16+0,Y
 ASL A                  \ get carry, only once
 LDA XX16+1,Y
 ROL A
 JSR LL28               \ BFRDIV R=A*256/197
 LDX R
 STX XX16,Y
 DEY
 DEY                    \ Y -=2
 BPL LL21               \ loop Y
 LDX #8                 \ load craft coords into XX18

.ll91                   \ counter X

 LDA XX1,X
 STA XX18,X
 DEX
 BPL ll91               \ loop X

 LDA #255               \ last normal is always visible
 STA XX2+15
 LDY #12                \ Hull byte 12 =  normals*4
 LDA XX1+31
 AND #32                \ mask bit5 exploding
 BEQ EE29               \ no, only Some visible
 LDA (XX0),Y
 LSR A                  \ else do explosion needs all vertices
 LSR A                  \ /=4
 TAX                    \ Xreg = number of normals, faces
 LDA #&FF               \ all faces visible

.EE30                   \ counter X  for each face

 STA XX2,X
 DEX
 BPL EE30               \ loop X
 INX                    \ X = 0
 STX XX4                \ visibility = 0

.LL41                   \ visibilities now set in XX2,X Transpose matrix

 JMP LL42               \ jump to transpose matrix

.EE29                   \ only Some visible  Yreg =Hull byte12, normals*4

 LDA (XX0),Y
 BEQ LL41               \ if no normals, visibilities now set in XX2,X Transpose matrix
 STA XX20               \ normals*4
 LDY #18                \ Hull byte #18  normals scaled by 2^Q%
                        \ DtProd^XX2 \ their comment \ Dot product gives  normals' visibility in XX2
 LDA (XX0),Y
 TAX                    \ normals scaled by 2^X plus
 LDA XX18+7             \ z_hi

.LL90                   \ scaling object distance

 TAY                    \ z_hi
 BEQ LL91               \ object close/small, hop
 INX                    \ repeat INWK z brought closer, take X up
 LSR XX18+4             \ yhi
 ROR XX18+3             \ ylo
 LSR XX18+1             \ xhi
 ROR XX18               \ xlo
 LSR A                  \ zhi /=2
 ROR XX18+6             \ z_lo
 TAY                    \ zhi
 BNE LL90+3             \ again as z_hi too big

.LL91                   \ object close/small

 STX XX17               \ keep Scale required
 LDA XX18+8             \ last member of INWK copied over
 STA XX15+5             \ zsign 6 members
 LDA XX18
 STA XX15               \ xscaled
 LDA XX18+2
 STA XX15+1             \ xsign
 LDA XX18+3
 STA XX15+2             \ yscaled
 LDA XX18+5
 STA XX15+3             \ ysign
 LDA XX18+6
 STA XX15+4             \ zscaled
 JSR LL51               \ XX12=XX15.XX16  each vector is 16-bit x,y,z
 LDA XX12
 STA XX18               \ load result back in
 LDA XX12+1
 STA XX18+2             \ xsg
 LDA XX12+2
 STA XX18+3
 LDA XX12+3
 STA XX18+5             \ ysg
 LDA XX12+4
 STA XX18+6
 LDA XX12+5
 STA XX18+8             \ zsg

 LDY #4                 \ Hull byte#4 = lsb of offset to normals
 LDA (XX0),Y
 CLC                    \ lo
 ADC XX0
 STA V                  \ will point to start of normals
 LDY #17                \ Hull byte#17 = hsb of offset to normals
 LDA (XX0),Y
 ADC XX0+1
 STA V+1                \ hi of pointer to normals data
 LDY #0                 \ byte#0 of normal

.LL86                   \ counter Y/4 go through all normals

 LDA (V),Y
 STA XX12+1             \ byte#0
 AND #31                \ lower 5 bits are face visibility
 CMP XX4
 BCS LL87               \ >= XX4 visibility, skip over jump LL88
 TYA                    \ face*4 count
 LSR A                  \ else visible
 LSR A                  \ counter/4
 TAX                    \ Xreg is normal count
 LDA #255               \ visible face
 STA XX2,X
 TYA                    \ next face*4
 ADC #4                 \ +=4
 TAY                    \ Yreg +=4 is next normal
 JMP LL88               \ to near end of normal's visibility loop

.LL87                   \ normal visibility>= XX4

 LDA XX12+1             \ byte#0 of normal
 ASL A                  \ get sign y
 STA XX12+3
 ASL A                  \ get sign z
 STA XX12+5
 INY                    \ byte#1 of normal
 LDA (V),Y
 STA XX12               \ xnormal lo
 INY                    \ byte#2 of normal
 LDA (V),Y
 STA XX12+2             \ ynormal lo
 INY                    \ byte#3 of normal
 LDA (V),Y
 STA XX12+4             \ znormal lo
 LDX XX17               \ kept Scale required
 CPX #4                 \ is XX17 < 4 ?
 BCC LL92               \ scale required is Quite close

.LL143                  \ Face offset<<PV \ their comment \ far enough away, use XX18

 LDA XX18               \ xlo
 STA XX15
 LDA XX18+2             \ xsg
 STA XX15+1
 LDA XX18+3             \ ylo
 STA XX15+2
 LDA XX18+5             \ ysg
 STA XX15+3
 LDA XX18+6             \ zlo
 STA XX15+4
 LDA XX18+8             \ zsg
 STA XX15+5
 JMP LL89               \ XX15(6) ready, down to START

.ovflw                  \ overflow from below, reduce xx18+0,3,6

 LSR XX18               \ x_lo/2
 LSR XX18+6             \ z_lo/2
 LSR XX18+3             \ y_lo/2
 LDX #1                 \ scale finished

.LL92                   \ arrive if Quite close, with scale in Xreg.  Normals translate

 LDA XX12               \ xnormal lo
 STA XX15
 LDA XX12+2             \ ynormal lo
 STA XX15+2
 LDA XX12+4             \ znormal lo

.LL93

 DEX                    \ scale--
 BMI LL94               \ exit, Scale done
 LSR XX15               \ counter X
 LSR XX15+2             \ ynormal lo/2
 LSR A                  \ znormal lo/2
 DEX                    \ reduce scale
 BPL LL93+3             \ loop to lsr xx15

.LL94                   \ Scale done

 STA R                  \ znormal  XX15+4
 LDA XX12+5             \ zsg
 STA S                  \ z_hi to translate
 LDA XX18+6             \ z_lo
 STA Q
 LDA XX18+8             \ zsg
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 BCS ovflw              \ up to overflow, reduce xx18+0,3,6

 STA XX15+4             \ new z
 LDA S                  \ maybe new sign
 STA XX15+5             \ zsg

 LDA XX15
 STA R                  \ xnormal
 LDA XX12+1             \ xsg
 STA S                  \ x_hi to translate

 LDA XX18               \ x_lo
 STA Q
 LDA XX18+2             \ xsg
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 BCS ovflw              \ up to overflow, reduce xx18+0,3,6
 STA XX15               \ new x
 LDA S                  \ maybe new sign
 STA XX15+1             \ xsg
 LDA XX15+2
 STA R                  \ ynormal
 LDA XX12+3             \ ysg
 STA S                  \ y_hi to translate
 LDA XX18+3             \ y_lo
 STA Q
 LDA XX18+5             \ ysg
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 BCS ovflw              \ up to overflow, reduce xx18+0,3,6
 STA XX15+2             \ new y
 LDA S                  \ maybe new sign
 STA XX15+3             \ ysg

.LL89                   \ START also arrive from LL143  Face offset<<PV  XX15(6) ready
                        \ Calculate 3D dot product  XX12 . XX15 for (x,y,z)

 LDA XX12               \ xnormal lo
 STA Q
 LDA XX15
 JSR FMLTU              \ A=A*Q/256unsg
 STA T                  \ x-dot
 LDA XX12+1
 EOR XX15+1
 STA S                  \ x-sign
 LDA XX12+2             \ ynormal lo
 STA Q
 LDA XX15+2
 JSR FMLTU              \ A=A*Q/256unsg
 STA Q                  \ y-dot
 LDA T                  \ x-dot
 STA R
 LDA XX12+3             \ ysg
 EOR XX15+3
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 STA T                  \ xdot+ydot
 LDA XX12+4             \ znormal lo
 STA Q
 LDA XX15+4
 JSR FMLTU              \ A=A*Q/256unsg
 STA Q                  \ zdot
 LDA T
 STA R                  \ xdot+ydot
 LDA XX15+5
 EOR XX12+5             \ hi sign
 JSR LL38               \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 PHA                    \ push xdot+ydot+zdot
 TYA                    \ normal_count *4 so far
 LSR A
 LSR A                  \ /=4
 TAX                    \ normal index
 PLA                    \ xdot+ydot+zdot
 BIT S                  \ maybe new sign
 BMI P%+4               \ if -ve then keep Acc
 LDA #0                 \ else face not visible
 STA XX2,X              \ face visibility
 INY                    \ Y now taken up by a total of 4

.LL88                   \ near end of normals visibility loop

 CPY XX20               \ number of normals*4
 BCS LL42               \ If Y >= XX20 all normals' visibilities set, onto Transpose
 JMP LL86               \ loop normals visibility Y

                        \ -- All normals' visibilities now set in XX2,X
.LL42                   \ DO nodeX-Ycoords \ their comment  \  TrnspMat

 LDY XX16+2             \ Transpose Matrix
 LDX XX16+3
 LDA XX16+6
 STA XX16+2
 LDA XX16+7
 STA XX16+3
 STY XX16+6
 STX XX16+7
 LDY XX16+4
 LDX XX16+5
 LDA XX16+12
 STA XX16+4
 LDA XX16+13
 STA XX16+5
 STY XX16+12
 STX XX16+13
 LDY XX16+10
 LDX XX16+11
 LDA XX16+14
 STA XX16+10
 LDA XX16+15
 STA XX16+11
 STY XX16+14
 STX XX16+15

\XX16 got INWK 9..21..26 up at LL15  . The ROTMAT has 18 bytes, for 3x3 matrix
\XX16_lsb[   0  2  4    highest XX16 done below is 5, then X taken up by 6, Y taken up by 2.
\            6  8 10
\	    12 14 16=0 ?]

 LDY #8                 \ Hull byte#8 = number of vertices *6
 LDA (XX0),Y
 STA XX20
 LDA XX0                \ pointer to ship type data
 CLC                    \ build
 ADC #20                \ vertex data fixed offset
 STA V                  \ pointer to start of hull vertices
 LDA XX0+1
 ADC #0                 \ any carry
 STA V+1
 LDY #0                 \ index for XX3 heap
 STY CNT
}

.LL48                   \ Start loop on Nodes for visibility, each node has 4 faces associated with it
{
 STY XX17               \ vertex*6 counter
 LDA (V),Y
 STA XX15               \ xlo
 INY                    \ vertex byte#1
 LDA (V),Y
 STA XX15+2
 INY                    \ vertex byte#2
 LDA (V),Y
 STA XX15+4
 INY                    \ vertex byte#3
 LDA (V),Y
 STA T                  \ sign bits of vertex
 AND #31                \ visibility
 CMP XX4
 BCC LL49-3             \ if yes jmp LL50, next vertex
 INY                    \ vertex byte#4, first 2 faces
 LDA (V),Y
 STA P                  \ two 4-bit indices 0:15 into XX2 for 2 of the 4 normals
 AND #15                \ face 1
 TAX                    \ face visibility index
 LDA XX2,X
 BNE LL49               \ vertex is visible
 LDA P                  \ restore
 LSR A
 LSR A
 LSR A
 LSR A                  \ hi nibble
 TAX                    \ face 2
 LDA XX2,X
 BNE LL49               \ vertex is visible
 INY                    \ vertex byte#5, other 2 faces
 LDA (V),Y
 STA P                  \ two 4-bit indices 0:15 into XX2
 AND #15                \ face 3
 TAX                    \ face visibility index
 LDA XX2,X
 BNE LL49               \ vertex is visible
 LDA P                  \ restore
 LSR A
 LSR A
 LSR A
 LSR A                  \ hi nibble
 TAX                    \ face 4
 LDA XX2,X
 BNE LL49               \ vertex is visible
 JMP LL50               \ both arrive here \ LL49-3 \ next vertex

                        \ This jump can only happen if got 4 zeros from XX2 normals visibility
.LL49                   \ Else vertex is visible, update info on XX3 node heap

 LDA T                  \ 4th byte read for vertex, sign bits
 STA XX15+1
 ASL A                  \ y sgn
 STA XX15+3
 ASL A                  \ z sgn
 STA XX15+5
 JSR LL51               \ XX12=XX15.XX16   Rotated
 LDA XX1+2              \ x-sign
 STA XX15+2
 EOR XX12+1             \ rotated xnode hi
 BMI LL52               \ hop as -ve x sign
 CLC                    \ else x +ve
 LDA XX12               \ rotated xnode lo
 ADC XX1                \ xorg lo
 STA XX15               \ new x
 LDA XX1+1              \ INWK+1
 ADC #0                 \ hi x
 STA XX15+1
 JMP LL53               \ Onto y

.LL52                   \ -ve x sign

 LDA XX1                \ xorg lo
 SEC
 SBC XX12               \ rotated xnode lo
 STA XX15               \ new x
 LDA XX1+1              \ INWK+1
 SBC #0                 \ hi x
 STA XX15+1
 BCS LL53               \ usually ok Onto y
 EOR #&FF               \ else fix x negative
 STA XX15+1
 LDA #1                 \ negate
 SBC XX15
 STA XX15
 BCC P%+4               \ skip x hi
 INC XX15+1
 LDA XX15+2
 EOR #128               \ flip xsg
 STA XX15+2

.LL53                   \ Both x signs arrive here, Onto y

 LDA XX1+5              \ y-sign
 STA XX15+5
 EOR XX12+3             \ rotated ynode hi
 BMI LL54               \ hop as -ve y sign
 CLC                    \ else y +ve
 LDA XX12+2             \ rotated ynode lo
 ADC XX1+3              \ yorg lo
 STA XX15+3             \ new y
 LDA XX1+4
 ADC #0                 \ hi y
 STA XX15+4
 JMP LL55               \ Onto z

.LL54                   \ -ve y sign

 LDA XX1+3              \ yorg lo
 SEC
 SBC XX12+2             \ rotated ynode lo
 STA XX15+3             \ new ylo
 LDA XX1+4
 SBC #0                 \ hi y

 STA XX15+4
 BCS LL55               \ usually ok Onto z
 EOR #255               \ else fix y negative
 STA XX15+4
 LDA XX15+3
 EOR #255               \ negate y lo
 ADC #1
 STA XX15+3
 LDA XX15+5
 EOR #128               \ flip ysg
 STA XX15+5
 BCC LL55               \ Onto z
 INC XX15+4

.LL55                   \ Both y signs arrive here, Onto z

 LDA XX12+5             \ rotated znode hi
 BMI LL56               \ -ve Z node
 LDA XX12+4             \ rotated znode lo
 CLC
 ADC XX1+6              \ zorg lo
 STA T                  \ z new lo
 LDA XX1+7
 ADC #0                 \ hi
 STA U                  \ z new hi
 JMP LL57               \ Node additions done, z = U.T case
}

\ ******************************************************************************
\
\ Subroutine: LL61
\
\ Doing additions and scalings for each visible node around here
\
\ ******************************************************************************

                        \ Doing additions and scalings for each visible node around here
.LL61                   \ Handling division R=A/Q for case further down

 LDX Q
 BEQ LL84               \ div by zero div error
 LDX #0

.LL63                   \ roll Acc count Xreg

 LSR A
 INX                    \ counts required will be stored in S
 CMP Q
 BCS LL63               \ loop back if Acc >= Q
 STX S
 JSR LL28               \ BFRDIV R=A*256/Q byte from remainder of division
 LDX S                  \ restore Xcount
 LDA R                  \ remainder

.LL64                   \ counter Xreg

 ASL A                  \ lo boost
 ROL U                  \ hi
 BMI LL84               \ bit7 set, overflowed, div error
 DEX                    \ bring X back down
 BNE LL64               \ loop X
 STA R                  \ remainder
 RTS

.LL84                   \ div error  R=U=#50

 LDA #50
 STA R
 STA U
 RTS

.LL62                   \ Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT

 LDA #128               \ x-screen mid-point
 SEC                    \ xcoord lo
 SBC R
 STA XX3,X
 INX                    \ hi
 LDA #0                 \ xcoord hi
 SBC U
 STA XX3,X
 JMP LL66               \ xccord shoved, go back down

.LL56                   \ Enter XX12+5 -ve Z node case  from above

 LDA XX1+6              \ z org lo
 SEC
 SBC XX12+4             \ rotated z node lo
 STA T
 LDA XX1+7              \ zhi
 SBC #0
 STA U
 BCC LL140              \ underflow, make node close
 BNE LL57               \ Enter Node additions done, UT=z
 LDA T                  \ restore z lo
 CMP #4                 \ >= 4 ?
 BCS LL57               \ zlo big enough, Enter Node additions done

.LL140                  \ else make node close

 LDA #0                 \ hi
 STA U
 LDA #4                 \ lo
 STA T

.LL57                   \ Enter Node additions done, z=T.U set up from LL55

 LDA U                  \ z hi
 ORA XX15+1             \ x hi
 ORA XX15+4             \ y hi
 BEQ LL60               \ exit loop down once hi U rolled to 0
 LSR XX15+1
 ROR XX15
 LSR XX15+4
 ROR XX15+3
 LSR U                  \ z hi
 ROR T                  \ z lo
 JMP LL57               \ loop U

.LL60                   \ hi U rolled to 0, exited loop above

 LDA T
 STA Q                  \ zdist lo
 LDA XX15               \ rolled x lo
 CMP Q
 BCC LL69               \ if xdist < zdist hop over jmp to small x angle
 JSR LL61               \ visit up  R = A/Q = x/z
 JMP LL65               \ hop over small xangle

.LL69                   \ small x angle

 JSR LL28               \ BFRDIV R=A*256/Q byte for remainder of division

.LL65                   \ both continue for scaling based on z

 LDX CNT                \ index for XX3 heap
 LDA XX15+2             \ sign of X dist
 BMI LL62               \ up, -ve Xdist, RU screen onto XX3 heap
 LDA R                  \ xscaled
 CLC                    \ xcoord lo to XX3 heap
 ADC #128               \ x screen mid-point
 STA XX3,X
 INX                    \ x hi onto node heap
 LDA U
 ADC #0                 \ any carry to hi
 STA XX3,X

.LL66                   \ also from LL62, XX3 node heap has xscreen node so far

 TXA                    \ Onto y coord
 PHA                    \ push XX3 heap pointer
 LDA #0                 \ y hi = 0
 STA U
 LDA T
 STA Q                  \ zdist lo
 LDA XX15+3             \ rolled y low
 CMP Q
 BCC LL67               \ if ydist < zdist hop to small yangle

 JSR LL61               \ else visit up R = A/Q = y/z
 JMP LL68               \ hop over small y yangle

.LL70                   \ arrive from below, Yscreen for -ve RU onto XX3 node heap, index X=CNT

 LDA #Y                 \ #Y = #96 mid Yscreen \ also rts at LL70+1
 CLC                    \ ycoord lo to XX3 node heap
 ADC R                  \ yscaled
 STA XX3,X
 INX                    \ y hi to node heap
 LDA #0                 \ any carry to y hi
 ADC U
 STA XX3,X
 JMP LL50               \ down XX3 heap has yscreen node

.LL67                   \ Arrive from LL66 above if XX15+3 < Q \ small yangle

 JSR LL28               \ BFRDIV R=A*256/Q byte from remainder of division

.LL68                   \ -> &4CF5 both carry on, also arrive from LL66, yscaled based on z

 PLA                    \ restore
 TAX                    \ XX3 heap index
 INX                    \ take XX3 heap index up
 LDA XX15+5             \ rolled Ydist sign
 BMI LL70               \ up, -ve RU onto XX3 heap
 LDA #Y                 \ #Y = #96 Yscreen
 SEC                    \ subtracted yscaled and store on heap
 SBC R
 STA XX3,X
 INX                    \ y screen hi
 LDA #0                 \ any carry
 SBC U
 STA XX3,X

.LL50                   \ also from LL70, Also from  LL49-3. XX3 heap has yscreen, Next vertex

 CLC                    \ reload XX3 heap index base
 LDA CNT
 ADC #4                 \ +=4, next 16bit xcoord,ycoord pair on XX3 heap
 STA CNT
 LDA XX17               \ vertex*6 count
 ADC #6                 \ +=6
 TAY                    \ Y taken up to next vertex
 BCS LL72               \ down Loaded if maxed out number of vertices (42)
 CMP XX20               \ number of vertices*6
 BCS LL72               \ done Loaded if all vertices done, exit loop
 JMP LL48               \ loop Y back to next vertex at transpose matrix

.LL72                   \ XX3 node heap already loaded with 16bit xy screen

 LDA XX1+31             \ display/exploding state|missiles
 AND #32                \ bit5 of mask
 BEQ EE31               \ if zero no explosion
 LDA XX1+31
 ORA #8                 \ else set bit3 to erase old line
 STA XX1+31
 JMP DOEXP              \ explosion

.EE31                   \ no explosion

 LDA #8                 \ mask bit 3 set of
 BIT XX1+31             \ exploding/display state|missiles
 BEQ LL74               \ clear is hop to do New lines
 JSR LL155              \ else erase lines in XX19 heap at LINEstr down
 LDA #8                 \ set bit3, as new lines

.LL74                   \ do New lines

 ORA XX1+31
 STA XX1+31
 LDY #9                 \ Hull byte#9, number of edges
 LDA (XX0),Y
 STA XX20               \ number of edges
 LDY #0                 \ ship lines heap offset to 0 for XX19
 STY U
 STY XX17               \ edge counter
 INC U                  \ ship lines heap offset = 1
 BIT XX1+31
 BVC LL170              \ bit6 of display state clear (laser not firing) \ Calculate new lines
 LDA XX1+31
 AND #&BF               \ else laser is firing, clear bit6
 STA XX1+31
 LDY #6                 \ Hull byte#6, gun vertex*4
 LDA (XX0),Y
 TAY                    \ index to gun on XX3 heap
 LDX XX3,Y
 STX XX15               \  x1 lo
 INX                    \ was heap entry updated from #255?
 BEQ LL170              \ skip the rest (laser node not visible)
 LDX XX3+1,Y
 STX XX15+1             \  x1 hi
 INX                    \ was heap entry updated from #255?
 BEQ LL170              \ skip the rest (laser node not visible)
 LDX XX3+2,Y
 STX XX15+2             \ y1 lo
 LDX XX3+3,Y
 STX XX15+3             \ y1 hi
 LDA #0                 \ x2 lo.hi = 0
 STA XX15+4
 STA XX15+5
 STA XX12+1             \ y2 high = 0
 LDA XX1+6              \ z ship lo
 STA XX12               \ y2 low = z-lo
 LDA XX1+2              \ xship-sgn
 BPL P%+4               \ skip dec
 DEC XX15+4             \ else x2 lo =#255 to right across screen
 JSR LL145              \ clip test on XX15 XX12 vector
 BCS LL170              \ if carry set skip the rest (laser not firing)
 LDY U                  \ ship lines heap offset
 LDA XX15               \ push (now clipped) to clipped lines ship heap
 STA (XX19),Y
 INY
 LDA XX15+1             \ Y1
 STA (XX19),Y
 INY
 LDA XX15+2             \ X2
 STA (XX19),Y
 INY
 LDA XX15+3             \ Y2
 STA (XX19),Y
 INY
 STY U                  \ ship lines heap offset updated

.LL170                  \ (laser not firing) \ Calculate new lines	\ their comment

 LDY #3                 \ Hull byte#3 edges lo
 CLC                    \ build base pointer
 LDA (XX0),Y
 ADC XX0
 STA V                  \ is pointer to where edges data start
 LDY #16                \ Hull byte #16 edges hi
 LDA (XX0),Y
 ADC XX0+1
 STA V+1
 LDY #5                 \ Hull byte#5 is 4*MAXLI + 1, for ship lines stack
 LDA (XX0),Y
 STA T1                 \ 4*MAXLI + 1, edge counter limit
 LDY XX17               \ edge counter

.LL75                   \ count Visible edges

 LDA (V),Y              \ edge data byte#0
 CMP XX4                \ visibility
 BCC LL78               \ edge not visible
 INY
 LDA (V),Y              \ edge data byte#1
 INY                    \ Y = 2
 STA P                  \ store byte#1
 AND #15
 TAX                    \ lower 4 bits are face1
 LDA XX2,X              \ face visibility
 BNE LL79               \ hop down to Visible edge
 LDA P                  \ restore byte#1
 LSR A
 LSR A
 LSR A
 LSR A                  \ /=16 upper nibble
 TAX                    \ upper 4 bits are face2
 LDA XX2,X              \ face visibility
 BEQ LL78               \ edge not visible

.LL79                   \ Visible edge

 LDA (V),Y              \ edge data byte#2
 TAX                    \ index into node heap for first node of edge
 INY                    \ Y = 3
 LDA (V),Y              \ edge data byte#3
 STA Q                  \ index into node heap for other node of edge
 LDA XX3+1,X
 STA XX15+1             \ x1 hi
 LDA XX3,X
 STA XX15               \ x1 lo
 LDA XX3+2,X
 STA XX15+2             \ y1 lo
 LDA XX3+3,X
 STA XX15+3             \ y1 hi
 LDX Q                  \ other index into node heap for second node
 LDA XX3,X
 STA XX15+4             \ x2 lo
 LDA XX3+3,X
 STA XX12+1             \ y2 hi
 LDA XX3+2,X
 STA XX12               \ y2 lo
 LDA XX3+1,X
 STA XX15+5             \ x2 hi
 JSR LL147              \ CLIP2, take care of swop and clips
 BCS LL78               \ jmp LL78 edge not visible

.LL80                   \ Shove visible edge onto XX19 ship lines heap counter U

 LDY U                  \ clipped edges heap index
 LDA XX15               \ X1
 STA (XX19),Y
 INY
 LDA XX15+1             \ Y1
 STA (XX19),Y
 INY
 LDA XX15+2             \ X2
 STA (XX19),Y
 INY
 LDA XX15+3             \ Y2
 STA (XX19),Y
 INY
 STY U                  \ clipped ship lines heap index
 CPY T1                 \ >=  4*MAXLI + 1 counter limit
 BCS LL81               \ hop over jmp to Exit edge data loop

.LL78                   \ also arrive here if Edge not visible, loop next data edge

 INC XX17               \ edge counter
 LDY XX17
 CPY XX20               \ number of edges
 BCS LL81               \ hop over jmp to Exit edge data loop
 LDY #0                 \ else next edge
 LDA V
 ADC #4                 \ take edge data pointer up to next edge
 STA V
 BCC ll81               \ skip inc hi
 INC V+1

.ll81                   \ skip inc hi

 JMP LL75               \ Loop Next Edge

.LL81                   \ Exited edge data loop

 LDA U                  \ clipped ship lines heap index for (XX19),Y
 LDY #0                 \ first entry in ship edges heap is number of bytes
 STA (XX19),Y

.LL155                  \ CLEAR LINEstr visited by EE31 when XX3 heap ready to draw/erase lines in XX19 heap

 LDY #0                 \ number of bytes
 LDA (XX19),Y
 STA XX20               \ valid length of heap XX19
 CMP #4                 \ if < 4 then
 BCC LL118-1            \ rts
 INY                    \ #1

.LL27                   \ counter Y, Draw clipped lines in XX19 ship lines heap

 LDA (XX19),Y
 STA XX15               \ X1
 INY
 LDA (XX19),Y
 STA XX15+1             \ Y1
 INY
 LDA (XX19),Y
 STA XX15+2             \ X2
 INY
 LDA (XX19),Y
 STA XX15+3             \ Y2
 JSR LL30               \ draw line using (X1,Y1), (X2,Y2)
 INY                    \ +=4
 CPY XX20               \ valid number of edges in heap XX19
 BCC LL27               \ loop Y
\LL82
 RTS                    \ --- Wireframe end  \ LL118-1

\ ******************************************************************************
\
\ Subroutine: LL118
\
\ Trim XX15,XX15+2 to screen grad=XX12+2 for CLIP
\
\ ******************************************************************************

.LL118                  \ Trim XX15,XX15+2 to screen grad=XX12+2 for CLIP
{
 LDA XX15+1             \ x1 hi
 BPL LL119              \ x1 hi+ve skip down
 STA S                  \ else x1 hi -ve
 JSR LL120              \ X1<0 \ their comment \ X.Y = x1_lo.S *  M/256
 TXA                    \ step Y1 lo
 CLC
 ADC XX15+2             \ Y1 lo
 STA XX15+2
 TYA                    \ step Y1 hi
 ADC XX15+3             \ Y1 hi
 STA XX15+3
 LDA #0                 \ xleft min
 STA XX15               \ X1 lo
 STA XX15+1             \ X1 = 0
 TAX                    \ Xreg = 0, will skip to Ytrim

.LL119                  \ x1 hi +ve from LL118

 BEQ LL134              \ if x1 hi = 0 skip to Ytrim
 STA S                  \ else x1 hi > 0
 DEC S                  \ x1 hi-1
 JSR LL120              \ X1>255 \ their comment \ X.Y = x1lo.S *  M/256
 TXA                    \ step Y1 lo
 CLC
 ADC XX15+2             \ Y1 lo
 STA XX15+2
 TYA                    \ step Y1 hi
 ADC XX15+3             \ Y1 hi
 STA XX15+3
 LDX #&FF               \ xright max
 STX XX15               \ X1 lo = 255
 INX                    \ = 0
 STX XX15+1             \ X1 hi

.LL134                  \ Ytrim

 LDA XX15+3             \ y1 hi
 BPL LL135              \ y1 hi +ve
 STA S                  \ else y1 hi -ve
 LDA XX15+2             \ y1 lo
 STA R                  \ Y1<0 their comment
 JSR LL123              \ X.Y=R.S*256/M (M=grad.)   \where 256/M is gradient
 TXA                    \ step X1 lo
 CLC
 ADC XX15               \ X1 lo
 STA XX15
 TYA                    \ step X1 hi
 ADC XX15+1             \ X1 hi
 STA XX15+1
 LDA #0                 \ Y bottom min
 STA XX15+2             \ Y1 lo
 STA XX15+3             \ Y1 hi = 0

.LL135                  \ y1 hi +ve from LL134
\BNE LL139
 LDA XX15+2             \ Y1 lo
 SEC
 SBC #Y*2               \ #Y*2  screen y height
 STA R                  \ Y1>191 their comment
 LDA XX15+3             \ Y1 hi
 SBC #0
 STA S
 BCC LL136              \ failed, rts

.LL139

 JSR LL123              \ X.Y=R.S*256/M (M=grad.)   \where 256/M is gradient
 TXA                    \ step X1 lo
 CLC
 ADC XX15               \ X1 lo
 STA XX15
 TYA                    \ step X1 hi
 ADC XX15+1             \ X1 hi
 STA XX15+1
 LDA #Y*2-1             \ #Y*2-1 = y top max
 STA XX15+2             \ Y1 lo
 LDA #0                 \ Y1 hi = 0
 STA XX15+3             \ Y1 = 191

.LL136                  \ rts

 RTS                    \ -- trim for CLIP done
}

\ ******************************************************************************
\
\ Subroutine: LL120
\
\ X.Y=x1lo.S*M/256  	\ where M/256 is gradient
\
\ ******************************************************************************

.LL120                  \ X.Y=x1lo.S*M/256  	\ where M/256 is gradient
{
 LDA XX15               \ x1 lo
 STA R

\.LL120

 JSR LL129              \ RS = abs(x1=RS) and return with
 PHA                    \ store Acc = hsb x1 EOR quadrant_info, Q = (1/)gradient
 LDX T                  \ steep toggle = 0 or FF for steep/shallow down
 BNE LL121              \ down Steep
}

.LL122                  \ else Shallow return step, also arrive from LL123 for steep stepX
{
 LDA #0
 TAX
 TAY                    \ all = 0 at start
 LSR S                  \ hi /=2
 ROR R                  \ lo /=2
 ASL Q                  \ double 1/gradient
 BCC LL126              \ hop first half of loop

.LL125                  \ roll Q up

 TXA                    \ increase step
 CLC
 ADC R
 TAX                    \ lo
 TYA                    \ hi
 ADC S
 TAY                    \ hi

.LL126                  \ first half of loop done

 LSR S                  \ hi /=2
 ROR R                  \ lo /=2
 ASL Q                  \ double 1/gradient
 BCS LL125              \ if gradient not too small, loop Q
 BNE LL126              \ half loop as Q not emptied yet
 PLA                    \ restore quadrant info
 BPL LL133              \ flip XY sign
 RTS
}

\ ******************************************************************************
\
\ Subroutine: LL123
\
\ X.Y=R.S*256/M (M=grad.)	\ where 256/M is gradient
\
\ ******************************************************************************

.LL123                  \ X.Y=R.S*256/M (M=grad.)	\ where 256/M is gradient
{
 JSR LL129              \ RS = abs(y1=RS) and return with
 PHA                    \ store  Acc = hsb x1 EOR hi, Q = (1/)gradient
 LDX T                  \ steep toggle = 0 or FF for steep/shallow up
 BNE LL122              \ up Shallow
}

.LL121                  \ T = #&FF for Steep return stepY, shallow stepX
{
 LDA #255
 TAY
 ASL A                  \ #&FE
 TAX                    \ Step X.Y= &FFFE at start

.LL130                  \ roll Y

 ASL R                  \ lo *=2
 ROL S                  \ hi *=2
 LDA S
 BCS LL131              \ if S overflowed skip Q test and do subtractions
 CMP Q
 BCC LL132              \ if S <  Q = 256/gradient skip subtractions

.LL131                  \ skipped Q test

 SBC Q
 STA S                  \ lo
 LDA R
 SBC #0                 \ hi
 STA R
 SEC

.LL132                  \ skipped subtractions

 TXA                    \ increase step
 ROL A
 TAX                    \ stepX lo
 TYA
 ROL A
 TAY                    \ stepX hi
 BCS LL130              \ loop Y if bit fell out of Y
 PLA                    \ restore quadrant info
 BMI LL128              \ down rts
}

.LL133                  \ flip XY sign, quadrant info +ve in LL120 arrives here too
{
 TXA
 EOR #&FF
\CLC
 ADC #1
 TAX                    \ flip sign of x
 TYA
 EOR #&FF
 ADC #0
 TAY                    \ flip sign of y
}

.LL128
{
 RTS
}

\ ******************************************************************************
\
\ Subroutine: LL129
\
\ RS = abs(RS) and return Acc = hsb x1 EOR hi, Q = (1/)gradient
\
\ ******************************************************************************

.LL129                  \ RS = abs(RS) and return Acc = hsb x1 EOR hi, Q = (1/)gradient
{
 LDX XX12+2             \ gradient
 STX Q
 LDA S                  \ hi
 BPL LL127              \ hop to eor
 LDA #0                 \ else flip sign of R
 SEC
 SBC R
 STA R
 LDA S
 PHA                    \ push old S
 EOR #255               \ flip S
 ADC #0
 STA S
 PLA                    \ pull old S for eor

.LL127

 EOR XX12+3             \ Acc ^= quadrant info
 RTS                    \ -- CLIP, bounding box is now done,
}

\ ******************************************************************************
\
\ Subroutine: LL145
\
\ CLIP  XX15 XX12 line
\
\ ******************************************************************************

.LL145                  \ -> &4E19  CLIP  XX15 XX12 line
{
                        \ also called by BLINE, waiting for (X1,Y1), (X2,Y2) to draw a line
                        \ Before clipping,  XX15(0,1) was x1.  XX15(2,3) was y1. XX15(4,5) was x2. XX12(0,1) was y2

 LDA #0
 STA SWAP
 LDA XX15+5             \ x2 hi
}

.LL147                  \ CLIP2 arrives from LL79 to do swop and clip
{
 LDX #Y*2-1             \ #Y*2-1 yClip = screen height
 ORA XX12+1             \ y2 hi
 BNE LL107              \ skip yClip
 CPX XX12               \ is screen hight < y2 lo ?
 BCC LL107              \ if yes, skip yClip
 LDX #0                 \ else yClip = 0

.LL107                  \ skipped yClip

 STX XX13               \ yClip
 LDA XX15+1             \ x1 hi
 ORA XX15+3             \ y1 hi
 BNE LL83               \ no hi bits in coord 1 present
 LDA #Y*2-1             \ #Y*2-1  screen height
 CMP XX15+2             \ y1 lo
 BCC LL83               \ if screen height < y1 lo skip A top
 LDA XX13               \ yClip
 BNE LL108              \ hop down, yClip not zero

.LL146                  \ Finished clipping, Shuffle XX15 down to (X1,Y1) (X2,Y2)

 LDA XX15+2             \ y1 lo
 STA XX15+1             \ new Y1
 LDA XX15+4             \ x2 lo
 STA XX15+2             \ new X2
 LDA XX12               \ y2 lo
 STA XX15+3             \ new Y2
 CLC                    \ valid to plot is in XX15(0to3)
 RTS                    \ 2nd pro different, it swops based on swop flag around here

.LL109                  \ clipped line Not visible

 SEC
 RTS

.LL108                  \ arrived as yClip not zero in LL107 clipping

 LSR XX13               \ yClip = Ymid

.LL83                   \ also arrive from LL107 if bits in hi present or y1_lo > screen height, A top

 LDA XX13               \ yClip
 BPL LL115              \ yClip < 128
 LDA XX15+1             \ x1 hi
 AND XX15+5             \ x2 hi
 BMI LL109              \ clipped line Not visible
 LDA XX15+3             \ y1 hi
 AND XX12+1             \ y2 hi
 BMI LL109              \ clipped line Not visible
 LDX XX15+1             \ x1 hi
 DEX
 TXA                    \ Acc = x1 hi -1
 LDX XX15+5             \ x2 hi
 DEX
 STX XX12+2             \ x2 hi --
 ORA XX12+2             \ (x1 hi -1) or (x2 hi -1)
 BPL LL109              \ clipped line not visible
 LDA XX15+2             \ y1 lo
 CMP #Y*2               \ #Y*2  screen height, maybe carry set
 LDA XX15+3             \ y1 hi
 SBC #0                 \ any carry
 STA XX12+2             \ y1 hi--
 LDA XX12               \ y2 lo
 CMP #Y*2               \ #Y*2 screen height, maybe carry set
 LDA XX12+1             \ y2 hi
 SBC #0                 \ any carry
 ORA XX12+2             \ (y1 hi -1) or (y2 hi -1)
 BPL LL109              \ clipped line Not visible

.LL115                  \ also arrive from LL83 with yClip < 128 need to trim

 TYA                    \ index for edge data
 PHA                    \ protect offset
 LDA XX15+4             \ x2 lo
 SEC
 SBC XX15               \ x1 lo
 STA XX12+2             \ delta_x lo
 LDA XX15+5             \ x2 hi
 SBC XX15+1             \ x1 hi
 STA XX12+3             \ delta_x hi
 LDA XX12               \ y2 lo
 SEC
 SBC XX15+2             \ y1 lo
 STA XX12+4             \ delta_y lo
 LDA XX12+1             \ y2 hi
 SBC XX15+3             \ y1 hi
 STA XX12+5             \ delta_y hi
 EOR XX12+3             \ delta_x hi
 STA S                  \ quadrant relationship for gradient
 LDA XX12+5             \ delta_y hi
 BPL LL110              \ hop down if delta_y positive
 LDA #0                 \ else flip sign of delta_y
 SEC                    \ delta_y lo
 SBC XX12+4
 STA XX12+4
 LDA #0                 \ delta_y hi
 SBC XX12+5
 STA XX12+5

.LL110                  \ delta_y positive

 LDA XX12+3             \ delta_x hi
 BPL LL111              \ hop down if positive to GETgrad
 SEC                    \ else flip sign of delta_x
 LDA #0                 \ delta_x lo
 SBC XX12+2
 STA XX12+2
 LDA #0                 \ Acc will have delta_x hi +ve
 SBC XX12+3

                        \ GETgrad get Gradient for trimming
.LL111                  \ roll Acc  delta_x hi

 TAX                    \ delta_x hi
 BNE LL112              \ skip if delta_x hi not zero
 LDX XX12+5             \ delta_y hi
 BEQ LL113              \ Exit when both delta hi zero

.LL112                  \ skipped as delta_x hi not zero

 LSR A                  \ delta_x hi/=2
 ROR XX12+2             \ delta_x lo/=2

 LSR XX12+5             \ delta_y hi/=2
 ROR XX12+4             \ delta_y lo/=2
 JMP LL111              \ loop GETgrad

.LL113                  \ Exited as both delta hi zero for trimming

 STX T                  \ delta_y hi = 0
 LDA XX12+2             \ delta_x lo
 CMP XX12+4             \ delta_y lo
 BCC LL114              \ hop to STEEP as x < y
 STA Q                  \ else shallow, Q = delta_x lo
 LDA XX12+4             \ delta_y lo
 JSR LL28               \ BFRDIV R=A*256/Q = delta_y / delta_x

                        \ Use Y/X grad. \ as not steep
 JMP LL116              \ gradient now known, go a few lines down

.LL114                  \ else STEEP

 LDA XX12+4             \ delta_y lo
 STA Q
 LDA XX12+2             \ delta_x lo
 JSR LL28               \ BFRDIV R=A*256/Q = delta_x / delta_y

                        \ Use X/Y grad
 DEC T                  \ steep toggle updated T = #&FF

.LL116                  \ arrive here for both options with known gradient

 LDA R                  \ gradient
 STA XX12+2
 LDA S                  \ quadrant info
 STA XX12+3
 LDA XX13
 BEQ LL138              \ yClip = 0 or 191?, skip bpl
 BPL LLX117             \ yClip+ve, swop nodes

.LL138                  \ yClip = 0 or or >127   need to fit x1,y1 into bounding box

 JSR LL118              \ Trim XX15,XX15+2 to screen grad=XX12+2
 LDA XX13
 BPL LL124              \ yClip+ve, finish clip

.LL117                  \ yClip > 127

 LDA XX15+1             \ x1 hi
 ORA XX15+3             \ y1 hi
 BNE LL137              \ some hi bits present, no line
 LDA XX15+2             \ y1 lo
 CMP #Y*2               \ #Y*2  Yscreen full height
 BCS LL137              \ if y1 lo >= Yscreen,  no line

.LLX117                 \ yClip+ve from LL116, swop nodes then trim nodes, XX12+2 = gradient, XX12+3 = quadrant info

 LDX XX15               \ x1 lo
 LDA XX15+4             \ x2 lo
 STA XX15
 STX XX15+4
 LDA XX15+5             \ x2 hi
 LDX XX15+1             \ x1 hi
 STX XX15+5
 STA XX15+1
 LDX XX15+2             \ Onto swopping y
 LDA XX12               \ y2 lo
 STA XX15+2
 STX XX12
 LDA XX12+1             \ y2 hi
 LDX XX15+3             \ y1 hi
 STX XX12+1
 STA XX15+3             \ finished swop of (x1 y1) and (x2 y2)
 JSR LL118              \ Trim XX15,XX15+2 to screen grad=XX12+2
 DEC SWAP

.LL124                  \ also yClip+ve from LL138, finish clip

 PLA                    \ restore ship edge index
 TAY
 JMP LL146              \ up, Finished clipping, Shuffle XX15 down to (x1,y1) (x2,y2)

.LL137                  \ no line

 PLA                    \ restore ship edge index
 TAY
 SEC                    \ not visible
 RTS                    \ -- Finished clipping
}

\ ******************************************************************************
\
\ Save output/ELTG.bin
\
\ ******************************************************************************

PRINT "ELITE G"
PRINT "Assembled at ", ~CODE_G%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_G%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_G%

PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
SAVE "output/ELTG.bin", CODE_G%, P%, LOAD%

\ ******************************************************************************
\
\ Variable: checksum0
\
\ This byte contains a checksum for the entire source file. It is populated by
\ elite-checksum.py and is used by the encryption checks in elite-loader.asm
\ (see the CHK routine in the loader for more details).
\
\ ******************************************************************************

.checksum0
{
SKIP 1
}

\ ******************************************************************************
\
\ ELITE SHIP BLUEPRINTS
\
\ Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
\
\ ******************************************************************************

CODE_SHIPS% = P%
LOAD_SHIPS% = LOAD% + P% - CODE%

\ ******************************************************************************
\
\ Variable: XX21
\
\ Ship blueprints lookup table.
\
\ The following lookup table points to the individual ship blueprints below.
\
\ ******************************************************************************

.XX21

 EQUW SHIP1             \         1 = Sidewinder
 EQUW SHIP2             \ COPS =  2 = Viper
 EQUW SHIP3             \ MAM  =  3 = Mamba
 EQUW &7F00             \         4 = Python
 EQUW SHIP5             \         5 = Cobra Mk III (bounty hunter)
 EQUW SHIP6             \ THG  =  6 = Thargoid
 EQUW SHIP5             \ CYL  =  7 = Cobra Mk III (trader)
 EQUW SHIP8             \ SST  =  8 = Coriolis space station
 EQUW SHIP9             \ MSL  =  9 = Missile
 EQUW SHIP10            \ AST  = 10 = Asteroid
 EQUW SHIP11            \ OIL  = 11 = Cargo
 EQUW SHIP12            \ TGL  = 12 = Thargon
 EQUW SHIP13            \ ESC  = 13 = Escape pod

\ ******************************************************************************
\
\ Ship blueprints
\
\ For each ship blueprint below, the first 20 bytes define the following:
\
\ Byte #0       Maximum number of bits of debris shown when destroyed
\ Byte #1-2     The ship's "hit area", which represents how far the ship can be
\               from the centre of our crosshairs and still be locked onto by
\               our missles or hit by our lasers, as described in the HITCH
\               routine (16-bit value, 1 = low byte, 2 = high byte)
\ Byte #3       Edges data offset lo (offset is from byte #0)
\ Byte #4       Faces data offset lo (offset is from byte #0)
\ Byte #5       Maximum heap size for plotting ship = 1 + 4 * max. no of
\               visible edges
\ Byte #6       Number * 4 of the vertex used for gun spike, if applicable
\ Byte #7       Explosion count = 4 * n + 6, where n = number of vertices used
\               as origins for explosion dust
\ Byte #8       Number of vertices * 6
\ Byte #10-11   The bounty awarded for the destruction of this ship in Cr * 10
\               (16-bit value, 10 = low byte, 11 = high byte)
\ Byte #12      Number of faces * 4
\ Byte #13      Beyond this distance, show this ship as a dot
\ Byte #14      Maximum energy/shields
\ Byte #15      Maximum speed
\ Byte #16      Edges data offset hi (if this is negative (&FF) it points to
\               another ship's edge net)
\ Byte #17      Faces data offset hi
\ Byte #18      Q%: Normals are scaled by 2^Q% to make large objects' normals
\               flare out further away (see EE29)
\ Byte #19      %00 lll mmm, where bits 0-2 = number of missiles,
\               bits 3-5 = laser power
\ ******************************************************************************

.SHIP1                              \ Sidewinder ship blueprint

 EQUB &00
 EQUB &81, &10
 EQUB &50
 EQUB &8C
 EQUB &3D
 EQUB &00                           \ gun vertex = 0
 EQUB &1E
 EQUB &3C                           \ number of vertices = &3C / 6 = 10
 EQUB &0F                           \ number of edges = &0F = 15
 EQUW 50                            \ bounty = 50
 EQUB &1C                           \ number of faces = &1C / 4 = 7
 EQUB &14
 EQUB &46
 EQUB &25
 EQUB &00
 EQUB &00
 EQUB &02
 EQUB %00010000                     \ laser power = 2, missiles = 0

 EQUB &20, &00, &24, &9F, &10, &54  \ vertices data (10*6)
 EQUB &20, &00, &24, &1F, &20, &65
 EQUB &40, &00, &1C, &3F, &32, &66
 EQUB &40, &00, &1C, &BF, &31, &44
 EQUB &00, &10, &1C, &3F, &10, &32

 EQUB &00, &10, &1C, &7F, &43, &65
 EQUB &0C, &06, &1C, &AF, &33, &33
 EQUB &0C, &06, &1C, &2F, &33, &33
 EQUB &0C, &06, &1C, &6C, &33, &33
 EQUB &0C, &06, &1C, &EC, &33, &33

 EQUB &1F, &50, &00, &04            \ edges data (15*4)
 EQUB &1F, &62, &04, &08
 EQUB &1F, &20, &04, &10
 EQUB &1F, &10, &00, &10
 EQUB &1F, &41, &00, &0C

 EQUB &1F, &31, &0C, &10
 EQUB &1F, &32, &08, &10
 EQUB &1F, &43, &0C, &14
 EQUB &1F, &63, &08, &14
 EQUB &1F, &65, &04, &14

 EQUB &1F, &54, &00, &14
 EQUB &0F, &33, &18, &1C
 EQUB &0C, &33, &1C, &20
 EQUB &0C, &33, &18, &24
 EQUB &0C, &33, &20, &24

 EQUB &1F, &00, &20, &08            \ faces data (7*4)
 EQUB &9F, &0C, &2F, &06
 EQUB &1F, &0C, &2F, &06
 EQUB &3F, &00, &00, &70
 EQUB &DF, &0C, &2F, &06

 EQUB &5F, &00, &20, &08
 EQUB &5F, &0C, &2F, &06

.SHIP2                              \ Viper ship blueprint

 EQUB &00
 EQUB &F9, &15
 EQUB &6E
 EQUB &BE
 EQUB &4D
 EQUB &00                           \ gun vertex = 0
 EQUB &2A
 EQUB &5A                           \ number of vertices = &5A / 6 = 15
 EQUB &14                           \ number of edges = &14 = 20
 EQUW 0                             \ bounty = 0
 EQUB &1C                           \ number of faces = &1C / 4 = 7
 EQUB &17
 EQUB &78
 EQUB &20
 EQUB &00
 EQUB &00
 EQUB &01
 EQUB %00010001                     \ laser power = 2, missiles = 1

 EQUB &00, &00, &48, &1F, &21, &43  \ vertices data (15*6)
 EQUB &00, &10, &18, &1E, &10, &22
 EQUB &00, &10, &18, &5E, &43, &55
 EQUB &30, &00, &18, &3F, &42, &66
 EQUB &30, &00, &18, &BF, &31, &66

 EQUB &18, &10, &18, &7E, &54, &66
 EQUB &18, &10, &18, &FE, &35, &66
 EQUB &18, &10, &18, &3F, &20, &66
 EQUB &18, &10, &18, &BF, &10, &66
 EQUB &20, &00, &18, &B3, &66, &66

 EQUB &20, &00, &18, &33, &66, &66
 EQUB &08, &08, &18, &33, &66, &66
 EQUB &08, &08, &18, &B3, &66, &66
 EQUB &08, &08, &18, &F2, &66, &66
 EQUB &08, &08, &18, &72, &66, &66

 EQUB &1F, &42, &00, &0C            \ edges data (20*4)
 EQUB &1E, &21, &00, &04
 EQUB &1E, &43, &00, &08
 EQUB &1F, &31, &00, &10
 EQUB &1E, &20, &04, &1C

 EQUB &1E, &10, &04, &20
 EQUB &1E, &54, &08, &14
 EQUB &1E, &53, &08, &18
 EQUB &1F, &60, &1C, &20
 EQUB &1E, &65, &14, &18

 EQUB &1F, &61, &10, &20
 EQUB &1E, &63, &10, &18
 EQUB &1F, &62, &0C, &1C
 EQUB &1E, &46, &0C, &14
 EQUB &13, &66, &24, &30

 EQUB &12, &66, &24, &34
 EQUB &13, &66, &28, &2C
 EQUB &12, &66, &28, &38
 EQUB &10, &66, &2C, &38
 EQUB &10, &66, &30, &34

 EQUB &1F, &00, &20, &00            \ faces data (7*4)
 EQUB &9F, &16, &21, &0B
 EQUB &1F, &16, &21, &0B
 EQUB &DF, &16, &21, &0B
 EQUB &5F, &16, &21, &0B

 EQUB &5F, &00, &20, &00
 EQUB &3F, &00, &00, &30

.SHIP3                              \ Mamba ship blueprint

 EQUB &01                           \ debris shown = 1
 EQUB &24, &13
 EQUB &AA
 EQUB &1A
 EQUB &5D
 EQUB &00                           \ gun vertex = 0
 EQUB &22
 EQUB &96                           \ number of vertices = &96 / 6 = 25
 EQUB &1C                           \ number of edges = &1C = 28
 EQUW 150                           \ bounty = 150
 EQUB &14                           \ number of faces = &14 / 4 = 5
 EQUB &19
 EQUB &5A
 EQUB &1E
 EQUB &00
 EQUB &01
 EQUB &02
 EQUB %000010010                    \ laser power = 2, missiles = 2

 EQUB &00, &00, &40, &1F, &10, &32  \ vertices data (25*6)
 EQUB &40, &08, &20, &FF, &20, &44
 EQUB &20, &08, &20, &BE, &21, &44
 EQUB &20, &08, &20, &3E, &31, &44
 EQUB &40, &08, &20, &7F, &30, &44

 EQUB &04, &04, &10, &8E, &11, &11
 EQUB &04, &04, &10, &0E, &11, &11
 EQUB &08, &03, &1C, &0D, &11, &11
 EQUB &08, &03, &1C, &8D, &11, &11
 EQUB &14, &04, &10, &D4, &00, &00

 EQUB &14, &04, &10, &54, &00, &00
 EQUB &18, &07, &14, &F4, &00, &00
 EQUB &10, &07, &14, &F0, &00, &00
 EQUB &10, &07, &14, &70, &00, &00
 EQUB &18, &07, &14, &74, &00, &00

 EQUB &08, &04, &20, &AD, &44, &44
 EQUB &08, &04, &20, &2D, &44, &44
 EQUB &08, &04, &20, &6E, &44, &44
 EQUB &08, &04, &20, &EE, &44, &44
 EQUB &20, &04, &20, &A7, &44, &44

 EQUB &20, &04, &20, &27, &44, &44
 EQUB &24, &04, &20, &67, &44, &44
 EQUB &24, &04, &20, &E7, &44, &44
 EQUB &26, &00, &20, &A5, &44, &44
 EQUB &26, &00, &20, &25, &44, &44

 EQUB &1F, &20, &00, &04            \ edges data (28*4)
 EQUB &1F, &30, &00, &10
 EQUB &1F, &40, &04, &10
 EQUB &1E, &42, &04, &08
 EQUB &1E, &41, &08, &0C

 EQUB &1E, &43, &0C, &10
 EQUB &0E, &11, &14, &18
 EQUB &0C, &11, &18, &1C
 EQUB &0D, &11, &1C, &20
 EQUB &0C, &11, &14, &20

 EQUB &14, &00, &24, &2C
 EQUB &10, &00, &24, &30
 EQUB &10, &00, &28, &34
 EQUB &14, &00, &28, &38
 EQUB &0E, &00, &34, &38

 EQUB &0E, &00, &2C, &30
 EQUB &0D, &44, &3C, &40
 EQUB &0E, &44, &44, &48
 EQUB &0C, &44, &3C, &48
 EQUB &0C, &44, &40, &44

 EQUB &07, &44, &50, &54
 EQUB &05, &44, &50, &60
 EQUB &05, &44, &54, &60
 EQUB &07, &44, &4C, &58
 EQUB &05, &44, &4C, &5C

 EQUB &05, &44, &58, &5C
 EQUB &1E, &21, &00, &08
 EQUB &1E, &31, &00, &0C

 EQUB &5E, &00, &18, &02            \ faces data (5*4)
 EQUB &1E, &00, &18, &02
 EQUB &9E, &20, &40, &10
 EQUB &1E, &20, &40, &10
 EQUB &3E, &00, &00, &7F

.SHIP5                              \ Variable: SHIP5

 EQUB &03                           \ debris shown = 3
 EQUB &41, &23                      \ area for missile lock = &2331
 EQUB &BC                           \ edges data offset = &00BC
 EQUB &54                           \ faces data offset = &0154
 EQUB &99                           \ max. edge count = (&99 - 1) / 4 = 38
 EQUB &54                           \ gun vertex = &54 / 4 = 21
 EQUB &2A                           \ explosion count = 9, (4 * n) + 6 = &2A
 EQUB &A8                           \ number of vertices = &A8 / 6 = 28
 EQUB &26                           \ number of edges = &26 = 38
 EQUW 0                             \ bounty = 0
 EQUB &34                           \ number of faces = &34 / 4 = 13
 EQUB &32                           \ show as a dot past a distance of 50
 EQUB &96                           \ maximum energy/shields = 150
 EQUB &1C                           \ maximum speed = 28
 EQUB &00                           \ edges data offset = &00BC
 EQUB &01                           \ faces data offset = &0154
 EQUB &01                           \ normals are scaled by 2^1 = 2
 EQUB %00010011                     \ laser power = 2, missiles = 3

 EQUB &20, &00, &4C, &1F, &FF, &FF  \ vertices data (28*6)
 EQUB &20, &00, &4C, &9F, &FF, &FF
 EQUB &00, &1A, &18, &1F, &FF, &FF
 EQUB &78, &03, &08, &FF, &73, &AA
 EQUB &78, &03, &08, &7F, &84, &CC

 EQUB &58, &10, &28, &BF, &FF, &FF
 EQUB &58, &10, &28, &3F, &FF, &FF
 EQUB &80, &08, &28, &7F, &98, &CC
 EQUB &80, &08, &28, &FF, &97, &AA
 EQUB &00, &1A, &28, &3F, &65, &99

 EQUB &20, &18, &28, &FF, &A9, &BB
 EQUB &20, &18, &28, &7F, &B9, &CC
 EQUB &24, &08, &28, &B4, &99, &99
 EQUB &08, &0C, &28, &B4, &99, &99
 EQUB &08, &0C, &28, &34, &99, &99

 EQUB &24, &08, &28, &34, &99, &99
 EQUB &24, &0C, &28, &74, &99, &99
 EQUB &08, &10, &28, &74, &99, &99
 EQUB &08, &10, &28, &F4, &99, &99
 EQUB &24, &0C, &28, &F4, &99, &99

 EQUB &00, &00, &4C, &06, &B0, &BB
 EQUB &00, &00, &5A, &1F, &B0, &BB
 EQUB &50, &06, &28, &E8, &99, &99
 EQUB &50, &06, &28, &A8, &99, &99
 EQUB &58, &00, &28, &A6, &99, &99

 EQUB &50, &06, &28, &28, &99, &99
 EQUB &58, &00, &28, &26, &99, &99
 EQUB &50, &06, &28, &68, &99, &99

 EQUB &1F, &B0, &00, &04            \ edges data (38*4)
 EQUB &1F, &C4, &00, &10
 EQUB &1F, &A3, &04, &0C
 EQUB &1F, &A7, &0C, &20
 EQUB &1F, &C8, &10, &1C

 EQUB &1F, &98, &18, &1C
 EQUB &1F, &96, &18, &24
 EQUB &1F, &95, &14, &24
 EQUB &1F, &97, &14, &20
 EQUB &1F, &51, &08, &14

 EQUB &1F, &62, &08, &18
 EQUB &1F, &73, &0C, &14
 EQUB &1F, &84, &10, &18
 EQUB &1F, &10, &04, &08
 EQUB &1F, &20, &00, &08

 EQUB &1F, &A9, &20, &28
 EQUB &1F, &B9, &28, &2C
 EQUB &1F, &C9, &1C, &2C
 EQUB &1F, &BA, &04, &28
 EQUB &1F, &CB, &00, &2C

 EQUB &1D, &31, &04, &14
 EQUB &1D, &42, &00, &18
 EQUB &06, &B0, &50, &54
 EQUB &14, &99, &30, &34
 EQUB &14, &99, &48, &4C

 EQUB &14, &99, &38, &3C
 EQUB &14, &99, &40, &44
 EQUB &13, &99, &3C, &40
 EQUB &11, &99, &38, &44
 EQUB &13, &99, &34, &48

 EQUB &13, &99, &30, &4C
 EQUB &1E, &65, &08, &24
 EQUB &06, &99, &58, &60
 EQUB &06, &99, &5C, &60
 EQUB &08, &99, &58, &5C

 EQUB &06, &99, &64, &68
 EQUB &06, &99, &68, &6C
 EQUB &08, &99, &64, &6C

 EQUB &1F, &00, &3E, &1F            \ faces data (13*4)
 EQUB &9F, &12, &37, &10            \ start normals #0 = top front plate of
 EQUB &1F, &12, &37, &10            \ Cobra
 EQUB &9F, &10, &34, &0E
 EQUB &1F, &10, &34, &0E

 EQUB &9F, &0E, &2F, &00
 EQUB &1F, &0E, &2F, &00
 EQUB &9F, &3D, &66, &00
 EQUB &1F, &3D, &66, &00
 EQUB &3F, &00, &00, &50

 EQUB &DF, &07, &2A, &09
 EQUB &5F, &00, &1E, &06
 EQUB &5F, &07, &2A, &09

.SHIP6                              \ Thargoid ship blueprint

 EQUB &00
 EQUB &49, &26
 EQUB &8C
 EQUB &F4
 EQUB &65
 EQUB &3C                           \ gun vertex = &3C / 4 = 15
 EQUB &26
 EQUB &78                           \ number of vertices = &78 / 6 = 20
 EQUB &1A                           \ number of edges = &1A = 26
 EQUW 500                           \ bounty = 500
 EQUB &28                           \ number of faces = &28 / 4 = 10
 EQUB &37
 EQUB &F0
 EQUB &27
 EQUB &00
 EQUB &00
 EQUB &02
 EQUB %00010110                     \ laser power = 2, missiles = 6

 EQUB &20, &30, &30, &5F, &40, &88  \ vertices data (20)
 EQUB &20, &44, &00, &5F, &10, &44
 EQUB &20, &30, &30, &7F, &21, &44
 EQUB &20, &00, &44, &3F, &32, &44
 EQUB &20, &30, &30, &3F, &43, &55

 EQUB &20, &44, &00, &1F, &54, &66
 EQUB &20, &30, &30, &1F, &64, &77
 EQUB &20, &00, &44, &1F, &74, &88
 EQUB &18, &74, &74, &DF, &80, &99
 EQUB &18, &A4, &00, &DF, &10, &99

 EQUB &18, &74, &74, &FF, &21, &99
 EQUB &18, &00, &A4, &BF, &32, &99
 EQUB &18, &74, &74, &BF, &53, &99
 EQUB &18, &A4, &00, &9F, &65, &99
 EQUB &18, &74, &74, &9F, &76, &99

 EQUB &18, &00, &A4, &9F, &87, &99
 EQUB &18, &40, &50, &9E, &99, &99
 EQUB &18, &40, &50, &BE, &99, &99
 EQUB &18, &40, &50, &FE, &99, &99
 EQUB &18, &40, &50, &DE, &99, &99

 EQUB &1F, &84, &00, &1C            \ edges data (26*4)
 EQUB &1F, &40, &00, &04
 EQUB &1F, &41, &04, &08
 EQUB &1F, &42, &08, &0C
 EQUB &1F, &43, &0C, &10

 EQUB &1F, &54, &10, &14
 EQUB &1F, &64, &14, &18
 EQUB &1F, &74, &18, &1C
 EQUB &1F, &80, &00, &20
 EQUB &1F, &10, &04, &24

 EQUB &1F, &21, &08, &28
 EQUB &1F, &32, &0C, &2C
 EQUB &1F, &53, &10, &30
 EQUB &1F, &65, &14, &34
 EQUB &1F, &76, &18, &38

 EQUB &1F, &87, &1C, &3C
 EQUB &1F, &98, &20, &3C
 EQUB &1F, &90, &20, &24
 EQUB &1F, &91, &24, &28
 EQUB &1F, &92, &28, &2C

 EQUB &1F, &93, &2C, &30
 EQUB &1F, &95, &30, &34
 EQUB &1F, &96, &34, &38
 EQUB &1F, &97, &38, &3C
 EQUB &1E, &99, &40, &44

 EQUB &1E, &99, &48, &4C

 EQUB &5F, &67, &3C, &19            \ faces data (10*4)
 EQUB &7F, &67, &3C, &19
 EQUB &7F, &67, &19, &3C
 EQUB &3F, &67, &19, &3C
 EQUB &1F, &40, &00, &00

 EQUB &3F, &67, &3C, &19
 EQUB &1F, &67, &3C, &19
 EQUB &1F, &67, &19, &3C
 EQUB &5F, &67, &19, &3C
 EQUB &9F, &30, &00, &00

.SHIP8                              \ Coriolis space station blueprint

 EQUB &00
 EQUB &00, &64
 EQUB &74
 EQUB &E4
 EQUB &55
 EQUB &00                           \ gun vertex = 0
 EQUB &36
 EQUB &60                           \ number of vertices = &60 / 6 = 16
 EQUB &1C                           \ number of edges = &1C = 28
 EQUW 0                             \ bounty = 0
 EQUB &38                           \ number of faces = &38 / 4 = 14
 EQUB &78
 EQUB &F0
 EQUB &00
 EQUB &00
 EQUB &00
 EQUB &00
 EQUB &06

 EQUB &A0, &00, &A0, &1F, &10, &62  \ vertices data (16*6)
 EQUB &00, &A0, &A0, &1F, &20, &83
 EQUB &A0, &00, &A0, &9F, &30, &74
 EQUB &00, &A0, &A0, &5F, &10, &54
 EQUB &A0, &A0, &00, &5F, &51, &A6

 EQUB &A0, &A0, &00, &1F, &62, &B8
 EQUB &A0, &A0, &00, &9F, &73, &C8
 EQUB &A0, &A0, &00, &DF, &54, &97
 EQUB &A0, &00, &A0, &3F, &A6, &DB
 EQUB &00, &A0, &A0, &3F, &B8, &DC

 EQUB &A0, &00, &A0, &BF, &97, &DC
 EQUB &00, &A0, &A0, &7F, &95, &DA
 EQUB &0A, &1E, &A0, &5E, &00, &00
 EQUB &0A, &1E, &A0, &1E, &00, &00
 EQUB &0A, &1E, &A0, &9E, &00, &00

 EQUB &0A, &1E, &A0, &DE, &00, &00

 EQUB &1F, &10, &00, &0C            \ edges data (28*4)
 EQUB &1F, &20, &00, &04
 EQUB &1F, &30, &04, &08
 EQUB &1F, &40, &08, &0C
 EQUB &1F, &51, &0C, &10

 EQUB &1F, &61, &00, &10
 EQUB &1F, &62, &00, &14
 EQUB &1F, &82, &14, &04
 EQUB &1F, &83, &04, &18
 EQUB &1F, &73, &08, &18

 EQUB &1F, &74, &08, &1C
 EQUB &1F, &54, &0C, &1C
 EQUB &1F, &DA, &20, &2C
 EQUB &1F, &DB, &20, &24
 EQUB &1F, &DC, &24, &28

 EQUB &1F, &D9, &28, &2C
 EQUB &1F, &A5, &10, &2C
 EQUB &1F, &A6, &10, &20
 EQUB &1F, &B6, &14, &20
 EQUB &1F, &B8, &14, &24

 EQUB &1F, &C8, &18, &24
 EQUB &1F, &C7, &18, &28
 EQUB &1F, &97, &1C, &28
 EQUB &1F, &95, &1C, &2C
 EQUB &1E, &00, &30, &34

 EQUB &1E, &00, &34, &38
 EQUB &1E, &00, &38, &3C
 EQUB &1E, &00, &3C, &30

 EQUB &1F, &00, &00, &A0            \ faces data (14*4)
 EQUB &5F, &6B, &6B, &6B
 EQUB &1F, &6B, &6B, &6B
 EQUB &9F, &6B, &6B, &6B
 EQUB &DF, &6B, &6B, &6B

 EQUB &5F, &00, &A0, &00
 EQUB &1F, &A0, &00, &00
 EQUB &9F, &A0, &00, &00
 EQUB &1F, &00, &A0, &00
 EQUB &FF, &6B, &6B, &6B

 EQUB &7F, &6B, &6B, &6B
 EQUB &3F, &6B, &6B, &6B
 EQUB &BF, &6B, &6B, &6B
 EQUB &3F, &00, &00, &A0

.SHIP9                              \ Missile blueprint

 EQUB &00
 EQUB &40, &06
 EQUB &7A
 EQUB &DA
 EQUB &51
 EQUB &00                           \ gun vertex = 0
 EQUB &0A
 EQUB &66                           \ number of vertices = &66 / 6 = 17
 EQUB &18                           \ number of edges = &18 = 24
 EQUW 0                             \ bounty = 0
 EQUB &24                           \ number of faces = &24 / 4 = 9
 EQUB &0E
 EQUB &02
 EQUB &2C
 EQUB &00
 EQUB &00
 EQUB &02
 EQUB %00000000                     \ laser power = 0, missiles = 0

 EQUB &00, &00, &44, &1F, &10, &32  \ vertices data (17*6)
 EQUB &08, &08, &24, &5F, &21, &54
 EQUB &08, &08, &24, &1F, &32, &74
 EQUB &08, &08, &24, &9F, &30, &76
 EQUB &08, &08, &24, &DF, &10, &65

 EQUB &08, &08, &2C, &3F, &74, &88
 EQUB &08, &08, &2C, &7F, &54, &88
 EQUB &08, &08, &2C, &FF, &65, &88
 EQUB &08, &08, &2C, &BF, &76, &88
 EQUB &0C, &0C, &2C, &28, &74, &88

 EQUB &0C, &0C, &2C, &68, &54, &88
 EQUB &0C, &0C, &2C, &E8, &65, &88
 EQUB &0C, &0C, &2C, &A8, &76, &88
 EQUB &08, &08, &0C, &A8, &76, &77
 EQUB &08, &08, &0C, &E8, &65, &66

 EQUB &08, &08, &0C, &28, &74, &77
 EQUB &08, &08, &0C, &68, &54, &55

 EQUB &1F, &21, &00, &04            \ edges data (24*4)
 EQUB &1F, &32, &00, &08
 EQUB &1F, &30, &00, &0C
 EQUB &1F, &10, &00, &10
 EQUB &1F, &24, &04, &08

 EQUB &1F, &51, &04, &10
 EQUB &1F, &60, &0C, &10
 EQUB &1F, &73, &08, &0C
 EQUB &1F, &74, &08, &14
 EQUB &1F, &54, &04, &18

 EQUB &1F, &65, &10, &1C
 EQUB &1F, &76, &0C, &20
 EQUB &1F, &86, &1C, &20
 EQUB &1F, &87, &14, &20
 EQUB &1F, &84, &14, &18

 EQUB &1F, &85, &18, &1C
 EQUB &08, &85, &18, &28
 EQUB &08, &87, &14, &24
 EQUB &08, &87, &20, &30
 EQUB &08, &85, &1C, &2C

 EQUB &08, &74, &24, &3C
 EQUB &08, &54, &28, &40
 EQUB &08, &76, &30, &34
 EQUB &08, &65, &2C, &38

 EQUB &9F, &40, &00, &10            \ faces data (9*4)
 EQUB &5F, &00, &40, &10
 EQUB &1F, &40, &00, &10
 EQUB &1F, &00, &40, &10
 EQUB &1F, &20, &00, &00

 EQUB &5F, &00, &20, &00
 EQUB &9F, &20, &00, &00
 EQUB &1F, &00, &20, &00
 EQUB &3F, &00, &00, &B0

.SHIP10                             \ Asteroid blueprint

 EQUB &00
 EQUB &00, &19
 EQUB &4A
 EQUB &9E
 EQUB &41
 EQUB &00                           \ gun vertex = 0
 EQUB &22
 EQUB &36                           \ number of vertices = &36 / 6 = 9
 EQUB &15                           \ number of edges = &15 = 21
 EQUW 5                             \ bounty = 5
 EQUB &38                           \ number of faces = &38 / 4 = 14
 EQUB &32
 EQUB &3C
 EQUB &1E
 EQUB &00
 EQUB &00
 EQUB &01
 EQUB %00000000                     \ laser power = 0, missiles = 0

 EQUB &00, &50, &00, &1F, &FF, &FF  \ vertices data (25*9)
 EQUB &50, &0A, &00, &DF, &FF, &FF
 EQUB &00, &50, &00, &5F, &FF, &FF
 EQUB &46, &28, &00, &5F, &FF, &FF
 EQUB &3C, &32, &00, &1F, &65, &DC

 EQUB &32, &00, &3C, &1F, &FF, &FF
 EQUB &28, &00, &46, &9F, &10, &32
 EQUB &00, &1E, &4B, &3F, &FF, &FF
 EQUB &00, &32, &3C, &7F, &98, &BA

 EQUB &1F, &72, &00, &04            \ edges data (21*4)
 EQUB &1F, &D6, &00, &10
 EQUB &1F, &C5, &0C, &10
 EQUB &1F, &B4, &08, &0C
 EQUB &1F, &A3, &04, &08

 EQUB &1F, &32, &04, &18
 EQUB &1F, &31, &08, &18
 EQUB &1F, &41, &08, &14
 EQUB &1F, &10, &14, &18
 EQUB &1F, &60, &00, &14

 EQUB &1F, &54, &0C, &14
 EQUB &1F, &20, &00, &18
 EQUB &1F, &65, &10, &14
 EQUB &1F, &A8, &04, &20
 EQUB &1F, &87, &04, &1C

 EQUB &1F, &D7, &00, &1C
 EQUB &1F, &DC, &10, &1C
 EQUB &1F, &C9, &0C, &1C
 EQUB &1F, &B9, &0C, &20
 EQUB &1F, &BA, &08, &20

 EQUB &1F, &98, &1C, &20

 EQUB &1F, &09, &42, &51            \ faces data (14*4)
 EQUB &5F, &09, &42, &51
 EQUB &9F, &48, &40, &1F
 EQUB &DF, &40, &49, &2F
 EQUB &5F, &2D, &4F, &41

 EQUB &1F, &87, &0F, &23
 EQUB &1F, &26, &4C, &46
 EQUB &BF, &42, &3B, &27
 EQUB &FF, &43, &0F, &50
 EQUB &7F, &42, &0E, &4B

 EQUB &FF, &46, &50, &28
 EQUB &7F, &3A, &66, &33
 EQUB &3F, &51, &09, &43
 EQUB &3F, &2F, &5E, &3F

.SHIP11                             \ Cargo canister blueprint

 EQUB &00
 EQUB &90, &01
 EQUB &50
 EQUB &8C
 EQUB &31
 EQUB &00                           \ gun vertex = 0
 EQUB &12
 EQUB &3C                           \ number of vertices = &3C / 6 = 10
 EQUB &0F                           \ number of edges = &0F = 15
 EQUW 0                             \ bounty = 0
 EQUB &1C                           \ number of faces = &1C / 4 = 7
 EQUB &0C
 EQUB &11
 EQUB &0F
 EQUB &00
 EQUB &00
 EQUB &02
 EQUB %00000000                     \ laser power = 0, missiles = 0

 EQUB &18, &10, &00, &1F, &10, &55  \ vertices data (10*6)
 EQUB &18, &05, &0F, &1F, &10, &22
 EQUB &18, &0D, &09, &5F, &20, &33
 EQUB &18, &0D, &09, &7F, &30, &44
 EQUB &18, &05, &0F, &3F, &40, &55

 EQUB &18, &10, &00, &9F, &51, &66
 EQUB &18, &05, &0F, &9F, &21, &66
 EQUB &18, &0D, &09, &DF, &32, &66
 EQUB &18, &0D, &09, &FF, &43, &66
 EQUB &18, &05, &0F, &BF, &54, &66

 EQUB &1F, &10, &00, &04            \ edges data (15*4)
 EQUB &1F, &20, &04, &08
 EQUB &1F, &30, &08, &0C
 EQUB &1F, &40, &0C, &10
 EQUB &1F, &50, &00, &10

 EQUB &1F, &51, &00, &14
 EQUB &1F, &21, &04, &18
 EQUB &1F, &32, &08, &1C
 EQUB &1F, &43, &0C, &20
 EQUB &1F, &54, &10, &24

 EQUB &1F, &61, &14, &18
 EQUB &1F, &62, &18, &1C
 EQUB &1F, &63, &1C, &20
 EQUB &1F, &64, &20, &24
 EQUB &1F, &65, &24, &14

 EQUB &1F, &60, &00, &00            \ faces data (7*4)
 EQUB &1F, &00, &29, &1E
 EQUB &5F, &00, &12, &30
 EQUB &5F, &00, &33, &00
 EQUB &7F, &00, &12, &30

 EQUB &3F, &00, &29, &1E
 EQUB &9F, &60, &00, &00

.SHIP12                             \ Thargon ship blueprint

 EQUB &00
 EQUB &40, &06
 EQUB &A8                           \ use canister edge data at &FFA8 = -88
 EQUB &50
 EQUB &41
 EQUB &00                           \ gun vertex = 0
 EQUB &12
 EQUB &3C                           \ number of vertices = &3C / 6 = 10
 EQUB &0F                           \ number of edges = &0F = 15
 EQUW 50                            \ bounty = 50
 EQUB &1C                           \ number of faces = &1C / 4 = 7
 EQUB &14
 EQUB &14
 EQUB &1E
 EQUB &FF                           \ use canister edge data at &FFA8 = -88
 EQUB &00
 EQUB &02
 EQUB %00010000                     \ laser power = 2, missiles = 0

 EQUB &09, &00, &28, &9F, &01, &55  \ vertices data (10*6)
 EQUB &09, &26, &0C, &DF, &01, &22
 EQUB &09, &18, &20, &FF, &02, &33
 EQUB &09, &18, &20, &BF, &03, &44
 EQUB &09, &26, &0C, &9F, &04, &55

 EQUB &09, &00, &08, &3F, &15, &66
 EQUB &09, &0A, &0F, &7F, &12, &66
 EQUB &09, &06, &1A, &7F, &23, &66
 EQUB &09, &06, &1A, &3F, &34, &66
 EQUB &09, &0A, &0F, &3F, &45, &66

 EQUB &9F, &24, &00, &00            \ faces data (7*4)
 EQUB &5F, &14, &05, &07
 EQUB &7F, &2E, &2A, &0E
 EQUB &3F, &24, &00, &68
 EQUB &3F, &2E, &2A, &0E

 EQUB &1F, &14, &05, &07
 EQUB &1F, &24, &00, &00

.SHIP13                             \ Escape pod blueprint

 EQUB &00
 EQUB &00, &01
 EQUB &2C
 EQUB &44
 EQUB &19
 EQUB &00                           \ gun vertex = 0
 EQUB &16
 EQUB &18                           \ number of vertices = &18 / 6 = 4
 EQUB &06                           \ number of edges = &06 = 6
 EQUW 0                             \ bounty = 0
 EQUB &10                           \ number of faces = &10 / 4 = 4
 EQUB &08
 EQUB &11
 EQUB &08
 EQUB &00
 EQUB &00
 EQUB &03
 EQUB %00000000                     \ laser power = 0, missiles = 0

 EQUB &07, &00, &24, &9F, &12, &33  \ vertices data (4*6)
 EQUB &07, &0E, &0C, &FF, &02, &33
 EQUB &07, &0E, &0C, &BF, &01, &33
 EQUB &15, &00, &00, &1F, &01, &22

 EQUB &1F, &23, &00, &04            \ edges data (6*4)
 EQUB &1F, &03, &04, &08
 EQUB &1F, &01, &08, &0C
 EQUB &1F, &12, &0C, &00
 EQUB &1F, &13, &00, &08

 EQUB &1F, &02, &0C, &04

 EQUB &3F, &1A, &00, &3D            \ faces data (4*4)
 EQUB &1F, &13, &33, &0F
 EQUB &5F, &13, &33, &0F
 EQUB &9F, &38, &00, &00

\ ******************************************************************************
\
\ Save output/SHIPS.bin
\
\ ******************************************************************************

PRINT "SHIPS"
PRINT "Assembled at ", ~CODE_SHIPS%
PRINT "Ends at ", ~P%
PRINT "Code size is ", ~(P% - CODE_SHIPS%)
PRINT "Execute at ", ~LOAD%
PRINT "Reload at ", ~LOAD_SHIPS%

PRINT "S.SHIPS ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
SAVE "output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%

\ ******************************************************************************
\
\ Show free space
\
\ ******************************************************************************

PRINT "ELITE game code ", ~(&6000-P%), " bytes free"
PRINT "Ends at ", ~P%
